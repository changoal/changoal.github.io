{"pages":[{"title":"about","text":"Android 开发者 喜欢 Python 皇马，鲁能死忠 享受技术，拥抱开源","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"links","text":"","link":"/links/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"timeline","text":"","link":"/timeline/index.html"}],"posts":[{"title":"2018 end","text":"2018 总结转眼间 2018 已经结束了。还是很丰富的一年。 我是一个仪式感很强的人，临近新年时，并没有别人那种期待欢喜的感觉，却总是有一种离别的失落感。 工作5 月底的时候终于离职了，在经过一个月的项目交接之后我离开了毕业后加入的第一家公司，对老东家谈不上感激，大家也就是好聚好散。这算是我第一份正式的工作，还是学到了很多的东西的，包括技术、项目、合作等等，因为对未来的规划以及薪资上的问题 3 月底就确定要离职，之后一直在准备面试。因为准备的时间很长，准备的也比较充分，两天就拿到两个 offer，虽然都不是大厂，其中选择了一家比较有前景的公司就直接入职了。后来觉得太着急了，其实该多面试找找机会的。在公司的这半年时间里，经历了还是很多的，封闭开发，两个月的调休期，拖欠工资，公司倒闭…..好充实的。 Python 还是一直在学的，但是效率太低，发现问题在于只是看书或者教程，自己很少写代码，而且完全没有在工作中用到。后来自己试着去写 wallhaven 的爬虫，学着去操作数据库，尝试 web开发。未来学习的方向想放在商业化爬虫以及数据可视化处理上。 Android 还是一直在发展的，今年的主要研究方向在项目框架、Kotlin、RxJava 还有 Dagger，“纸上得来终觉浅 ” 在学习的过程中有时候感觉这些知识点自己已经掌握了，但是到了自己实际使用的时候还是会出现很多的问题，还有就是学完之后一定要在项目中去使用，去试着思考使用场景、bug、设计模式等等，否则遗忘的时间是很快的。在学习 Kotlin，Python 以及阅读 Github 优秀开源项目的时候，逐渐理解了所谓的编程思想，总之学无止境，还有很多需要进步的地方。 Android 行业今年有些疲软，工作岗位已经少了很多了，但我相信“高级程序员”的数量还是很少的，暂时还是打算继续走这条路。今年有一点小小的学习感触，一段时间内最好是只学习一个知识点，大量的寻找相关的博客、教程等等，关键的地方一定要做笔记，有一段时间是很浮躁的，因为发现有特别多需要学习的，又没有好的学习方式，所以导致心态有些问题。后来看到胡适先生的一句话“怕什么真理无穷，进一寸有一寸的欢喜”，豁然开朗。 出行虽然今年休息的时间挺多的，但是也没怎么出去玩，也就去了德州和天津吧。在德州三天不是睡觉就是喝酒…也是福气。天津这座城市我还是挺喜欢的，可能是在北京呆的时间太久了，觉得其他地方生活节奏都慢一些，给了人们更多生活享受的时间，整个人一下就放松了，很舒服。因为城区有三条主河流的原因，整个城市都是挺漂亮的，“天津之眼”仿佛让我回到了在黄岛的时候，不止一次地说过大学是我人生中目前为止最快乐最自由的一段时光，满满的都是回忆。五大道就像是青岛的八大关，德式建筑，不过多了些商业气息。CBD 那边给人一种香港维多利亚港的感觉，夜景无敌。不过天津菜我是真的不喜欢，煎饼果子也没有想象中的那么好。 哈尔滨，呼和浩特，黄山，成都是我目前最想去的国内城市，希望明年有机会的话最少能去其中两个城市。体验人间的各种风情。 娱乐围城 红拂夜奔 商博良 九州·缥缈录 流畅的Python Android开发艺术探索 计算机网络教程：自顶向下方法 今年还是看了很多电影的，个人心中的2018年度最佳：我不是药神，红海行动，大护法，大象席地而坐（还没看），是的，都是国产电影。《我不是药神》让我看到了一种希望，只愿这会是一个好的开始。《红海行动》证明了国产电影也可以是世界级的，林超贤导演依旧没有让观众失望，一部满分的军队宣传片。《大护法》国产最佳动漫，不解释。《大象席地而坐》，有些电影不用去看就可以成为最佳影片。 今年看书还是挺少的，除去江南的那些小说，只有好多朋友推荐的《围城》和第一部完整看完的王小波的小说《红拂夜奔》。两本都是好书，可惜自己的能力实在太差，没资格评价。 皇马欧冠三连，可是我罗走了，齐祖走了，物是人非。 鲁能虽然四大皆空，但是在现有的人员基础上联赛第三，足协杯亚军，也算是超常发挥了。 希望明年我团我鲁都有好的发挥。 生活今年买了好多电子产品，捡个人觉得还不错的介绍下吧。 MSI GL63。七月初入手的，换掉了陪了我五年的 lenovo，摇身一变成了龙骑士，配置是 i7 8750h + 16g ddr4 + 128 ssd + 1T hhd，性能强劲，造型漂亮，缺点就是 128 的 ssd 容量还是太小，屏幕边框太宽，整体来说还是很不错的。 SHP9500。年度最大惊喜，直接就提升了我的生活品质。没有好的前端，只是用在电脑上，音质不多评价，性价比之王。 Xiaomi8。最失望的产品，信号极差，屏幕极差。 Filco 87。双十一的时候终于剁手心心念念了好久的大 F，带给我的惊喜丝毫不差于第一次摸到机械键盘，那触感，那声音，美妙至极，从此打字变成了一种享受，只是多了一丝惭愧感，写的代码配不上这把键盘。 思考主题，做一件事一定要有一个主题。这是从大宝教我的摄影知识以及陈晓卿导演的点菜座谈上得到的感悟。摄影里，一张好的作品都是有一个主题的，而且是只有一个，没有主题的话，作品再漂亮也只是“形”，主题多的话会太杂。点菜的时候，一种好的方式是先点一个“重要”的菜，根据这道菜来选择其他搭配的菜。一个人的精力并不多，大部分情况下同一时间只能做好一件事。 在看《铿锵三人行》的时候发现窦文涛有一档新栏目-《圆桌派》，三个月的时间听完了三季的所有剧集。人跟人之间的差距是很大的，听他们的座谈，了解到了很多小知识点，而且三观极正，在现在这个物欲横流娱乐至死的时代里，这档节目真的不可多得。 同样，还有 stormzhang 和 Fenng ，“人这一生，不同领域的认知偏差太大，向不同领域的最顶尖牛人学习，自认为是修高效的一种学习方式，他们积累的经验，对后辈们是及其宝贵的财富”。 寄语以上流水账式的文字清晰的总结了我的这一年，就像过去的那么多年一样，普通，无趣，甚至都找不到一个出彩的词来形容。就刚才，李志的 2019 洗心革面的跨年演唱会上，他说“2018 过去了，我不怀念它”，于是我又回想了下这一年，还是发生了很多有趣的故事的，不后悔。 2019 只希望能做到 “有意义”，一点一点实现定下的那些小目标，做个善良的人，独立思考，用心生活。 相信未来。 欲买桂花同载酒，终不似，少年游。","link":"/2018/12/31/2018-end/"},{"title":"60day","text":"每个人心里都有一团火，路过的人只看到烟。但总有一个人，总有那么一个人能看到这团火，然后走过来，陪我一起。我带着我的热情，我的冷漠，我的狂暴，我的温和，以及对爱情毫无理由的相信，走的上气不接下气。我结结巴巴对她说：你叫什么名字。从你叫什么名字开始，后来，有了一切。 ——梵高 清总终于也找女朋友了。认识清总快八年了，也偶尔听到过绯闻，到最终都被证明为假消息，也许是真的，但他就是不承认。就在我刚要认为他是我认识的第一个不考虑“感情”的男生的时候。他给我发了一张照片，很清秀的一个女生挺漂亮的。有时候就是这样，老韩说他有女朋友的时候压根就没人相信，因为大家都认为他不可能有女朋友，当他在开玩笑，可是他还真的有。我问清总她是哪个学校的时候，吞吞吐吐的就是不说，我也想到了，大概是怕我看不起吧。后来，清总发消息说她是专科的，比他小好几岁。有种似曾相识的感觉。看过这样剧情的电影或文章吧。我想如果是我的话我会怎样呢，为了面子，不说？希望他俩能走下去吧。 周四的时候突然想做个公众号，没想到几分钟就申请下来了，太快了吧。当申请完了才想，又有什么用呢，只给自己看。这周断断续续的看完了《小森林》。非常小清新的一部电影，它的主意应该是乡村和大城市之间的矛盾。但是我只看到了一点，哪怕只有一个人，也要好好生活，好好照顾自己。台湾有个导演说，「一个人」的状态总是最糟的，哪怕养条狗，你都不是一个人，你要对它负责任，只要你不是一个人，你的生命就不会没有意义。所以，一个人也要好好生活，好好照顾自己呀。 最近听到不少同学保研成功的消息。有的是人大数据库直博，王琪是中科院数据挖掘。我承认我是有些后悔了，后悔自己当初太懦弱，目光太短浅。但就像清总说的，后悔又有什么用，不要后悔。 我还是太爱玩了，两个月的时间里，FIFAOL3已经安装卸载了好几遍。还有就是心里承受能力太差，有时候晚上睡觉想起来还挂着三科就睡不着了。我有一个缺点，事情发生的时候，只知道害怕，只知道抱怨，却不去想怎么解决。这个要改了。 想了想，还是不写你了。","link":"/2016/09/26/60day/"},{"title":"5.17","text":"网站推荐几个好用的软件和网站吧 第一个肯定是 github 了，这种神站，只能说你想要的它都有 然后就是 知乎 了吧，这个应该都知道吧，开放注册之后，用户爆发式的增长，看个段子还是挺好的。 还有 lofter，可以在上面找图啊，图的质量都很高哦，果然是良心网易。 最最最要推荐的当然是 google，用习惯之后你就知道百度是什么货色了。翻墙大法好，墙外的世界更大。 还有两个我自己平常喜欢去的网站 zealer 和 数字尾巴，网页太漂亮了。 软件首先是 chrome 了，谷歌家的都好用，自从看到了 Material Design ，我就成了谷歌脑残粉。chrome 一定要用插件，同样需要翻墙。推荐用Adblock Plus，装上之后广告基本消失在你的浏览器里，眼不见心不烦。 音乐播放器用 网易云音乐 啊，看视频的话用 Potplayer 。 最近刚开始用 Markdown ，简直好用到爆，怪不得这么多人推荐，编辑器的话我现在用的是 MarkdownPad2。 手机app的话，个人推荐 印象笔记 和 Any.do ，没有为什么，只是因为界面好看/微笑。 暂时就这些了，如果有的话以后再更新喽。 P.S. 本来打算第一篇写技术的，想了好久发现自己啥都不会。。 下午一直在弄域名，下手晚了，不但连 liuchang.com 被注册了，连 changoal.com 都不给我留。。好歹还有 changoal.cn，正在备案中，估计十天之后就可以用了吧。","link":"/2016/05/17/5-17/"},{"title":"Android ListView无数据时显示其他View","text":"大家都遇到过这样的情况，当 ListView 中的数据为空时，需要显示一个 “没有数据” 的 View 。想过一些办法，比如 FrameLayout 来 包含 ListView 和 数据为空时的 View，当有数据时隐藏空 View，没有数据时显示空 View。或者是给 ListView 添加一个 header 或 footer。但是今天看到了一种更简单的方案，下面来介绍一下。 先贴一下今天看到的代码 布局文件 1234567891011121314151617&lt;FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;ListView android:id=\"@android:id/list\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt; &lt;TextView android:id=\"@android:id/empty\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:gravity=\"center\" android:text=\"No items.\" /&gt;&lt;/FrameLayout&gt; Activity12345678910111213141516171819202122232425public class MainActivity extends ListActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_list_item_1, generateStrings()); setListAdapter(adapter); } private String[] generateStrings() { String[] strings = new String[0]; for (int i = 0; i &lt; strings.length; ++i) { strings[i] = \"String \" + i; } return strings; }} Activity 是继承自 ListActivity ，到这里代码都能看懂。奇怪的一点是布局文件中 android:id=&quot;@android:id/empty&quot; id 是这样写的。在网上查了一下，这个属性的作用就是，当 ListView 关联的 Adapter 的数据为时，就显示这个 id 为 @android:id/empty 的 View。而当数据不为空时，这个 空 View 就不可见。 如果在不是继承自 ListActivity 的话，上面的那个属性没有作用，TextView 会是一直可见的状态。 所以如果是不继承 ListActivity 的情况下，需要在代码中调用 listView.setEmptyView(nullView) 来设置 listView 数据为空时 显示 nullView 。 样例代码如下： 12345678910111213141516171819&lt;FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;ListView android:id=\"@+id/myList\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt; &lt;!-- Here is the view to show if the list is emtpy --&gt; &lt;TextView android:id=\"@+id/myText\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:gravity=\"center\" android:text=\"No items.\" /&gt;&lt;/FrameLayout&gt; 123456789101112131415161718192021222324252627public class MainActivity extends Activity { private ListView mListView = null; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mListView = (ListView) findViewById(R.id.myList); mListView.setEmptyView(findViewById(R.id.myText)); ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_list_item_1, generateStrings()); mListView.setAdapter(adapter); } private String[] generateStrings() { String[] strings = new String[100]; for (int i = 0; i &lt; strings.length; ++i) { strings[i] = \"String \" + i; } return strings; }}","link":"/2017/08/24/Android-ListView无数据时显示其他View/"},{"title":"AS导出so文件","text":"1.新建java类Test.java，在类中声明一个native方法 123static { System.loadLibrary(\"jnitest\");} 2.进入到类所在文件夹javac Test.java 生成Test.class 3.返回到java目录 javah -jni com.example.jnitest.Test 生成com_example_jnitest_Test.h 4.新建com_example_jnitest_Test.c，把.h里的内容拷过去，写里面的方法 5.在build.gradle添加 12345ndk { moduleName \"sffstreamer\" ldLibs \"log\", \"z\", \"m\" abiFilters \"armeabi\", \"armeabi-v7a\", \"x86\"} 还有 12345sourceSets { main { jni.srcDirs = [] }} Build.gradle文件如下： 1234567891011121314151617181920212223242526272829android { compileSdkVersion 24 buildToolsVersion \"25.0.2\" defaultConfig { applicationId \"com.ishow3d.ffmpegjni\" minSdkVersion 15 targetSdkVersion 24 versionCode 1 versionName \"1.0\" testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\" ndk { moduleName \"sffstreamer\" ldLibs \"log\", \"z\", \"m\" abiFilters \"armeabi\", \"armeabi-v7a\", \"x86\" } } buildTypes { release { minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' } sourceSets { main { jni.srcDirs = [] } } }}","link":"/2017/04/30/AS导出so文件/"},{"title":"Android View事件分发","text":"前段时间看了《Android开发艺术探索》，关于 Android 事件分发，写了一些笔记。事件分发机制的伪代码。 12345678910public boolean dispatchTouchEvent(MotionEvent event){ boolean consume = false; if(onInterceptTouchEvent(ev)){ consume = onTouchEvent(ev); } else{ consume = child.dispatchTouchEvent(ev); } return consume;} 对于一个根 ViewGroup 来说，点击事件产生后，首先会传递给它，它的 dispatchTouchEvent 方法会被调用，如果这个 ViewGroup 的 onInterceptTouchEvent 方法返回 true 则表示它要拦截此事件，事件就会交给它自己处理，即调用它的 onTouchEvent 方法；如果它的 onInterceptTouchEvent 方法返回 false 表示不会拦截这个事件，当前事件就会传递给它的子元素，子元素的 dispatchTouchEvent 方法会被调用，如此循环知道事件被处理。 当一个 View 需要处理事件时，如果它已经设置了 OnTouchListener，那么 OnTouchListener 中的 onTouch 方法会被回调，这是事件如何处理还要看 onTouch 的返回值，如果返回 true 则当前 View 的 onTouchEvent 方法会被调用；如果返回 false ，那么 onTouchEvent 方法不会被调用。由此可见方法的优先级 onTouch &gt; onTouchEvent &gt; onClick。 点击事件的传递过程遵循以下顺序：Activity -&gt; Window -&gt; View，即事件总是先传递给 Activity，Activity 再传递给 Window，最后再传递给顶级 View，顶级 View 接收到事件后，就会按照事件分发机制分发事件。 如果一个 View 的 OnTouchEvent 方法返回 false，那么他的父容器的 OnTouchEvent 会被调用，以此类推。如果所有的元素都不处理这个事件，那么这个事件最终会传递给 Activity 处理。 注意： 同一个事件序列是指从手指接触屏幕的那一刻起，到手指离开屏幕的那一刻结束，在这个过程中产生的一系列事件，这个事件序列以 down 事件开始，中间含有数量不定的 move 事件，最终以 up事件结束。 正常情况下，一个事件序列只能被一个 View 拦截并消耗。因为一旦一个元素拦截了某事件，那么同一个序列内的所有事件都会直接交给他处理，因此同一个序列中的事件不能分别有两个 View 同时处理。但是通过特殊手段可以做到，比如一个 View 将本该有它处理的事件通过 OnTouchEvent 强行传递给其他 View 处理。 某个 View 一旦决定拦截，那么这一个事件序列都只能由它来处理（如果事件序列能够传递给它的话），并且它的 onInterceptTouchEvent 方法不会再被调用。 某个 View 一旦开始处理事件，如果它不消耗 ACTION_DOWN 事件，那么同一个事件序列里的其他事件都不会再交给他处理，并且事件将重新交由它的父元素去处理，即父元素的 onTouchEvent 方法会被调用。 如果 View 不消除掉 ACTION_DOWN 之外的其他事件，那么这个点击事件就会消失，此时父元素的 onTouchEvent 并不会被调用，并且当前 View 可以持续收到后续的事件，最终这些消失的点击事件会传递给 Activity 处理。 ViewGroup 方法默认不拦截任何事件。Android 源码中 ViewGroup 的 onInterceptTouchEvent 方法默认返回 false。 View 没有 onInterceptTouchEvent 方法，只有有子元素的元素才有。所以只要有点击事件传递给 View，就会调用它的 onTouchEvent 方法。 View 的 onTouchEvent 默认都会消耗事件，除非它是不可点击的。View 的 longClickable 属性默认都为 false。 View 的 enable 属性不影响 onTouchEvent 的默认返回值。哪怕一个 View 是 disable 状态的，只要它的 clickable 和 longClickable 有一个为 true，那么它的 onTouchEvent 就返回 true。 onClick 发生的前提是当前 View 是可点击的。并且它收到了 down 和 up 的事件。 事件传递过程是由外到内的，即事件总是先传递给父元素，然后再由父元素下发到子元素。","link":"/2018/02/26/Android-View事件分发/"},{"title":"Android 动态权限申请","text":"简介 Android6.0以上把权限分为普通权限和危险权限，所以危险权限是需要动态申请，给予用户提示的。 看到上面的 permissions，会发现一个问题，危险权限都是一组一组的。 分组对权限机制的申请是有一定影响的。例如app运行在android 6.x的机器上，对于授权机制是这样的。如果你申请某个危险的权限，假设你的app早已被用户授权了同一组的某个危险权限，那么系统会立即授权，而不需要用户去点击授权。比如你的app对 READ_CONTACTS 已经授权了，当你的app申请 WRITE_CONTACTS 时，系统会直接授权通过。 此外，对于申请时的弹窗上面的文本说明也是对整个权限组的说明，而不是单个权限。 动态权限申请1.首先要保证在AndroidManifest中写明需要的权限。123&lt;uses-permission android:name=\"android.permission.READ_CONTACTS\" /&gt;&lt;uses-permission android:name=\"android.permission.WRITE_CONTACTS\" /&gt;&lt;uses-permission android:name=\"android.permission.CAMERA\"/&gt; 2.权限申请示例 以获取定位权限为例。 点击按钮，检查并申请权限1234567891011121314151617btn.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { if (Build.VERSION.SDK_INT &gt;23) { if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.ACCESS_COARSE_LOCATION) == PackageManager.PERMISSION_GRANTED) { //授予权限 getLoation(); }else{ //未获得权限 requestPermissions(new String[]{Manifest.permission.ACCESS_COARSE_LOCATION} ,REQUEST_CODE_LOCATION); } } } }); 如果有权限，执行获取位置逻辑，如果没权限，则进行请求权限。 权限申请结果回调1234567891011121314151617181920212223@Overridepublic void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { if (requestCode == REQUEST_CODE_LOCATION){ if (grantResults[0] == PackageManager.PERMISSION_GRANTED){ getLoation(); } else{ if (shouldShowRequestPermissionRationale( Manifest.permission.ACCESS_COARSE_LOCATION)){ new AlertDialog.Builder(this) .setMessage(\"申请定位权限,才能为你推送更准确的信息\") .setPositiveButton(\"确定\", new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { //申请定位权限 requestPermissions(MainActivity.this, new String[]{Manifest.permission.ACCESS_COARSE_LOCATION}, REQUEST_CODE_LOCATION); } }).show(); } } return; } super.onRequestPermissionsResult(requestCode, permissions, grantResults);} 如果同意，执行获取位置逻辑，如果拒绝，重写 shouldShowRequestPermissionRationale 方法，返回 true,向用户弹窗给出一个获取权限的提示，点击后再次申请权限。 1234567public boolean shouldShowRequestPermissionRationale(@NonNull String permission) { if (permission.equals(Manifest.permission.ACCESS_COARSE_LOCATION) ) { return true; } else { return super.shouldShowRequestPermissionRationale(permission); }} 重写shouldShowRequestPermissionRationale，在申请位置权限时，返回true，给用户解释。 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class PermissionActivity extends AppCompatActivity implements View.OnClickListener { private static final String TAG = \"PermissionActivity\"; public static final int REQUEST_CAMERA = 1; private ConstraintLayout constraintLayout; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_permission); initView(); } private void initView() { constraintLayout = findViewById(R.id.mainLayout); findViewById(R.id.btn_camera).setOnClickListener(this); findViewById(R.id.btn_contact).setOnClickListener(this); } @RequiresApi(api = Build.VERSION_CODES.M) private boolean checkPermission(String permission) { int i = checkSelfPermission(permission); return i != PackageManager.PERMISSION_DENIED; } private void showSnackbar(String message) { Snackbar.make(constraintLayout, message, Snackbar.LENGTH_SHORT).show(); } @Override public void onClick(View v) { switch (v.getId()) { case R.id.btn_camera: showCamera(); break; case R.id.btn_contact: break; } } private void showCamera() { if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) { if (checkPermission(Manifest.permission.CAMERA)) { showSnackbar(\"已授权，可以打开\"); } else { if (shouldShowRequestPermissionRationale(Manifest.permission.CAMERA)) { Snackbar.make(constraintLayout, \"Camera permission is needed\", Snackbar.LENGTH_SHORT) .setAction(\"确定\", new View.OnClickListener() { @Override public void onClick(View v) { requestPermissions(new String[]{Manifest.permission.CAMERA}, REQUEST_CAMERA); } }).show(); } else { requestPermissions(new String[]{Manifest.permission.CAMERA}, REQUEST_CAMERA); } } } else { showSnackbar(\"可以直接打开\"); } } @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { switch (requestCode) { case REQUEST_CAMERA: if (grantResults.length &gt; 0) { if (grantResults[0] == PackageManager.PERMISSION_GRANTED) { showSnackbar(\"已授权\"); } else { showSnackbar(\"拒绝授权\"); } } break; } super.onRequestPermissionsResult(requestCode, permissions, grantResults); }} 另外，在看一些 权限申请 的三方库的时候，发现了一件很有意思的事情。通常代码很难追踪到 Activity 的生命周期，一些库就新建一个 Fragment 在其生命周期的各个回调方法里去调用相应的方法。很棒。 参考文章 Google官方实例 Android权限处理的那些事 RxPermissions AndPermission","link":"/2018/05/21/Android-动态权限申请/"},{"title":"Android 命名规范","text":"Android 命名规范标识符命名法标识符命名法最要有四种: 驼峰(Camel)命名法:又称小驼峰命名法，除首单词外，其余所有单词的第一个字母大写。 帕斯卡(pascal)命名法:又称大驼峰命名法，所有单词的第一个字母大写 下划线命名法:单词与单词间用下划线做间隔。 匈牙利命名法:广泛应用于微软编程环境中，在以Pascal命名法的变量前附加小写序列说明该变量的类型。 量的取名方式为：&lt;scope_&gt; + &lt;prefix_&gt; + &lt;qualifier&gt; 范围前缀，类型前缀，限定词。 尽可能的用最少的字符而又能完整的表达标识符的含义。 英文缩写原则： 较短的单词可通过去掉“元音”形成缩写 较长的单词可取单词的头几个字母形成缩写 此外还有一些约定成俗的英文单词缩写 下面为常见的英文单词缩写: 名称 缩写 icon ic color cl divider di selector sl background bg image img password pwd position pos TextView tv ImageView iv EditText et 注意： 单词缩写原则：不要用缩写，除非该缩写是约定俗成的。 命名规范包采用反域名命名规则，全部使用小写字母。一级包名为com，二级包名为xx（可以是公司或则个人的随便），三级包名根据应用进行命名，四级包名为模块名或层级名。 包名 此包中包含 包名.activities Activity类 包名.base 自定义基类 包名.adapter Adapter类 包名.tools 公共工具方法类 包名.bean 包中包含：实体类 包名.view (或 widget) 自定义的View类等 包名.service Service服务 … … 类采用大驼峰命名法，尽量避免缩写，除非该缩写是众所周知的，比如 HTML , URL，如果类名称中包含单词缩写，则单词缩写的每个字母均应大写。 类 描述 例如 activity Aty或者Activity为后缀标识 WelcomeAty.或者WelcomeActivity Adapter Adapte 为后缀标识 NewsAdp或NewsAdapter 基础类 以Base开头 BaseActivity,BaseFragment 公共方法类 Tools或Manager为后缀标识 ThreadPoolManager, LogTools Service 以Service为后缀标识 TimeService … … … 方法动词或动名词，采用小驼峰命名法例如: onCreate(), run() 变量采用小驼峰命名法。类中控件名称必须与xml布局id保持一致。 用统一的量词通过在结尾处放置一个量词，就可创建更加统一的变量，它们更容易理解，也更容易搜索。例如，请使用 strCustomerFirst 和 strCustomerLast ，而不要使用 strFirstCustomer 和 strLastCustomer。 常量全部大写,采用下划线命名法.例如：MIN_WIDTH 资源文件全部小写，采用下划线命名法，加前缀区分 名称 功能 btn_xx 按钮图片使用btn_整体效果（selector） btn_xx_normal 按钮图片使用btn_正常情况效果 btn_xx_press 按钮图片使用btn_点击时候效果 bg_head 背景图片使用bg_功能_说明 ic_more_help 图标图片使用icon_功能_说明 … … 资源ID大小写规范与方法名一致，采用小驼峰命名法。命名规范为“资源控件的缩写 名”+“变量名”。注意：页面控件名称应该和控件id名保持一致 layout中的id命名命名模式为：view缩写_模块名称_view的逻辑名称 控件 缩写 RelativeView rv TextView tv Button btn ImageView iv ProgressBar pb … … 注意： 如果layout文件很复杂，建议将layout分成多个模块，每个模块定义一个moduleViewHolder，其成员变量包含所属view styles.xml将layout中不断重现的style提炼出通用的style通用组件，放到styles.xml中","link":"/2018/09/26/Android-命名规范/"},{"title":"AS导入jni项目","text":"最近遇到了一个问题，老板让看关于android直播推流方面的资料，因为觉得像百度云，腾讯云等的封装的太厉害，所以打算自己做推流的部分。在网上看到了雷霄骅大神的博客，就把他做的demo的源码下下来了，但是他之前是用 eclipse 写得项目，所以在用AS导入的时候出现了一些问题。 解决打开 app 的 build.gradle 在 buildTypes 里添加如下 123456789101112131415sourceSets { main { jni.srcDirs = [] } } task ndkBuild(type: Exec, description: 'Compile JNI source via NDK') { commandLine \"D:/java/android-ndk-r13b/ndk-build.cmd\", 'NDK_PROJECT_PATH=build/intermediates/ndk', 'NDK_LIBS_OUT=src/main/jniLibs', 'APP_BUILD_SCRIPT=src/main/jni/Android.mk', 'NDK_APPLICATION_MK=src/main/jni/Application.mk' } tasks.withType(JavaCompile) { compileTask -&gt; compileTask.dependsOn ndkBuild } 其中 D:/java/android-ndk-r13b/ndk-build.cmd 是你电脑的ndk路径下的ndk-build.cmd路径","link":"/2017/04/30/AS导入jni项目/"},{"title":"Android与JS交互","text":"最近的项目里用到了混合开发，需要进行 Android 与 JS 的交互，就了解了一下相关知识。 Android 调用 JS 中的方法布局就不放出来了。 html 代码如下。两个按钮，分别创建两个 script 方法，一个有参，一个无参。1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt; &lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;jsandroid_test&lt;/title&gt; &lt;script type=\"text/javascript\" language=\"javascript\"&gt; function showFromHtml(){ document.getElementById(\"id_input\").value = \"Java call Html\"; } function showFromHtml2( param ){ document.getElementById(\"id_input2\").value = \"Java call Html : \" + param; } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input id=\"id_input\" style=\"width: 90%\" type=\"text\" value=\"null\" /&gt; &lt;br&gt; &lt;input type=\"button\" value=\"JavacallHtml\" onclick=\"window.jsObj.JavacallHtml()\" /&gt; &lt;br&gt; &lt;input id=\"id_input2\" style=\"width: 90%\" type=\"text\" value=\"null\" /&gt; &lt;br&gt; &lt;input type=\"button\" value=\"JavacallHtml2\" onclick=\"window.jsObj.JavacallHtml2()\" /&gt; &lt;/body&gt; &lt;/html&gt; android 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657private void showWebView(){ // webView与js交互代码 try { mWebView = new WebView(this); setContentView(mWebView); mWebView.requestFocus(); //触摸焦点起作用,如果不设置，则在点击网页文本输入框时，不能弹出软键盘及不响应其他的一些事件。 // 设置 WebChromeClient mWebView.setWebChromeClient(new WebChromeClient(){ @Override public void onProgressChanged(WebView view, int progress){ JSAndroidActivity.this.setTitle(\"Loading...\"); JSAndroidActivity.this.setProgress(progress); if(progress &gt;= 80) { JSAndroidActivity.this.setTitle(\"JsAndroid Test\"); } } }); WebSettings webSettings = mWebView.getSettings(); webSettings.setJavaScriptEnabled(true); //支持 JavaScript webSettings.setDefaultTextEncodingName(\"utf-8\"); mWebView.addJavascriptInterface(getHtmlObject(), \"jsObj\"); //设置 JS 接口,第一个参数是事件接口实例，第二个参数是 实例 在 JS 中的别名 mWebView.loadUrl(\"http://192.168.1.121:8080/jsandroid/index.html\"); } catch (Exception e) { e.printStackTrace(); } } private Object getHtmlObject(){ Object insertObj = new Object(){ public void JavacallHtml(){ runOnUiThread(new Runnable() { @Override public void run() { mWebView.loadUrl(\"javascript: showFromHtml()\"); Toast.makeText(JSAndroidActivity.this, \"clickBtn\", Toast.LENGTH_SHORT).show(); } }); } public void JavacallHtml2(){ runOnUiThread(new Runnable() { @Override public void run() { mWebView.loadUrl(\"javascript: showFromHtml2('IT-homer blog')\"); Toast.makeText(JSAndroidActivity.this, \"clickBtn2\", Toast.LENGTH_SHORT).show(); } }); } }; return insertObj; } 如上所示，在 JS 中新建两个方法。按钮的点击事件是 window.jsObj.JavacallHtml() 其中 window 代表当前界面，jsObj 是 java 里设置的 JS 接口的别名，JavacallHtml() 是 java 里的方法名字。 JS 调用 Android 中的方法12345678910111213141516171819202122232425262728&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt; &lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;jsandroid_test&lt;/title&gt; &lt;script type=\"text/javascript\" language=\"javascript\"&gt; function showHtmlcallJava(){ var str = window.jsObj.HtmlcallJava(); alert(str); } function showHtmlcallJava2(){ var str = window.jsObj.HtmlcallJava2(\"IT-homer blog\"); alert(str); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;br&gt; &lt;input type=\"button\" value=\"HtmlcallJava\" onclick=\"showHtmlcallJava()\" /&gt; &lt;br&gt; &lt;input type=\"button\" value=\"HtmlcallJava2\" onclick=\"showHtmlcallJava2()\" /&gt; &lt;br&gt; &lt;/body&gt; &lt;/html&gt; android 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445private void showWebView(){ // webView与js交互代码 try { mWebView = new WebView(this); setContentView(mWebView); mWebView.requestFocus(); //触摸焦点起作用,如果不设置，则在点击网页文本输入框时，不能弹出软键盘及不响应其他的一些事件。 // 设置 WebChromeClient mWebView.setWebChromeClient(new WebChromeClient(){ @Override public void onProgressChanged(WebView view, int progress){ JSAndroidActivity.this.setTitle(\"Loading...\"); JSAndroidActivity.this.setProgress(progress); if(progress &gt;= 80) { JSAndroidActivity.this.setTitle(\"JsAndroid Test\"); } } }); WebSettings webSettings = mWebView.getSettings(); webSettings.setJavaScriptEnabled(true); //支持 JavaScript webSettings.setDefaultTextEncodingName(\"utf-8\"); mWebView.addJavascriptInterface(getHtmlObject(), \"jsObj\"); //设置 JS 接口,第一个参数是事件接口实例，第二个参数是 实例 在 JS 中的别名 mWebView.loadUrl(\"http://192.168.1.121:8080/jsandroid/index.html\"); } catch (Exception e) { e.printStackTrace(); } } private Object getHtmlObject(){ Object insertObj = new Object(){ public String HtmlcallJava(){ return \"Html call Java\"; } public String HtmlcallJava2(final String param){ return \"Html call Java : \" + param; } }; return insertObj; } WebViewClient与WebChromeClient的区别WebViewClient主要帮助WebView处理各种通知、请求事件的，比如：onLoadResource, onPageStart,onPageFinish, onReceiveError, onReceivedHttpAuthRequest, shouldOverrideUrlLoading, 可以进行 url 的跳转链接等处理。 WebChromeClient主要辅助WebView处理JavaScript的对话框、网站图标、网站title、加载进度等比如 onCloseWindow， onCreateWindow，onJsAlert，onProgressChanged, onReceivedTitle 等。","link":"/2017/08/15/Android与JS交互/"},{"title":"Android图片三级缓存","text":"三级缓存来减少不必要的网络请求，节省流量。 内存缓存，优先加载，速度最快 本地缓存，次要加载，速度快 网络缓存，最后加载，速度慢 内存缓存实现12345678910111213141516171819202122232425262728293031323334353637public class MemoryCacheUtils { private LruCache&lt;String, Bitmap&gt; mMemoryCache; public MemoryCacheUtils() { long maxMemory = Runtime.getRuntime().maxMemory() / 8;//得到手机最大允许内存的1/8,即超过指定内存,则开始回收 //需要传入允许的内存最大值,虚拟机默认内存16M,真机不一定相同 mMemoryCache = new LruCache&lt;String, Bitmap&gt;((int) maxMemory) { //用于计算每个条目的大小 @Override protected int sizeOf(String key, Bitmap value) { return value.getByteCount(); } }; } /** * 从内存中读图片 * * @param url */ public Bitmap getBitmapFromMemory(String url) { Bitmap bitmap = mMemoryCache.get(url); return bitmap; } /** * 往内存中写图片 * * @param url * @param bitmap */ public void setBitmapToMemory(String url, Bitmap bitmap) { mMemoryCache.put(url, bitmap); }} 本地缓存实现12345678910111213141516171819202122232425262728293031323334353637383940414243public class LocalCacheUtils { private static final String CACHE_PATH = Environment.getExternalStorageDirectory().getAbsolutePath() + \"/WerbNews\"; /** * 从本地读取图片 * @param url */ public Bitmap getBitmapFromLocal(String url) { String fileName = null;//把图片的url当做文件名,并进行MD5加密 try { fileName = EncryptUtil.mapUrl(url); File file = new File(CACHE_PATH, fileName); Bitmap bitmap = BitmapFactory.decodeStream(new FileInputStream(file)); return bitmap; } catch (Exception e) { e.printStackTrace(); } return null; } /** * 从网络获取图片后,保存至本地缓存 * @param url * @param bitmap */ public void setBitmapToLocal(String url, Bitmap bitmap) { try { String fileName = EncryptUtil.mapUrl(url);//把图片的url当做文件名,并进行MD5加密 File file = new File(CACHE_PATH, fileName); //通过得到文件的父文件,判断父文件是否存在 File parentFile = file.getParentFile(); if (!parentFile.exists()) { parentFile.mkdirs(); } //把图片保存至本地 bitmap.compress(Bitmap.CompressFormat.JPEG, 100, new FileOutputStream(file)); } catch (Exception e) { e.printStackTrace(); } }} 网络缓存实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899public class NetCacheUtils { private LocalCacheUtils mLocalCacheUtils; private MemoryCacheUtils mMemoryCacheUtils; public NetCacheUtils(LocalCacheUtils localCacheUtils, MemoryCacheUtils memoryCacheUtils) { mLocalCacheUtils = localCacheUtils; mMemoryCacheUtils = memoryCacheUtils; } /** * 从网络下载图片 * @param ivPic 显示图片的imageview * @param url 下载图片的网络地址 */ public void getBitmapFromNet(ImageView ivPic, String url) { new BitmapTask().execute(ivPic, url);//启动AsyncTask } /** * AsyncTask就是对handler和线程池的封装 * 第一个泛型:参数类型 * 第二个泛型:更新进度的泛型 * 第三个泛型:onPostExecute的返回结果 */ class BitmapTask extends AsyncTask&lt;Object, Void, Bitmap&gt; { private ImageView ivPic; private String url; /** * 后台耗时操作,存在于子线程中 * @param params * @return */ @Override protected Bitmap doInBackground(Object[] params) { ivPic = (ImageView) params[0]; url = (String) params[1]; return downLoadBitmap(url); } /** * 更新进度,在主线程中 * @param values */ @Override protected void onProgressUpdate(Void[] values) { super.onProgressUpdate(values); } /** * 耗时方法结束后执行该方法,主线程中 * @param result */ @Override protected void onPostExecute(Bitmap result) { if (result != null) { ivPic.setImageBitmap(result); System.out.println(\"从网络缓存图片啦.....\"); //从网络获取图片后,保存至本地缓存 mLocalCacheUtils.setBitmapToLocal(url, result); //保存至内存中 mMemoryCacheUtils.setBitmapToMemory(url, result); } } } /** * 网络下载图片 * @param url * @return */ private Bitmap downLoadBitmap(String url) { HttpURLConnection conn = null; try { conn = (HttpURLConnection) new URL(url).openConnection(); conn.setConnectTimeout(5000); conn.setReadTimeout(5000); conn.setRequestMethod(\"GET\"); int responseCode = conn.getResponseCode(); if (responseCode == 200) { //图片压缩 BitmapFactory.Options options = new BitmapFactory.Options(); options.inSampleSize=2;//宽高压缩为原来的1/2 options.inPreferredConfig=Bitmap.Config.ARGB_4444; Bitmap bitmap = BitmapFactory.decodeStream(conn.getInputStream(),null,options); return bitmap; } } catch (IOException e) { e.printStackTrace(); } finally { conn.disconnect(); } return null; }} MD5加密12345678910111213141516171819public class EncryptUtil { public EncryptUtil() { } public static String mapUrl(String url) { StringBuilder builder = new StringBuilder(); try { MessageDigest md5 = MessageDigest.getInstance(\"MD5\"); byte[] bytes = md5.digest(url.getBytes()); for (byte b : bytes) { builder.append(String.format(\"%02x\", b)); } } catch (NoSuchAlgorithmException e) { e.printStackTrace(); } return builder.toString(); }} 图片加载工具类123456789101112131415161718192021222324252627282930313233343536public class MyBitmapUtils { private NetCacheUtils mNetCacheUtils; private LocalCacheUtils mLocalCacheUtils; private MemoryCacheUtils mMemoryCacheUtils; public MyBitmapUtils() { mMemoryCacheUtils = new MemoryCacheUtils(); mLocalCacheUtils = new LocalCacheUtils(); mNetCacheUtils = new NetCacheUtils(mLocalCacheUtils, mMemoryCacheUtils); } public void disPlay(ImageView ivPic, String url) { ivPic.setImageResource(R.mipmap.ic_launcher); Bitmap bitmap; //内存缓存 bitmap = mMemoryCacheUtils.getBitmapFromMemory(url); if (bitmap != null) { ivPic.setImageBitmap(bitmap); System.out.println(\"从内存获取图片啦.....\"); return; } //本地缓存 bitmap = mLocalCacheUtils.getBitmapFromLocal(url); if (bitmap != null) { ivPic.setImageBitmap(bitmap); System.out.println(\"从本地获取图片啦.....\"); //从本地获取图片后,保存至内存中 mMemoryCacheUtils.setBitmapToMemory(url, bitmap); return; } //网络缓存 mNetCacheUtils.getBitmapFromNet(ivPic, url); }}","link":"/2017/07/04/Android图片三级缓存/"},{"title":"Android面试题集","text":"在这里记录一下面试中遇到的问题，慢慢更新。 数据结构 堆和栈的区别 堆：先进先出。Java中，创建的对象存放在堆内存里。 栈：先进后出。Java中，基本数据类型以及其他类的引用放在栈内存里，速度快。 Java基础 Java基本数据类型 (8种) 数据类型 int short long float double byte char boolean 字节 4 2 8 4 8 1 2 1 String 和 StringBuilder 以及 StringBuffer 区别 Android基础 Handler机制 事件分发 线程间通信方式 项目经验 Glide源码 Android性能优化 面试经验 面试前看下公司的一些要求以及公司给的薪资。 最好是有一些自己深入了解过的东西，比如 Glide 源码之类的。然后主动跟面试官聊自己擅长的东西。 不会的就直说不会。","link":"/2017/07/28/Android面试题集/"},{"title":"CrashHandler","text":"源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103public class CrashHandler implements Thread.UncaughtExceptionHandler { private static final String TAG = \"CrashHandler\"; private static final boolean DEBUG = true; private static final String PATH = Environment.getExternalStorageDirectory().getPath() + \"/CrashTest/log/\"; private static final String FILE_NAME = \"crash\"; private static final String FILE_NAME_SUFFIX = \".trace\"; private static CrashHandler sInstance = new CrashHandler(); private Thread.UncaughtExceptionHandler mDefaultCrashHandler; private Context mContext; private CrashHandler() { } public static CrashHandler getInstance() { return sInstance; } public void init(Context context) { mContext = context.getApplicationContext(); mDefaultCrashHandler = Thread.getDefaultUncaughtExceptionHandler(); Thread.setDefaultUncaughtExceptionHandler(this); } @Override public void uncaughtException(Thread t, Throwable e) { try { dumpExceptionToSDCard(e); uploadExceptionToServer(); } catch (IOException e1) { e1.printStackTrace(); } if (mDefaultCrashHandler != null) { mDefaultCrashHandler.uncaughtException(t, e); } else { Process.killProcess(Process.myPid()); } } private void dumpExceptionToSDCard(Throwable t) throws IOException { if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) { if (DEBUG) { Log.w(TAG, \"sdcard unmounted, skip dump exception\"); return; } } File dir = new File(PATH); if (!dir.exists()) { dir.mkdirs(); } long current = System.currentTimeMillis(); String time = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(new Date(current)); File file = new File(PATH + FILE_NAME + time + FILE_NAME_SUFFIX); try { PrintWriter printWriter = new PrintWriter(new BufferedWriter(new FileWriter(file))); printWriter.println(time); dumpPhoneInfo(printWriter); printWriter.println(); t.printStackTrace(printWriter); printWriter.close(); } catch (PackageManager.NameNotFoundException e) { Log.e(TAG, \"dump crash info failed \"); e.printStackTrace(); } } private void dumpPhoneInfo(PrintWriter pw) throws PackageManager.NameNotFoundException { PackageManager manager = mContext.getPackageManager(); PackageInfo pi = manager.getPackageInfo(mContext.getPackageName(), PackageManager.GET_ACTIVITIES); pw.print(\"App Version: \"); pw.print(pi.versionName); pw.print(\"_\"); pw.println(pi.versionCode); //Android版本号 pw.print(\"OS Version: \"); pw.print(Build.VERSION.RELEASE); pw.print(\"_\"); pw.println(Build.VERSION.SDK_INT); //手机制造商 pw.print(\"Vendor: \"); pw.println(Build.MANUFACTURER); //手机型号 pw.print(\"Model: \"); pw.println(Build.MODEL); //CPU架构 pw.print(\"CPU ABI: \"); pw.println(Build.CPU_ABI); } private void uploadExceptionToServer() { //TODO: Upload Exception Message To Web Server }} 使用1234567891011121314151617public class BaseApplication extends Application { private static BaseApplication sInstance; @Override public void onCreate() { super.onCreate(); sInstance = this; CrashHandler crashHandler = CrashHandler.getInstance(); crashHandler.init(this); } public static BaseApplication getInstance() { return sInstance; }}","link":"/2018/02/26/CrashHandler/"},{"title":"Django入门","text":"1.Django安装方法1：用pip安装 pip install django 方法2：下载安装包，在这里下载 django 安装包，然后python setup.py install 2.配置环境变量在 path 中添加 C:\\Python33\\Lib\\site-packages\\django\\bin 3.新建Django项目在安装 Python，Django 以及添加环境变量后，就可以通过使用 django-admin startproject HelloWorld 命令来创建第一个 django 项目 HelloWorld 。 创建完成后，可以看到如下的目录结构123456789$ cd HelloWorld/$ tree.|-- HelloWorld| |-- __init__.py| |-- settings.py| |-- urls.py| `-- wsgi.py`-- manage.py 目录说明： HelloWorld 项目的容器。 manage.py 一个实用的命令行工具，可让你以各种方式与该 Django 项目进行交互。 HelloWorld/__init__.py: 一个空文件，告诉 Python 该目录是一个 Python 包。 HelloWorld/settings.py: 该 Django 项目的设置/配置。 HelloWorld/urls.py: 该 Django 项目的 URL 声明; 一份由 Django 驱动的网站”目录”。 HelloWorld/wsgi.py: 一个 WSGI 兼容的 Web 服务器的入口，以便运行你的项目。 然后进入第一层 HelloWorld 目录，使用命令 python manage.py runserver 0.0.0.0:8089 来启动服务器，8089 是端口号，不说明的话默认是 8000 在浏览器输入你服务器的ip及端口号，如果正常启动，输出结果如下： 4.配置在创建的 HelloWorld 下的 HelloWorld 目录新建一个 view.py 文件,并写入代码1234from django.http import HttpResponsedef hello(request): return HttpResponse(\"Hello World !\") 接着，绑定 URL 与视图函数。打开 urls.py 文件，删除原来代码，将以下代码复制粘贴到 urls.py 文件中：123456from django.conf.urls import urlfrom . import viewurlpatterns=[ url(r'^$', view.hello)] 这时再用浏览器访问 127.0.0.1:8089 会出现下图 也可以在urls.py里修改规则123456from django.conf.urls import urlfrom . import viewurlpatterns=[ url(r'^hello', view.hello)] 浏览器访问 127.0.0.1:8089/hello 会出现下图 Django 的 url() 函数可以接受四个参数，分别是两个必选参数：regex、view 和两个可选参数：kwargs、name，接下来详细介绍这四个参数。 regex：正则表达式，与之匹配的url将会执行对应的第二个参数 view。 view：用于执行与正则表达式匹配的 URL 请求。 kwargs：视图使用的字典类型的参数。 name: 用来反向获取 URL。 注意：如果用其他设备访问被拒绝的话，应该是没有开启允许访问，这时应该修改项目下的settings.py，把其中的ALLOWED_HOSTS=[] 改成 ALLOWED_HOSTS=['*']， 其中 * 表示任意地址。","link":"/2017/06/04/Django入门/"},{"title":"First","text":"幸得识卿桃花面，自此阡陌多暖春。 希望这是一个好的开始， 更希望会有一个好的结果。","link":"/2016/05/16/First/"},{"title":"Django模型","text":"Django 对各种数据库提供了很好的支持，包括：PostgreSQL、MySQL、SQLite、Oracle。Django 为这些数据库提供了统一的调用API。 我们可以根据自己业务需求选择不同的数据库。 可以使用 pip install mysqlclient 来安装 mysql 驱动 数据库配置在项目的 settings.py 文件中找到 DATABASES 配置项，将其信息修改为：12345678910DATABASES = { 'default': { 'ENGINE': 'django.db.backends.mysql', 'NAME': 'test', 'USER': 'root', 'PASSWORD': '0107', 'HOST': 'localhost', 'PORT':'3306', }} 定义模型Django规定，如果要使用模型，必须要创建一个app。我们使用以下命令创建一个 TestModel 的 app:1python manage.py startapp TestModel 目录结构如下：1234567HelloWorld|-- TestModel| |-- __init__.py| |-- admin.py| |-- models.py| |-- tests.py| `-- views.py 修改 TestModel/models.py 文件，代码如下：1234from django.db import modelsclass Test(models.Model): name = models.CharField(max_length=20) 以上的类名代表了数据库表名，且继承了 models.Model ，类里面的字段代表数据表中的字段(name)，数据类型则由 CharField（相当于varchar）、DateField（相当于datetime）， max_length 参数限定长度。接下来在 settings.py 中找到 INSTALLED_APPS 这一项，如下：123456789INSTALLED_APPS = ( 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'TestModel', # 添加此项) 在命令行中运行12345python manage.py migrate # 创建表结构python manage.py makemigrations TestModel # 让 Django 知道我们在我们的模型有一些变更python manage.py migrate TestModel # 创建表结构 然后在 HelloWorld 目录下添加 testdb.py，代码如下：1234567from django.http import HttpResponsefrom TestModel.models import Testdef testdb(request): test1 = Test(name='runoob') test1.save() return HttpResponse(\"&lt;p&gt;数据添加成功！&lt;/p&gt;\") 并且修改 urls.py1234567from django.conf.urls import *from . import view,testdburlpatterns=[ url(r'^hello', view.hello), url(r'^testdb', testdb.testdb),] 访问 http://127.0.0.1:8000/testdb 就可以看到数据添加成功的提示。 获取数据12345678910111213141516171819202122232425262728293031323334from django.http import HttpResponse from TestModel.models import Test # 数据库操作def testdb(request): # 初始化 response = \"\" response1 = \"\" # 通过objects这个模型管理器的all()获得所有数据行，相当于SQL中的SELECT * FROM list = Test.objects.all() # filter相当于SQL中的WHERE，可设置条件过滤结果 response2 = Test.objects.filter(id=1) # 获取单个对象 response3 = Test.objects.get(id=1) # 限制返回的数据 相当于 SQL 中的 OFFSET 0 LIMIT 2; Test.objects.order_by('name')[0:2] #数据排序 Test.objects.order_by(\"id\") # 上面的方法可以连锁使用 Test.objects.filter(name=\"runoob\").order_by(\"id\") # 输出所有数据 for var in list: response1 += var.name + \" \" response = response1 return HttpResponse(\"&lt;p&gt;\" + response + \"&lt;/p&gt;\") 更新数据修改数据可以用 save() 或者 update():123456789101112131415161718from django.http import HttpResponse from TestModel.models import Test # 数据库操作def testdb(request): # 修改其中一个id=1的name字段，再save，相当于SQL中的UPDATE test1 = Test.objects.get(id=1) test1.name = 'Google' test1.save() # 另外一种方式 #Test.objects.filter(id=1).update(name='Google') # 修改所有的列 # Test.objects.all().update(name='Google') return HttpResponse(\"&lt;p&gt;修改成功&lt;/p&gt;\") 删除数据删除数据库中的对象只需调用该对象的delete()方法即可：1234567891011121314151617from django.http import HttpResponse from TestModel.models import Test # 数据库操作def testdb(request): # 删除id=1的数据 test1 = Test.objects.get(id=1) test1.delete() # 另外一种方式 # Test.objects.filter(id=1).delete() # 删除所有数据 # Test.objects.all().delete() return HttpResponse(\"&lt;p&gt;删除成功&lt;/p&gt;\")","link":"/2017/06/04/Django模型/"},{"title":"Django模板","text":"模板应用实例在上文创建的 HelloWorld 目录下新建 templates 目录并建立 hello.html 文件，整个项目目录结构如下123456789101112131415HelloWorld/|-- HelloWorld| |-- __init__.py| |-- __init__.pyc| |-- settings.py| |-- settings.pyc| |-- urls.py| |-- urls.pyc| |-- view.py| |-- view.pyc| |-- wsgi.py| `-- wsgi.pyc|-- manage.py`-- templates `-- hello.html hello.html 中代码如下：1&lt;h1&gt;{{ hello }}&lt;/h1&gt; 从模板中我们知道变量使用了双括号。接下来我们需要向 Django 说明模板文件的路径，修改HelloWorld/settings.py，修改 TEMPLATES 中的 DIRS 为 [BASE_DIR+”/templates”,]，如下所示:123456789101112131415TEMPLATES = [ { 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [BASE_DIR+\"/templates\",], 'APP_DIRS': True, 'OPTIONS': { 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], }, },] 现在修改 view.py 增加一个新的对象1234567from django.http import HttpResponsefrom django.shortcuts import renderdef hello(request): context = {} context['hello'] = 'Hello World!' return render(request,'hello.html',context) 这里使用 render 来替代之前使用的 HttpResponse。render 还使用了一个字典 context 作为参数。context 字典中元素的键值 “hello” 对应了模板中的变量 ““。再访问访问 http://127.0.0.1:8000/hello，可以看到页面： 这样我们就完成了使用模板来输出数据，从而实现数据与视图分离。 模板标签if/else 标签123{% if condition %} ...display{% endif %} 或者是1234567{% if condition1 %} ...display 1{% elif condition2 %} ...display 2{% else %} ...display 3{% endif %} 根据条件判断是否输出。if/else 支持嵌套。{\\% if \\%} 标签接受 and ， or 或者 not 关键字来对多个变量做判断 ，或者对变量取反( not )，例如：123{% if athlete_list and coach_list %} athletes 和 coaches 变量都是可用的。{% endif %} for标签{\\% for \\%} 允许我们在一个序列上迭代。与Python的 for 语句的情形类似，循环语法是 for X in Y ，Y是要迭代的序列而X是在每一个特定的循环中使用的变量名称。每一次循环中，模板系统会渲染在 {\\% for \\%} 和 {\\% endfor \\%} 之间的所有内容。例如，给定一个运动员列表 athlete_list 变量，我们可以使用下面的代码来显示这个列表：123{% for athlete in athlete_list %}{{ athlete.name }}{% endfor %} 给标签增加一个 reversed 使得该列表被反向迭代：123{% for athlete in athlete_list reversed %}...{% endfor %} 可以嵌套使用 {\\% for \\%} 标签：12345678{% for athlete in athlete_list %} &lt;h1&gt;{{ athlete.name }}&lt;/h1&gt; &lt;ul&gt; {% for sport in athlete.sports_played %} &lt;li&gt;{{ sport }}&lt;/li&gt; {% endfor %} &lt;/ul&gt;{% endfor %} ifequal/ifnotequal 标签{\\% ifequal \\%} 标签比较两个值，当他们相等时，显示在 {\\% ifequal \\%} 和 {\\% endifequal \\%} 之中所有的值。下面的例子比较两个模板变量 user 和 currentuser :123{% ifequal user currentuser %} &lt;h1&gt;Welcome!&lt;/h1&gt;{% endifequal %} 和 {\\% if \\%} 类似， {\\% ifequal \\%} 支持可选的 {\\% else \\%} 标签：12345{% ifequal section 'sitenews' %} &lt;h1&gt;Site News&lt;/h1&gt;{% else %} &lt;h1&gt;No News Here&lt;/h1&gt;{% endifequal %} 注释标签Django 注释使用 过滤器模板过滤器可以在变量被显示前修改它，过滤器使用管道字符，如下所示：1{{ name|lower }} 变量被过滤器 lower 处理后，文档大写转换文本为小写。过滤管道可以被* 套接* ，既是说，一个过滤器管道的输出又可以作为下一个管道的输入：1{{ my_list|first|upper }} 以上实例将第一个元素并将其转化为大写。有些过滤器有参数。 过滤器的参数跟随冒号之后并且总是以双引号包含。 例如：1{{ bio|truncatewords:\"30\" }} 这个将显示变量 bio 的前30个词。其他过滤器： addslashes : 添加反斜杠到任何反斜杠、单引号或者双引号前面。 date : 按指定的格式字符串参数格式化 date 或者 datetime 对象，实例： 123456789{{ pub_date | date: \"F j, Y\" }}``` * length 返回变量的长度。# include标签\\{\\% include \\%\\} 标签允许在模板中包含其它的模板的内容。下面这个例子都包含了 nav.html 模板：```python{% include \"nav.html\" %} 模板继承模板可以用继承的方式来实现复用。接下来我们先创建之前项目的 templates 目录中添加 base.html 文件，代码如下：1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Hello World!&lt;/h1&gt; &lt;p&gt; Django 测试。&lt;/p&gt; {% block mainbody %} &lt;p&gt;original&lt;/p&gt; {% endblock %}&lt;/body&gt;&lt;/html&gt; 以上代码中，名为 mainbody 的 block 标签是可以被继承者们替换掉的部分。所有的 {\\% block \\%} 标签告诉模板引擎，子模板可以重载这些部分。hello.html 中继承 base.html，并替换特定 block，hello.html 修改后的代码如下：12345{% extends \"base.html\" %} {% block mainbody %}&lt;p&gt;继承了 base.html 文件&lt;/p&gt;{% endblock %} 第一行代码说明 hello.html 继承了 base.html 文件。可以看到，这里相同名字的 block 标签用以替换 base.html 的相应 block。重新访问地址 http://127.0.0.1:8000/hello，输出结果如下：","link":"/2017/06/04/Django模板/"},{"title":"Hala 2018","text":"刚看了眼积分榜，习惯性的去榜首找渣团的战绩，突然回过神来，直接拉到最下面然后再一点点的往上翻，哦，原来还在前5。这可能是唯一能让我觉得欣慰的了，明年有可能还能打欧冠。 终场哨响后，深深地无力感把我压在床上不能动。从来没像现在这么绝望，哪怕是被巴萨踢了4:0的时候，哪怕前年贝秃带队的时候，因为那时候总还有赢得冠军的希望。联赛没了还有欧冠，国王杯没了还有欧冠。其实想起来，皇马现在的状况在去年就开始显现了，不过当时替补阵容比较厚加上运气的成分吧。说起来也是事后诸葛亮吧。没想到今年bbc状态这么差，替补席又不给力，还可能是四年三冠预支了未来几年的好运气导致现在这糟糕的战绩。 之前从来觉得不应该批评队员，但是看到这次国家德比第一个丢球时，还是有怪科娃的想法，后来一想，没办法，谁站在那个地方谁背锅。 感觉自己是幸运的。第一年看皇马就赢到了第十冠还有个国王杯。十二年后重新夺冠，十六郎的时代我没经历，不知道当时是怎样过来的。记得当时贴吧的背景图是“十冠皇马，欧洲之王”，随后就四大皆空。然后再欧冠卫冕，真正站在了欧洲顶峰。 刚开始看球是pptv，后来是乐视，现在连西甲都收费了。 朋友圈看到了哈工大的定位，想起了五年前我那写满哈工大的桌布和当了两年头像的哈工大校徽。 强哥是真的文艺。我服，我是伪文艺，他是真文青。“人不似少年游”，我能想到的只有“莫欺少年穷”，“少年不识愁滋味”还有坑王的“龙与少年游”。 17年的总结和18的规划一直不想写，因为觉得写了后 这年就是真的过去了。我可是最害怕时间的。 python（爬虫，数据处理，web），Android高级。 拥抱开源，享受技术。 独立思考，用心生活。 待从头收拾旧山河朝天阙。","link":"/2018/01/15/Hala-2018/"},{"title":"Linux安装jdk","text":"1.下载合适的安装包(.tar.gz) 2.sudo mkdir /usr/local/java 在usr/local下创建java文件夹 3.sudo cp ~/home/Downloads/jdk-8u31-linux-x64.tar.gz /usr/local/java 复制一份java安装包到java路径下 4.sudo tar -zxvf jdk-8u31-linux-x64.tar.gz 解压安装包 5.编辑 home 下的 .bashrc 文件(修改环境变量) 在末尾添加1234export JAVA_HOME=/usr/local/java/jdk1.8.0_31/export JRE_HOME=${JAVA_HOME}/jre export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib export PATH=${JAVA_HOME}/bin:$PATH 6.source .bashrc 使更改立即生效","link":"/2017/04/30/Linux安装jdk/"},{"title":"LruCache 解析","text":"LRU 全称为 Least Recently Used 即最近最少使用，是一种缓存置换算法。淘汰最长时间未使用的对象。下面是 LruCache 的结构。123456789101112131415161718private final LinkedHashMap&lt;K, V&gt; map;private int size; //当前缓存内容的大小。它不一定是元素的个数，比如如果缓存的是图片，一般用的是图片占用的内存大小private int maxSize; // 最大可缓存的大小private int putCount; // put 方法被调用的次数private int createCount; // create(Object) 被调用的次数private int evictionCount; // 被置换出来的元素的个数private int hitCount; // get 方法命中缓存中的元素的次数private int missCount; // get 方法未命中缓存中元素的次数public LruCache(int maxSize) { if (maxSize &lt;= 0) { throw new IllegalArgumentException(\"maxSize &lt;= 0\"); } this.maxSize = maxSize; this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true);} LinkedHashMap可以看出，LruCache 是使用 LinkedHashMap 来存储内容的。LinkedHashMap 继承自 HashMap ，不同的是，它是一个双向循环链表，它的每一个数据结点都有两个指针，分别指向直接前驱和直接后继。LinkedHashMap 的 put（key ，value） 方法，我觉得是当 map 中已经插入过 key 的话，把newValue插入到map中，返回之前存储的 oldValue ，否则返回null。 新建一个节点时的插入过程123456789101112131415@Override void addNewEntry(K key, V value, int hash, int index) { LinkedEntry&lt;K, V&gt; header = this.header; // Remove eldest entry if instructed to do so. LinkedEntry&lt;K, V&gt; eldest = header.nxt; if (eldest != header &amp;&amp; removeEldestEntry(eldest)) { remove(eldest.key); } // Create new entry, link it on to list, and put it into table LinkedEntry&lt;K, V&gt; oldTail = header.prv; LinkedEntry&lt;K, V&gt; newTail = new LinkedEntry&lt;K,V&gt;( key, value, hash, table[index], header, oldTail); table[index] = oldTail.nxt = header.prv = newTail; } 可以看到，当加入一个新结点时，结构如下： 当accessOrder为true时，更新或者访问一个结点时，它会把这个结点移到尾部，对应代码如下：12345678910111213private void makeTail(LinkedEntry&lt;K, V&gt; e) { // Unlink e e.prv.nxt = e.nxt; e.nxt.prv = e.prv; // Relink e as tail LinkedEntry&lt;K, V&gt; header = this.header; LinkedEntry&lt;K, V&gt; oldTail = header.prv; e.nxt = header; e.prv = oldTail; oldTail.nxt = header.prv = e; modCount++;} 以上代码分为两步，第一步是先把该节点取出来（Unlink e），如下图： 第二步是把这个这个结点移到尾部（Relink e as tail），也就是把旧的尾部的nxt以及头部的prv指向它，并让它的nxt指向头部，把它的prv指向旧的尾部。如下图： LruCachesafeSizeOf(K key, V value) 是返回 value 对应的 size 大小 通过重写 sizeOf( ) 方法来确定每个 size 的大小 来读一下它的get方法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public final V get(K key) { if (key == null) { throw new NullPointerException(\"key == null\"); } V mapValue; synchronized (this) { //获取到值时，就返回该值 mapValue = map.get(key); if (mapValue != null) { hitCount++; return mapValue; } missCount++; } /* * Attempt to create a value. This may take a long time, and the map * may be different when create() returns. If a conflicting value was * added to the map while create() was working, we leave that value in * the map and release the created value. */ //尝试创建一个值，这个方法的默认实现是直接返回null。但是在它的设计中，这个方法可能执行完成之后map已经有了变化。 V createdValue = create(key); if (createdValue == null) { return null; // 如果不为没有命名的key创建新值，则直接返回 null } synchronized (this) { createCount++; //将创建的值放入map中，如果map在前面的过程中正好放入了这对key-value，那么会返回放入的value mapValue = map.put(key, createdValue); if (mapValue != null) { //如果不为空，说明不需要我们所创建的值，所以又把返回的值放进去 // There was a conflict so undo that last put map.put(key, mapValue); } else { //为空，说明我们更新了这个key的值，需要重新计算大小 size += safeSizeOf(key, createdValue); } } //上面放入的值有冲突 if (mapValue != null) { entryRemoved(false, key, createdValue, mapValue);// 通知之前创建的值已经被移除，而改为mapValue return mapValue; } else { trimToSize(maxSize);//没有冲突时，因为放入了新创建的值，大小已经有变化，所以需要修整大小 return createdValue; }} LruCache 是可能被多个线程同时访问的，所以在读写 map 时进行加锁。当获取不到对应的 key 的值时，它会调用其 create(K key) 方法，这个方法用于当缓存没有命名时计算一个 key 所对应的值，它的默认实现是直接返回 null。这个方法并没有加上同步锁，也就是在它进行创建时，map 可能已经有了变化。所以在 get 方法中，如果 create(key) 返回的 V 不为 null，会再把它给放到 map 中，并检查是否在它创建的期间已经有其他对象也进行创建并放到 map 中了，如果有，则会放弃这个创建的对象，而把之前的对象留下，否则因为我们放入了新创建的值，所以要计算现在的大小并进行 trimToSize。trimToSize 方法是根据传进来的 maxSize，如果当前大小超过了这个 maxSize，则会移除最老的结点，直到不超过。代码如下：12345678910111213141516171819202122232425public void trimToSize(int maxSize) { while (true) { K key; V value; synchronized (this) { if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) { throw new IllegalStateException(getClass().getName() + \".sizeOf() is reporting inconsistent results!\"); } if (size &lt;= maxSize || map.isEmpty()) { break; } Map.Entry&lt;K, V&gt; toEvict = map.entrySet().iterator().next(); key = toEvict.getKey(); value = toEvict.getValue(); map.remove(key); size -= safeSizeOf(key, value); evictionCount++; } entryRemoved(true, key, value, null); }} 再来看put方法，它的代码也很简单：12345678910111213141516171819202122public final V put(K key, V value) { if (key == null || value == null) { throw new NullPointerException(\"key == null || value == null\"); } V previous; synchronized (this) { putCount++; size += safeSizeOf(key, value); previous = map.put(key, value); if (previous != null) { size -= safeSizeOf(key, previous); } } if (previous != null) { entryRemoved(false, key, previous, value); } trimToSize(maxSize); return previous;} 主要逻辑是，计算新增加的大小，加入 size ，然后把 key-value 放入 map 中，如果是更新旧的数据（map.put(key, value) 会返回之前的 value），则减去旧数据的大小，并调用 entryRemoved(false, key, previous, value) 方法通知旧数据被更新为新的值，最后也是调用 trimToSize(maxSize) 修整缓存的大小。 本文参考: Android源码解析——LruCache","link":"/2017/07/13/LruCache-解析/"},{"title":"Recyclerview加载更多","text":"布局文件123456789101112&lt;android.support.v4.widget.SwipeRefreshLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:id=\"@+id/view_refresh\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/recycler_view\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"/&gt;&lt;/android.support.v4.widget.SwipeRefreshLayout&gt; 普通 item_with_image.xml123456789101112131415161718192021&lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_margin=\"10dp\"&gt; &lt;ImageView android:id=\"@+id/img_avatar\" android:layout_width=\"40dp\" android:layout_height=\"40dp\" tools:src=\"@mipmap/ic_launcher\"/&gt; &lt;TextView android:id=\"@+id/tv_name\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:maxLines=\"1\" android:textColor=\"@color/text_black\" android:textSize=\"15sp\" tools:text=\"seyo+\"/&gt;&lt;/LinearLayout&gt; 底部 item_foot.xml123456789101112131415161718192021&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"40dp\" android:gravity=\"center\" android:orientation=\"horizontal\"&gt; &lt;ProgressBar android:id=\"@+id/progressBar\" style=\"?android:attr/progressBarStyleSmall\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center\" android:layout_marginRight=\"6dp\"/&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center\" android:text=\"@string/loading\"/&gt;&lt;/LinearLayout&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class TestAdapter extends RecyclerView.Adapter { private Context mContext; private List&lt;DynamicModel&gt; mVideoList; private int TYPE_IMAGE = 0; private int TYPE_FOOTER = 2; public TestAdapter(Context context, List&lt;DynamicModel&gt; videoList) { mContext = context; mVideoList = videoList; } @Override public int getItemViewType(int position) { if (position + 1 == getItemCount()) { return TYPE_FOOTER; } return TYPE_IMAGE; } @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { RecyclerView.ViewHolder holder = null; if (viewType == TYPE_IMAGE) { View itemView = LayoutInflater.from(mContext).inflate(R.layout.item_with_image, parent, false); holder = new ImageHolder(itemView); } else if (viewType == TYPE_FOOTER) { View view = LayoutInflater.from(mContext).inflate(R.layout.item_foot, parent, false); return new FootViewHolder(view); } return holder; } @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) { if (holder instanceof ImageHolder) { ((ImageHolder) holder).bindView(mVideoList.get(position)); } } @Override public int getItemCount() { return mVideoList.size() == 0 ? 0 : mVideoList.size() + 1; } private class ImageHolder extends RecyclerView.ViewHolder { private final ImageView imgAvatar; private final TextView tvName; public ImageHolder(View itemView) { super(itemView); imgAvatar = ((ImageView) itemView.findViewById(R.id.img_avatar)); tvName = ((TextView) itemView.findViewById(R.id.tv_name)); } private void bindView(DynamicModel item) { if (item.getUsers().size() &gt; 0) { Glide.with(mContext).load(AppConfig.GetImageUrl(item.getUsers().get(0).getAvatarImage())).transform(new GlideCircleTransform(mContext)).into(imgAvatar); tvName.setText(item.getUsers().get(0).getUserName()); } else { Glide.with(mContext).load(R.drawable.default_seyo).transform(new GlideCircleTransform(mContext)).into(imgAvatar); tvName.setText(\"seyo+\"); } } } private class FootViewHolder extends RecyclerView.ViewHolder { public FootViewHolder(View itemView) { super(itemView); } }} Fragment123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public void initView( LinearLayoutManager layoutManager = new LinearLayoutManager(getActivity()); mRecyclerView.setLayoutManager(layoutManager); adapter = new VideoAdapter(getActivity(), mList); mRecyclerView.setAdapter(adapter); mRefreshLayout = ((SwipeRefreshLayout) view.findViewById(R.id.view_refresh)); mRefreshLayout.setOnRefreshListener(this); mRecyclerView.addOnScrollListener(new RecyclerView.OnScrollListener() { @Override public void onScrollStateChanged(RecyclerView recyclerView, int newState){ super.onScrollStateChanged(recyclerView, newState); if (newState == RecyclerView.SCROLL_STATE_IDLE &amp;&amp; lastVisibleItemPosition + 1 == adapter.getItemCount()) { boolean isRefreshing = mRefreshLayout.isRefreshing(); if (isRefreshing) { adapter.notifyItemRemoved(adapter.getItemCount()); return; } if (!isLoading) { isLoading = true; loadData(); } } } @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) { super.onScrolled(recyclerView, dx, dy); lastVisibleItemPosition = layoutManager.findLastCompletelyVisibleItemPosition(); } });)@Overridepublic void onRefresh() { mList.clear(); loadData();}private void loadData() { NetService service = new NetService(); service.getDynamicList(0, AppConfig.TYPE_RECOMMEND, AppConfig.PAGESIZE,curIndex, new Observer&lt;DetailList&lt;DynamicModel&gt;&gt;() { @Override public void onSubscribe(@NonNull Disposable d) { MethodUtils.LoadingDialog(getContext(), \"正在加载\"); } @Override public void onNext(@NonNull DetailList&lt;DynamicModel&gt; list) { mList.addAll(list.getData()); adapter.notifyDataSetChanged(); } @Override public void onError(@NonNull Throwable e) { MethodUtils.loadingDialogDismiss(); ToastUtils.showMessage(getContext(), \"网络异常，请求失败\"); mRefreshLayout.setRefreshing(false); isLoading = false; if (adapter.getItemCount() &gt; 0) { adapter.notifyItemRemoved(adapter.getItemCount()); } } @Override public void onComplete() { mRefreshLayout.setRefreshing(false); isLoading = false; MethodUtils.loadingDialogDismiss(); if (adapter.getItemCount() &gt; 0) { adapter.notifyItemRemoved(adapter.getItemCount()); } } });} 挺简单的，主要就是多布局，当滑动到最后一个 item 时，让他绑定 item_foot.xml 布局。然后在加载导数据之后 adapter.notifyItemRemoved(adapter.getItemCount()); 去掉最后 foot。","link":"/2017/09/21/Recyclerview加载更多/"},{"title":"R.I.P","text":"7.13 他走了 之前从没有认真去了解过那年那以日期为称呼的事件，甚至之前我都没听说过昨天去世的那个人。之前只是跟风，觉得知道了一些别人不知道的，有人不想让你知道的事会显得自己很厉害，却从来没考虑过事情的真相，事情的发展。个人觉得其中肯定夹杂着境外破坏势力，但是更多的人只是想要”自由”和”民主”，他们一直试图和平解决。这件事双方都有错，一方是过分信任对方，太善良了；另一方也是应该从始至终保持一种态度，开始的温和派给了学生一种可以和平解决的希望。而后的强硬派则是让他们死在了自己的希望上。也许没有这件事。现在不会这样，应该是肯定不会这样。1984慢慢变成了现实，各种备案，各种下架，各种不符合当前法律法规。只是在意这件事的真相，在意那些去世的亡魂。其他那些政治的东西我不在乎，只是觉得应该给他们一个交代，他们什么都没错。之前总觉得这种事跟自己无关，远远躲开。但是 為眾人抱薪者， 不可使其凍斃於風雪。為自由開路者， 不可使其困頓於荊棘。 愿自由。","link":"/2017/07/16/R-I-P/"},{"title":"RecyclerView IndexOutOfBoundsException","text":"前言最近使用 RecyclerView 的 notifyItemInserted 和 notifyItemRemoved 的时候，经常遇到这个异常。 123456789java.lang.IndexOutOfBoundsException: Inconsistency detected. Invalid view holder adapter positionViewHolder{2064e5c6 position=2 id=-1, oldPos=2, pLpos:-1 scrap [attachedScrap] tmpDetached no parent}at android.support.v7.widget.RecyclerView$Recycler.validateViewHolderForOffsetPosition(RecyclerView.java:4505)at android.support.v7.widget.RecyclerView$Recycler.getViewForPosition(RecyclerView.java:4636)at android.support.v7.widget.RecyclerView$Recycler.getViewForPosition(RecyclerView.java:4617)at android.support.v7.widget.LinearLayoutManager$LayoutState.next(LinearLayoutManager.java:1994)at android.support.v7.widget.LinearLayoutManager.layoutChunk(LinearLayoutManager.java:1390)at android.support.v7.widget.LinearLayoutManager.fill(LinearLayoutManager.java:1353)at android.support.v7.widget.LinearLayoutManager.onLayoutChildren(LinearLayoutManager.java:574)... 查了一些资料，大多是说因为数据源改变了，但是 adapter 却没有及时调用 notifyItemRangeChanged 。 解决方案方法一自己写一个继承 LinearLayoutManager 的包装类，在 onLayoutChildren() 方法里 try-catch 捕获该异常。然后给 recyclerView 设置该 LayoutManager1234567891011121314151617public class WrapContentLinearLayoutManager extends LinearLayoutManager { //... constructor @Override public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) { try { super.onLayoutChildren(recycler, state); } catch (IndexOutOfBoundsException e) { Log.e(\"probe\", \"meet a IOOBE in RecyclerView\"); e.printStackTrace(); } }}...RecyclerView recyclerView = (RecyclerView)findViewById(R.id.recycler_view);recyclerView.setLayoutManager(new WrapContentLinearLayoutManager(activity, LinearLayoutManager.HORIZONTAL, false)); 方法二在进行数据移除和数据增加时，务必要保证RecyclerView的Adapter中的数据集和移除／添加等操作后的数据集保持一致！ 这里，前者是在该Adapter内部，不妨叫做内部数据集，后者是开发人员传过给Adapter的，不妨叫外部数据集。更新RecyclerView数据时，需要保证外部数据集和内部数据集实时保持一致。每一次对外部数据集做改动时，都需要紧接着主动对外部数据集和内部数据集做一次同步操作 外部数据集同步到内部数据集，使用如下的方法： notifyItemRangeRemoved(); notifyItemRangeInserted(); notifyItemRangeChanged(); notifyDataSetChanged(); 这里对 notifyDataSetChange() 做些说明： 使用该方法的更新内部数据集，没有默认的动画效果，同时更新数据的效率页不如上面的方法，官方不推荐使用这种方式更新数据集。 方法三使用notifyDataSetChanged同步外部数据集和内部数据集。该方法简单，但是失去了动画效果，并且更新数据的性能低。 另外，如果对外部数据集做了二次以上的操作，却只调用notifyDataSetChanged同步一次，也很有可能会报上文所示的错误。 参考文章: stackoverflow 当RecyclerView遇到Inconsistency detected崩溃 使用RecyclerView遇到的一些问题 Inconsistency detected","link":"/2018/05/03/RecyclerView-IndexOutOfBoundsException/"},{"title":"Scrapy命令行","text":"新建项目scrapy startproject Demo 该命令会在当前目录下建立一个名为 Demo 的 scrapy 项目 控制项目cd Demo 进入到项目目录中 scrapy genspider changoal changoal.cn创建一个新的 spider，该命令会在 spiders 文件夹下新建一个叫 changoal.py 的文件。文件里有以下内容：123456789import scrapyclass ChangoalSpider(scrapy.Spider): name = \"changoal\" allowed_domains = [\"changoal.cn\"] start_urls = ['http://changoal.cn/'] def parse(self, response): pass 可用的工具命令scrapy -h 可以查看所有可用的命令。 Scrapy提供了两种类型的命令。一种必须在Scrapy项目中运行(针对项目(Project-specific)的命令)，另外一种则不需要(全局命令)。全局命令在项目中运行时的表现可能会与在非项目中运行有些许差别(因为可能会使用项目的设定)。 全局命令： startproject settings runspider shell fetch view version 项目(Project-only)命令: crawl check list edit parse genspider bench startproject 语法: scrapy startproject &lt;project_name&gt; 是否需要项目: no 在 project_name 文件夹下创建一个名为 myproject 的 Scrapy 项目。scrapy startproject myproject genspider 语法: scrapy genspider [-t template] &lt;name&gt; &lt;domain&gt; 是否需要项目: yes 在当前项目中创建spider。 这仅仅是创建spider的一种快捷方法。该方法可以使用提前定义好的模板来生成spider。您也可以自己创建spider的源码文件。 例子:1234567891011121314151617181920212223$ scrapy genspider -lAvailable templates: basic crawl csvfeed xmlfeed$ scrapy genspider -d basicimport scrapyclass $classname(scrapy.Spider): name = &quot;$name&quot; allowed_domains = [&quot;$domain&quot;] start_urls = ( &apos;http://www.$domain/&apos;, ) def parse(self, response): pass$ scrapy genspider -t basic example example.comCreated spider &apos;example&apos; using template &apos;basic&apos; in module: mybot.spiders.example crawl 语法:scrapy crawl &lt;spider&gt; 是否需要项目: yes 使用spider进行爬取。scrapy crawl myspider check 语法: scrapy check [-l] &lt;spider&gt; 是否需要项目: yes 运行contract检查。(不懂有什么用)1234567891011121314$ scrapy check -lfirst_spider * parse * parse_itemsecond_spider * parse * parse_item$ scrapy check[FAILED] first_spider:parse_item&gt;&gt;&gt; &apos;RetailPricex&apos; field is missing[FAILED] first_spider:parse&gt;&gt;&gt; Returned 92 requests, expected 0..4 list 语法: scrapy list 是否需要项目: yes 列出当前项目中所有可用的spider。每行输出一个spider。 edit 语法: scrapy edit &lt;spider&gt; 是否需要项目: yes使用 EDITOR 中设定的编辑器编辑给定的spider 该命令仅仅是提供一个快捷方式。开发者可以自由选择其他工具或者IDE来编写调试spider。 fetch 语法: scrapy fetch &lt;url&gt; 是否需要项目: no 使用Scrapy下载器(downloader)下载给定的URL，并将获取到的内容送到标准输出。 该命令以spider下载页面的方式获取页面。例如，如果spider有 USER_AGENT 属性修改了 User Agent，该命令将会使用该属性。 因此，您可以使用该命令来查看spider如何获取某个特定页面。 该命令如果非项目中运行则会使用默认Scrapy downloader设定。 scrapy fetch http://www.changoal.cn view 语法: scrapy view &lt;url&gt; 是否需要项目: no 在浏览器中打开给定的URL，并以Scrapy spider获取到的形式展现。 有些时候spider获取到的页面和普通用户看到的并不相同。因此该命令可以用来检查spider所获取到的页面，并确认这是您所期望的。 scrapy view http://www.changoal.cn shell 语法: scrapy shell [url] 是否需要项目: no 以给定的URL(如果给出)或者空(没有给出URL)启动Scrapy shell。 scrapy shell http://www.changoal.cn parse 语法: scrapy parse &lt;url&gt; [options] 是否需要项目: yes 获取给定的URL并使用相应的 spider 分析处理。如果您提供 --callback 选项，则使用 spider 的该方法处理，否则使用 parse 。 支持的选项: --spider=SPIDER: 跳过自动检测spider并强制使用特定的spider --a NAME=VALUE: 设置spider的参数(可能被重复) --callback or -c: spider中用于解析返回(response)的回调函数 --pipelines: 在pipeline中处理item --rules or -r: 使用 CrawlSpider 规则来发现用来解析返回(response)的回调函数 --noitems: 不显示爬取到的item --nolinks: 不显示提取到的链接 --nocolour: 避免使用pygments对输出着色 --depth or -d: 指定跟进链接请求的层次数(默认: 1) --verbose or -v: 显示每个请求的详细信息 settings 语法: scrapy settings [options] 是否需要项目: no 获取Scrapy的设定。 在项目中运行时，该命令将会输出项目的设定值，否则输出Scrapy默认设定。 1234$ scrapy settings --get BOT_NAMEscrapybot$ scrapy settings --get DOWNLOAD_DELAY0 runspider 语法: scrapy runspider &lt;spider_file.py&gt; 是否需要项目: no 在未创建项目的情况下，运行一个编写在Python文件中的spider。 scrapy runspider myspider.py version 语法: scrapy version [-v] 是否需要项目: no 输出Scrapy版本。配合 -v 运行时，该命令同时输出Python, Twisted以及平台的信息，方便bug提交。 自定义项目命令您也可以通过 COMMANDS_MODULE 来添加您自己的项目命令。您可以以 scrapy/commands 中 Scrapy commands 为例来了解如何实现您的命令。","link":"/2017/09/27/Scrapy命令行/"},{"title":"changvision","text":"王小波说，一个人只拥有此生此世是不够的，他还应该拥有诗意的世界。 我觉得，单反 + photoshop = 整个世界。 世界本来已经很美好，但是单反和ps会让世界变得美好之极。 微博一直关注的TANGVISION，是一个婚礼影像记录团体，他们拍的每张婚纱照都有那么美好的笑容，看了就让人觉得幸福。 放几张自己拍的渣图~ （感谢宝哥出境，成为本人的第一位模特） 梦想就是买个好单反，不停地拍拍拍，拍人像，拍风景，拍静物，哈哈哈。。。走遍每一个角落，拍遍每一个人。 敬请关注 Lofter ChangVision 和 500px chang，有好作品会分享的~","link":"/2016/06/06/changvision/"},{"title":"java四大排序","text":"慢慢把数据结构和算法补起来吧。。 选择排序选择排序的核心思想就是先选出来最小的，再从第二个开始选出来最小的，直到全部排序完成。先把第一个数当成最小的，依次和第一个之后的数比较，如果小的话就记下下标，直到选出最小的，和第一个数进行交换。代码如下：12345678910111213private static void xuanze(int[] a) { for (int i = 0; i &lt; a.length; i++) { int min = i; for (int j = i; j &lt; a.length; j++) { if (a[j] &lt; a[min]) { min = j; } } if (i != min) { swap(a, i, min); } }} 交换代码：12345678private static void swap(int[] a, int i, int j) { if (i == j) { return; } a[i] ^= a[j]; a[j] ^= a[i]; a[i] ^= a[j];} 冒泡排序冒泡排序的核心思想就是从第一个元素开始，依次和它的下一个元素进行比较，如果比下一个元素的值要大，则交换，直到最大的元素排到最后。这样，每一趟会将最小或最大的元素“浮”到顶端，最终达到完全有序。 代码如下：12345678910public void sort(int[] a){ int length = a.length; for (int i = 0; i &lt; length - 1; i++) { for (int j = 0; j &lt; length - 1 - i; j++) { if (a[j] &gt; a[j + 1]) { swap(a, j, j + 1); } } }} 插入排序插入排序的核心思想就是，默认前面的数组是有序的，然后把下个元素插入到应该在的位置。代码如下：123456789101112131415161718192021222324public void sort(int[] a){ int j, target = 0; for (int i = 1; i &lt; a.length; i++) { j = i; target = a[i]; while (j &gt; 0 &amp;&amp; a[j - 1] &gt; target) { a[j] = a[j - 1]; j--; } a[j] = target; }}public void sort2(int[] a){ for (int i = 1; i &lt; a.length; i++) { for (int j = i - 1; j &gt;= 0; j--) { if (a[j + 1] &lt; a[j]) { swap(a, j + 1, j); } else { break; } } }} 快速排序这个是四个里面最复杂的排序了。当时刚开始看的时候一脸懵逼，后来看到一篇好博客，茅塞顿开：挖坑填数+分治法。 该方法的基本思想是： 1．先从数列中取出一个数作为基准数。 2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。 3．再对左右区间重复第二步，直到各区间只有一个数。 代码如下：12345678910111213141516171819public static void sort(int[] a , int start , int end){ if(start &lt; end){ int i = start , j = end , x = a[i]; while(i &lt; j){ while ( i &lt; j &amp;&amp; a[j] &gt;= x) j--; if(i &lt; j) a[i++] = a[j]; while(i &lt; j &amp;&amp; a[i] &lt;= x) i++; if(i &lt; j){ a[j--] = a[i]; } } a[i] = x; sort(a , start , i - 1); sort(a , i + 1 , end); }}","link":"/2017/07/18/java四大排序/"},{"title":"todo","text":"todo列一下目标清单上的一些计划。 技术android RxJava(源码解析、实战应用、操作符、设计模式) Kotlin(一些面试问题，高级特性) dagger(使用) Jetpack(详解以及使用) 高级(源码，bug，APT) 架构(设计模式，项目框架封装) 源码解析(OkHttp、Glide、EventBus、ButterKnife) Python Django 项目使用 Scrapy 使用 特性学习 500 Lines or Less 数据可视化 计算机网络数据结构生活 摄影(手机摄影) PS 健身 跑步 书 流畅的Python Android开发艺术探索 Head First 设计模式 代码整洁之道 HTTP 权威指南 万历十五年 王小波全集","link":"/2018/12/05/todo/"},{"title":"修改Activity进入和退出动画","text":"新建 Activity 进入和退出的动画在anim文件夹里面创建两个xml动画文件 activity_fade_in.xml123456&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;alpha android:duration=\"200\" android:fromAlpha=\"0.0\" android:toAlpha=\"1.0\"/&gt;&lt;/set&gt; activity_fade_out.xml123456&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;alpha android:duration=\"200\" android:fromAlpha=\"1.0\" android:toAlpha=\"0.0\" /&gt;&lt;/set&gt; 创建进入和退出 style123456&lt;style name=\"activity_fade_in_out\" parent=\"android:Animation.Activity\"&gt; &lt;item name=\"android:activityCloseEnterAnimation\"&gt;@anim/activity_alpha_out&lt;/item&gt; &lt;item name=\"android:activityCloseExitAnimation\"&gt;@anim/activity_alpha_out&lt;/item&gt; &lt;item name=\"android:activityOpenEnterAnimation\"&gt;@anim/activity_alpha_in&lt;/item&gt; &lt;item name=\"android:activityOpenExitAnimation\"&gt;@anim/activity_alpha_in&lt;/item&gt;&lt;/style&gt; 创建应用动画的 style123&lt;style name=\"fade_in_out_theme\" parent=\"Theme.AppCompat.Light.NoActionBar\"&gt; &lt;item name=\"android:windowAnimationStyle\"&gt;@style/activity_fade_in_out&lt;/item&gt;&lt;/style&gt; 在清单文件中设置 Activity 的Theme123&lt;activity android:name=\".Main2Activity\" android:theme=\"@style/fade_in_out_theme\" /&gt;","link":"/2017/07/03/修改Activity进入和退出动画/"},{"title":"八月十五记","text":"八月十五了，仔细想想，这应该是我第四个没在家里过的中秋了，从大学以来，就一直在外边。 前几天，跟朋友聊天，她一直在准备出国留学，说到什么时候回来的话题上，她反问我“你学完之后还会不会回临清？”。我呆住了，从大二以后，对这个行业有了些认识，就没有再想过回临清找工作，甚至是聊城，都没想过。也许等到累了的时候会回去吧。但是现在，我肯定不会回去，因为每个人都向往更高的地方。 她说，她留学是为了“谋生”，不是出去混的。那句话怎么说来着，这个世界上最可怕的是，比你优秀的人比你更努力。 我都要准备接受当一辈子平凡人，平庸的过一辈子的时候。突然我又想起来了，我不想当一般人啊，我要当“人上人”。所以要努力啊，一直以来，我都认为自己实力配不上自己的梦想，所以就一直抱怨啊，一直得过且过。但是我忘了，实力是可以提升的，只知道抱怨，从来不去努力的话，肯定是实现不了梦想的。就像原来我从来没想过出国，觉得离自己特别遥远，但是现在认真想想，为什么不可能呢，出国现在那么方便，费用也不是太贵，为什么就不可以呢，即使不能在外国生活，但是起码出去转一转，体验一下其他文化，也好啊。我现在已经从潘庄那个布恩那个再小的小地方走到北京了，为什么不试着走向更远的地方呢。就是那种 想去体验更大的世界的欲望嘛。 昨天晚上打了四个小时的电话，可能是我这辈子大的时间最长的一次电话了。大果子说在学校也挺无聊啊，学不下去，目标就是海洋大学了。祥耀说 哈哈，你们几个都瘦了，还是要努力啊，肩上的胆子越来越重，重要的是心态要放稳，重点的怕考不上，报一般的又觉得对不起自己的努力，不甘心，挺难选择的，大家都要好好干啊。王琪说，最近太上愁了，选学校太难了，又怪自己之前没好好准备。唉，每个人都有自己的困难，但都是走在追求目标的路上，这就是一种幸福了。 我妈说，别太累了，我和你爸只想着你能平稳的生活就行，不要求你能挣多少钱啊，只要生活幸福就好。我说以后千万不能让刘悦敲代码啊，太累了。原来我一直没努力，只要是一般水平就满足了，从来不知道，人可以有多拼命，从来没逼过自己。但现在好不容易又重新有了有机会达到的梦想了，我不想放弃啊，所以要加倍努力啊。 要向优秀的人学习，跟琪哥学着照顾人，跟宝哥为人处世啊学祥耀怎么解决问题啊，学楷儿那么投入啊，学主任 吹牛逼啊。","link":"/2016/09/16/八月十五记/"},{"title":"函数式编程","text":"函数式编程编程范式:函数式编程是一种编程范式，我们常见的编程范式有,命令式编程（Imperative programming）,函数式编程, 逻辑式编程，常见的面向对象编程是也是一种命令式编程。 本质函数式编程中的“函数”这个术语不是指计算机中的函数（实际上是“Subroutine”），而是指数学中的函数，即自变量的映射。也就是说一个函数的值仅决定于函数参数的值，不依赖其他状态。 比如sqrt(x)函数计算x的平方根，只要x不变，不论什么时候调用，调用几次，值都是不变的。 函数式编程关心数据的映射，命令式编程关心解决问题的步骤(更数学化一点的描述：函数式编程关心类型（代数结构）之间的关系，命令式编程关心解决问题的步骤) 在函数式语言中，函数作为一等公民，可以在任何地方定义，在函数内或函数外，可以作为函数的参数和返回值，可以对函数进行组合。 纯函数式编程语言中的变量也不是命令式编程语言中的变量，即存储状态的单元，而是代数中的变量，即一个值的名称。变量的值是不可变的（immutable），也就是说不允许像命令式编程语言中那样多次给一个变量赋值。比如说在命令式编程语言我们写“x = x + 1”，这依赖可变状态的事实，拿给程序员看说是对的，但拿给数学家看，却被认为这个等式为假。 严格意义上的函数式编程意味着不使用可变的变量，赋值，循环和其他命令式控制结构进行编程。 特点 与面向对象编程（Object-oriented programming）和过程式编程（Procedural programming）并列的编程范式。 最主要的特征是，函数是第一等公民。 强调将计算过程分解成可复用的函数，典型例子就是map方法和reduce方法组合而成 MapReduce 算法。 只有纯的、没有副作用的函数，才是合格的函数。 不变性。 好处由于命令式编程语言也可以通过类似函数指针的方式来实现高阶函数，函数式的最主要的好处主要是不可变性带来的。没有可变的状态，函数就是引用透明（Referential transparency）的和没有副作用（No Side Effect）。 一个好处是，函数即不依赖外部的状态也不修改外部的状态，函数调用的结果不依赖调用的时间和位置，这样写的代码容易进行推理，不容易出错。这使得单元测试和调试都更容易。 不变性带来的另一个好处是：由于（多个线程之间）不共享状态，不会造成资源争用(Race condition)，也就不需要用锁来保护可变状态，也就不会出现死锁，这样可以更好地并发起来，尤其是在对称多处理器（SMP）架构下能够更好地利用多个处理器（核）提供的并行处理能力。 参考： 函数式编程入门教程 什么是函数式编程思维？nameoverflow 什么是函数式编程思维？用心阁","link":"/2018/03/30/函数式编程/"},{"title":"十二年一轮回","text":"一个月的时间，法国欧洲杯终于结束了。 结果是好的，葡萄牙有史以来第一次获得国际大赛的冠军，威尔士第一次参加欧洲杯就进入四强。作为皇马球迷是非常高兴的。 犹记得第一场看的是克罗地亚vs土耳其，魔笛惊世骇俗的一脚世界波，踢得我当时就服了，但愿下赛季回到渣团多进几个这样的神仙球吧。然后其他的小组赛都是看的集锦，都没完整的看过直播。大圣的两个任意球尤其漂亮，球速快，急下坠，力量大，颇得我罗的真传，下赛季的任意球就交给你了，干巴爹。 熬夜看的第一场淘汰赛是西意大战，虽然我支持西班牙，不过我承认意大利是踢得更好的那支球队，把防守演绎到了极致，虽然没有大牌球星，不过团队的合作极其流畅，跟一台严密的机器一样，每个人都会出现在应该在的位置，防守反击也是犀利，可惜最后阵容不整，败在了德国人的脚下，但意大利仍然是本届欧洲杯表现最好的球队。 没想到的是葡萄牙竟然一路跌跌撞撞的打进了决赛。法国人教给我们不要败人品，世界上真的存在一种力量叫做 命。即使你准备了庆祝大巴，即使你的阵容星光璀璨，即使你是主场作战，即使帕耶把我罗踢下场，然而你还是输掉了比赛，葡萄牙才是冠军。 十二年前，我八岁，都不知道什么是欧洲杯。就是那一年，葡萄牙所谓的黄金一代作为东道主打进决赛，确在离冠军一步之遥的决赛中输给了希腊，就是堪称足球神话的那只希腊队，C罗那年18岁，表现亮眼，在赛后留下了伤心的泪水。十二年来，葡萄牙星光不再，三届世界杯两届欧洲杯都没有太好的成绩。终于今年在我罗的带领下，葡萄牙的老将和小将们踏上了法兰西的土地，虽然决赛中，C罗因伤下场，但没有人能说你配不上冠军。 自从欧冠以一己之力帽子戏法逆转淘汰狼堡就彻底成了你的脑残粉。 希望足球原离伤病。 是真的会有奇迹的！","link":"/2016/07/11/十二年一轮回/"},{"title":"可是过往便是过往","text":"我终究还是要走的，纵然我可以舍得，纵然我舍不得。 我的记忆里，有这里的时光，有这里风吹过的声音，有许许多多人的笑脸和哭泣，那我对于这段 时光而言，又算什么呢。 大概一切只是一个名字。 对于一个终究要说再见的人而言，忘掉这段记忆对你而言，很容易，只要你忘记我的名字。 不过谢谢你，谢谢你的所有，谢谢你。 可是啊，过往便是过往，不可磨灭啊。 可是啊，可是过往也不是过往，而我要怎么忘记你呢。 对你的一切视而不见。假装从来不知道你离开，也假装你明天就会回来，假装自己是一个哑巴，说不出任何话，也发不出任何声音。假装站在你面前，继续夸夸其谈我的优秀，假装关于你的一切我从未在意。 你何不忘记她，也许我从未对你说过很多话，但我绝不会不告而别，绝不会枉顾你的心意，绝不会假装看不到你难过，绝不会在每一个有情节的段落里，走漏一点点关于你的风声。哪怕到老，我会像一个小偷瞒天过海，藏着你和我之前所有的秘密，一个人，悄悄看着他们。 我在另外一个地方，听到有两个声音同时在跟我说话。 一个声音牵挂着我，另外一个声音在和他争吵。 我在不知名的地方醒来，看见那些潮湿而温暖的过去，被陡然的隐藏在地平线下。 我在不知名的地方，用回忆封印，借助冰冷的事物前行，春夏秋冬疏忽而过。 而我的马蹄，大概永远都在美丽的错过。 也许，我不是归人，只是一个过客。 那个所谓的过客，你能听得见我的声音吗？ 我听得见。 她听不见！ 我猜，也许是我们约定的时针除了差错。 也许在你出现的上一秒，有人加快了脚步。 他只是无视了时间，悄悄把踪迹擦掉。 否则我不会一直原地，苦苦等待你的下落。 也许我和你的齿轮，终究无法再邂逅。 可能她在另一个世界苏醒，已经更改了灵魂。 像永远等不到黄昏黎明的日与夜。 像，空荡码头，永远等着船只的水手。 像，落在深海上，寂静无声的雨点。 我赤手空拳，就像个无赖。 但那又怎样呢。 你以为她独自处在沙漠，你就想做那片遥远绿洲吗？ 我啊，我喜欢我没有的东西，而你是那么的遥远。 是啊，而我们竟还要不断地赶路，各奔东西。 远或近，她在意吗？ 但你知道吗，我曾经以为我和你的名字总会靠在一起。 可谁都要不断接受别离，重逢与错过。 她并不是为了你一个人而存在。 但你知道吗？我不在乎你是往左或是往右。 你以为谁都很清楚自己的方向。 所以你认定了吧，她的方向就是你的方向。 但你知道吗，我就想一个木偶，扯线的人已经不知去向。 凭什么归咎于我！ 所以，你变成了一个哑巴。 告诉我，我用什么才能留住你。 不如，忘记我。 她甚至没有给你挽留的机会。 告诉我，是不是一定要无疾而终，来吊足我的胃口。 不告而别，也许是我的婉转。 是不是非得一记响亮的结果。 你满意了吧？ 你又怎么知道？ 可能疯了吧。 但是你的情绪有一点点是来自于我，我就是成功的。 这就是你对成功的定义吗？ 也许无动于衷，是你的方式。而她，只想奉还给你。 你不敢跟我正面迎战吗？因为我永远会赢你。 我是不想变得和你一样幼稚。 在她的世界中，载着过去的版图里，也许有你。 但愿。 我们就此作别，拥有不一样的路途和黄昏。 此生如一。 一心一意。 再见了。 你们会重逢吗？ 一心。 再见了。 一切安好。 顾一心。 再见了。 健康幸福。 唉，你听得见吗？ 原来，我听不见。 是的。她听得见。 如此，也好。 可是啊，顾一心，要是有一天，我能再见到你，我想对你说的，不是刚刚那些话。 你站在校门口，对我说，嗨，毕十三，我从美国回来看你了。 其实我想对你说，我杜撰过很多和你再相遇的版本，但那些都不是我真的会对你说的。而我想对你说什么呢？ 顾一心，我真的好讨厌你，我讨厌你那么喜欢另一个男生，我讨厌你无视我的态度，我讨厌你的不辞而别，我讨厌你忘记我，我讨厌你甚至不曾记得我。 我讨厌你，我真的好讨厌你。 你呢？ 你还讨厌我么？ 这是个喧嚣的世界我从未觉得安静过他的繁荣他的昌盛带给人们却只是更多的疲倦更多的抱怨 于是我捂住双耳不去听他的疲倦不去听他的昌盛不去听他的繁荣也不去听他的抱怨 于是我以为我的世界安静了 只是这世上总有那么一人，哪怕她不曾对我讲过一言一语，但我却听得到她的声音","link":"/2018/04/26/可是过往便是过往/"},{"title":"嗯","text":"原来一直都想着弄个博客，开始是因为不会搭建，后来是因为没时间。 期间也用过 lofter，csdn 什么的，但这些都是现成的，用起来没什么感觉， 今天终于搞出来了。 Blog 是用 GitHub Pages 和 Hexo 搭建的，平台是 windows10，主题用了 NexT 。过程不是太难，但是挺复杂，尤其是配置那些文件。弄完之后还是挺有成就感的。 贴上最喜欢的两个知乎回答要怎样努力，才能成为很厉害的人，人这一生为什么要努力？ 种一棵树最好的时间是十年前，其次是现在","link":"/2016/05/16/嗯/"},{"title":"四年之久","text":"2017.9.16 周六等了一年，终于等来了这天。我之前无数次想象着这天的场景。七年已经过去了四年。 提前一天，准备着要去的地方，最近的路线，路上的商家。你说去人少的地方，好，那就先不去故宫，你说不想去太远的地方，那颐和园798以后有时间再去。之前想过无数次在北京相见时的场景，没想到到了这天我却迟到了。 我记得跟你说过我特别讨厌北京，因为三张图给了我继续留在北京的支持，一张是雪中的故宫，我一直认为故宫真的是北京最值得逛的一处景点，无论去多少次都不会感到无聊，那种作为曾经皇城的尊严是别的地方感受不到的。第二张是角楼的照片，应该是每个摄影爱好者心中的圣地吧，我也去拍过，手机直拍，加上是正中午，糊的一片。第三张就是你，起码是一部分因为你让我选择继续留在北京。 之前有人问我有没有喜欢的人，我说不知道，因为我真的不知道自己还喜不喜欢你真的不知道。不过，昨天我终于确定了，我喜欢你，喜欢了你四年，真的，只是有时候可能不是特别喜欢那种。之前怕被拒绝，怕尴尬，但是现在都四年了，还怕什么，四年都过来了。这四年太年轻，什么都不懂，一直没有行动，还总是自己感动自己。当时说的七年现在已经过去一大半了。有时候经常会无缘无故的想起你，想到未来，想起与你的点点滴滴。我已经习惯了一个人的生活，不过这种生活的前提是未来有你，不然的话我不知道我要怎么过来，像我这么无聊的人。 我要加油啊！带你去看故宫的雪。","link":"/2017/09/18/四年之久/"},{"title":"天亮了","text":"2016.7.25-2017.5.16 终于结束了，这地狱一般的生活，如释重负。终于不用天天提心吊胆，终于不用一直看着别人的脸色办事。至少是暂时不用。 对北京没有任何的好感了。一座冷冰冰的城市，一座压得人喘不过气的城市。那么无情，那么冷漠。 或许是该考虑什么时候逃离北京了。考研？考公务员？去济南青岛发展？要该好好考虑一下了。 奶奶的病还是没好，爸爸的腿现在又开始疼起来。我在想我是不是真的无情。虽然不能说是要感同身受，但是连最起码的关心我都没有表现出来。要好好关心身边的人啊。 认真生活。 愿永远健康！ （一年来拍下的夜景。从青岛到北京，从北京到临清）","link":"/2017/05/16/天亮了/"},{"title":"告白","text":"告白 像我这么一个如此理性的人，竟然会喜欢一个人这么长时间。 五年的时间。你就这么出现在我的世界里，悄无声息的融入到我的生活。以为你一直能陪伴到最后，从来不曾想你也会离去。我能理解，但我不能接受，也不想接受。 不能想象你身上的球衣不再是白色，不能想象伯纳乌的7号球衣会有新的主人。而我甚至都还没有亲眼到现场看过白衣飘飘的你在球场奔跑的样子。 因为大罗喜欢上足球。而你是我的足球初恋，到现在都还是觉得有些奇怪，为什么在当时巴萨如日中天，梅西势不可挡的时候在周围一票巴萨球迷的情况下还是选择了你。我看球晚，没见过伯纳乌王子在球场上的表现。从我看球第一眼，你就是伯纳乌的主人。我是幸运的，从13/14赛季开始，有幸见证了足球历史上最传奇的一段岁月，五年四冠，欧洲之王。 刚开始喜欢看你带球狂奔，花式过人，暴力头槌，无解电梯球。不过如果当时有人说，你会反超梅西，估计是没有人会相信的。14/15那个赛季，四大皆空，网上全是黑子，甚至有段时间都不敢打开新闻。被带节奏，认为你浪射，浪费机会，不支持队友……直到踢狼堡的第二回合，踢那个任意球的时候那个眼神，这辈子都不会忘，从那开始你好像就变了个人，我也从那次决定再不黑你，很庆幸那场球看了直播，还有客场踢拜仁4:0的那种，完美的表现。然后就是16年欧洲杯的时候，可以说是奇迹吧，欧洲球王就是你的完美称号。从此，你又转型，减重，减少持球，做纯粹的“射门员”，你和齐祖互相成全，三连冠，前无古人。之前一直以为自己是队迷，到现在才发现我是你的人迷。 你就是最完美的球员。 希望明年皇马尤文再次出现在欧冠决赛的舞台，120分钟内4:4，你上演大四喜，然后结果就交给点球大战吧，最完美的结局。 1个传奇，2夺联赛，3连欧冠，4座金球，5子登科，6双欧靴， 7号球衣，8次一阵， 9年时光，10分不舍。 Cristiano Ronaldo","link":"/2018/07/21/告白/"},{"title":"好好活着总会有好事发生","text":"苦海翻起爱恨，在世间 难逃避命运 “好好活着总会有好事发生”，我记得这句话应该是张莹莹说的吧。 又过去了一个月，那些之前担心的问题，现在或多或少都有了解决的方案。所以说 碰到事情的时候不要焦躁，不要太害怕，再害怕也不能解决问题。淡定下来，慢慢想解决问题的方法，事情总会有回旋的余地。 十一 在家里呆了整整七天，离上次回家过去了整整五个月，在外边这么长时间，感觉这次最想家。毕竟以前是在学校，什么都不用担心，吃吃喝喝，天天玩的那么爽，轻易不会想家。但在这儿就不一样了，各种压力。还是回家好啊。再外边睡觉总是没有安全感，经常会失眠，但在家里就不一样了，睡的特别爽。现在想来，等以后不想在外边了，回家也是很好的选择啊。 突然听到消息要提前毕业，感觉自己还没学多少东西呢，什么都不会","link":"/2016/10/24/好好活着总会有好事发生/"},{"title":"小雪","text":"如若变成生命中的情不自禁，那就用最温暖的手臂，拥抱自己。 下起了雪，正好小区里有几棵腊梅，可惜不是真的。想象着记忆里青岛下雪的场景是什么样子，雪花漫天飞舞，纷纷扬扬，一片一片的从天空飘落，不知道还有没有机会在看到下雪的青岛。 找工作第三周。我人生的这前二十年都是春天，几乎从来没有遇到过什么困难。然后这半年就突然到了冬天，中间都没有过渡。突然理解了为什么古代那些诗人只有在极其落魄失败的情况下才能写出那些可以绝世传诵的诗词，真的是有感而发，自己最亲身的经历，才能写出这些如泣如诉的句子。 前几天看一档综艺节目，金志文说到当时自己在北漂，在自己最落魄最痛苦的时候，是赵传老师的一首歌给了他坚持下去的力量，陪他从那段困难的日子里走了出来。我当时还不理解，哪可能有说的这个感动，肯定是节目的效果。现在我才能微微感受到那种感觉，之前只是自己没经历过罢了，永远不会体会到别人的感受。那时候一个人躺在操场上听着《你离开了南京，从此没有人跟我说话》，今天一直循环的《梵高先生》，李B现在已经不唱《梵高先生》了，他说他回不到当时写歌的那种感觉了。还有那时候的《secret base》。 加油啊，最近太浮躁，还是要认真学技术。减少无脑抱怨，多想一下解决方案，多多“有效”努力。 最落魄，最失败的日子。哈尔滨果然没有青啤好喝，不过我怎么可能分得清好不好喝，我只是想念以前罢了。 对北京唯一的好印象就是两张图片了，一张是角楼的照片，另一张就是雪中的故宫了，皇城的那种威严，那种雄伟，别的地方是不可能有的。之前说过，不会一直留在北京，但是不是那种呆不下去灰溜溜的狼狈的逃走。","link":"/2017/02/25/小雪/"},{"title":"师太","text":"师太，第一次见你是13年10月1日，国庆放假回家的那天早上认识的你，我记得清清楚楚。 从那天到现在也有两年半的时间了。从陌生人变为熟人再到无话不说，但是因为10月31我办了那件蠢事，就变了，我无法装作那件事没有发生，对我来说，那件事始终让我心有隔阂。 不多说。你要好好考研啊，我也会努力，因为我说过，我要变得优秀到能配得上你。 师太，你知道咱们第一次见面是什么时候吗，那是13年10月1日的早上，看见你拉着旅行箱从A17走出来，短发散在肩上，正是合适的长度。四个人，三辆车，偏偏是咱们俩一辆车，我一直坚信这是证明咱们有缘的重要事实。 后来知道了当时你在谈恋爱，还是有些遗憾的。又是因为回家，联系越来越密切。那是早晨，站在拥挤隧道三的车上，路过石油大学，海上嘉年华刚刚建好。隔着两三个人，你用手指了指摩天轮，然后笑了笑。你知道吗，我到现在都清楚的记着你当时的笑容。李宗盛说春风再美也比不了你的笑，没见过你的人不会明了。我想这是最好的形容了吧。 再后来从你的只言片语中看出你分手了，当时很像安慰你，却发现我并没有这样的身份，只能慢慢的慢慢的跟你聊天，拉近我们之间的关系。多亏了老刘的创业中心，给我提供了一个完美的借口，我终于可以经常见到你了。一直聊天，关系也像我预料中的越来越密切。不过，我没想到我又会陷进去，无法自拔。天天想你，发了疯似的想。正好你当时发了一些比较暧昧的微博，我就自作多情了。 你说会找到有缘人的。你说等着吧。你发微博有多久没见你，配图写着我一直在这里等风也等你。这怎么能不让我自作多情，我试图忍着，我故意不联系你，越是压抑越是强烈，终于我不想再这样了。那条短信我写了一天，我犹豫了一天，11点多还是发了出去。也许我早就知道了答案，只是不想承认，满心期待着万一幸运女神真的在呢，万一你被我感动了么。我真的害怕，我怕看到那个字。也是害怕，所以发的QQ消息，心里还想着可能你没上QQ呢，也可能你收不到呢，这样还可以装作什么都没发生继续原来的关系。所以看到消息已发送之后，就立即按了关机键。我试图催眠自己，睡一觉也许一切都过去了。根本不可能。早晚要面对，十二点多还是把手机打开了，嗯，虽然之前已经想到了这个结果，但看到那段话的时候我还是颤抖了，全身都在不由自己地哆嗦。你怕伤害我故意说的委婉，当时我脑子就像空了，我真的看不到那个“不”字我是不会承认的。最后你还是说了。我还是懵了。第二天早晨去上了党课，然后去了八大关，真的笑不出来，在青岛买了个哆啦A梦，现在还挂在我的墙上，部长聚餐喝了七八瓶啤酒吧，不行了，从没喝过这么多的酒。吐得一塌糊涂。 说着当那件事没发生过，但还是有了隔阂。聊天时总是小心翼翼，那件事成了一个炸点，仿佛如果我说的跟这件事有关的话。 忘了无数次，放弃了无数次，但只要看你一眼，只要听你说一句话，我就知道我忘不了你，我也不想忘记你。 忘了是哪次回学校了，好像是大一暑假坐客车回来。路上停车休息时，你去上厕所，我背着你的包，胳膊上搭着你的衣服，那瞬间只有一个感受，幸福。还有年前还是回家，在出租车上，你睡着了，斜靠在我肩上，当时就想紧紧的抱住你，让你舒服的睡。朋友之上？恋人未满。 还有我自己特别喜欢的一封情书 致未来的你 今天是2014年3月21日，321，这是一个有趣的日子，我一个人开着车经过卢浦大桥，夕阳斜下，漫目熔金，于是又想到了你。 世界之大，有些人在欢笑，有些人在哭泣，有些人举杯痛饮，有些人细品茗茶，有些人为生活的压力四处奔走，有些人碌碌无为，虚度年华。当思念这两个字坠落在我心底的这一瞬，我并不知道，你在做着什么？是在办公室里加着班，还是在拥挤繁华的街头匆匆漫步，亦或是在地铁里眯着眼打着瞌睡，无论此时你身在何处，是否也微微抬头，陪我一起看这抹残阳？ 我曾无数次幻想你的容颜，想象着你的眼角眉梢，定是带着些许碎纹。因为我想你一定是一个爱笑的人。古龙说，笑得甜的女人,将来的运气都不会太坏。想到你我注定相遇，我便痴痴的信了这话。小鱼儿飞身救苏樱于深泉，西门吹雪为孙姑娘轻展笑颜，你看，原来笑得甜的姑娘，命真的不会太坏。于是我多么希望你能笑的再甜一点，生活已经苦如莲心，何必徒增烦恼。我深知这世间的生活，并不是你想慢，便慢的下来；想笑，就笑得出来。但请坚信，我定会在人生的某个岔路口等候着你，此后无论荆棘遍地，还是锦衣玉食，你可以走得再从容一点，走得再轻松一点，因为一路有我。 你并不知，我渴望遇见你的心有多么强烈，可你亦不知，我畏惧遇见你的心又有多么忐忑。我多希望，生活这么长，能够伴你左右的是一个有趣的人。可是我既无俊朗的外貌，也无幽默的言谈，甚至时不时还会做一些愚蠢狭隘的事，说一些肤浅无趣的话。潘闲邓小驴，我无一拥有，若是硬说，恐怕只有潘长江的貌，闲家放炮的命，邓通的文采，驴大的脑子，这小字落在眼睛上，还真聚的了光。其实，也就是短短的三个字，二十四笔的转折，我竟絮絮叨叨，说了半天。你这么聪慧，定会笑我没得文采，迂腐倒是与日俱增。可你若是听得不厌，我愿余生请你指教。 这是我给你写的第七封情书，我不知道你会在什么情况下看到这些琐碎无谓的字迹。是穿着宽松的棉织T恤坐在新居的沙发里，厨房里是我忙碌洗碗的身影，还是在婚礼的现场，此时你站在我的身侧，是正哭着笑，还是正笑着哭，我是不知的，我唯一知道的是，穿婚纱的你应是这世间最美丽的女子，美丽本是俗字，可我却已辞穷。 但我还是希望，能与你一起跋涉在荒漠沙谷，探寻未知的精彩。山脊蜿蜒，你走在我前面，我唤你回头，从被汗水打湿的衣服里取出这一封信，一个字一个字的念给你听。 此时身侧，夕阳斜下，落日熔金。","link":"/2016/07/13/师太/"},{"title":"收藏","text":"View HenCoder 自定义 View 如何高效学习Android动画？ 图解 Android 事件分发机制 从Toast显示原理初窥Android窗口管理 可视化 ListView 缓存机制，手摸手带你打通任督二脉 Android Transition Framework详解—超炫的动画框架 架构 Android Studio 构建那些事 Android源码设计模式分析 Android App的设计架构：MVC,MVP,MVVM与架构经验谈 带你领略Clean架构的魅力 一个优秀的Android应用从建项目开始 源码 Android中为什么主线程不会因为Looper.loop()里的死循环卡死？ 为什么 Android 要采用 Binder 作为 IPC 机制？ 性能 Android内存优化之OOM 框架/库 给 Android 开发者的 RxJava 详解 Android常用开源项目及库 OKHttp源码解析 掘金 Android 文章精选合集 RecyclerView 使用ItemDecoration实现吸附效果 Java 深入理解Java内存模型（一） 面试 Android面试题 国内一线互联网公司内部面试题库 android2017经典面试题汇总 Android拿高薪面试题必看 Android 开发工程师面试指南 亲爱的面试官，这个我可没看过！ 经验 Android开发中，有哪些让你觉得相见恨晚的方法、类或接口？ 有赞Android客户端网络架构演进 Android 测试相关的方方面面都在这儿 博客 Android 开发技术周报 技术小黑屋 泡在网上的日子 干货集中营 玩Android Android系统开篇 Android官方培训课程 老罗的Android之旅 书籍 Android开发艺术探索","link":"/2018/03/30/收藏/"},{"title":"此间","text":"来北京一个月了，果然很快啊，这样算的话，这段注定是不堪回首的日子已经过去四分之一了。 这一个月还好吧，经历了不少，现在也算是一半身在社会中了，还是学校好啊，真的体会到了。 还是爱玩，以后要变变了，起码 玩的时候要好好玩不要考虑其他事，哈哈哈。 是我自己一直太过自负，总是有一种迷之优越感，总是觉得其他人不如自己，只有自己想着要努力。我喜欢这种优越，但是现实是每个人都想着努力，可以产生优越感，但是要让自己拥有可以优越的本钱啊。 还是太浮躁，我一直都是自己的能力配不上自己的野心。 淡定，慢慢来。 最近特别喜欢看那种治愈系温暖类的电影：一个叫欧维的男人决定去死，一一。也许是因为心里太没安全感，太寂寞。 “我们是选择死亡还是努力活着呢？” 女主很漂亮，她的出现改变了欧维的一生，他俩才是最适合的吧。 “我觉得，我也老了。” 三个小时的电影一点不让人觉得无聊，通过一件一件小事讲述了主题，家？人？ 奥运会结束了，犹记得四年前林丹战胜李宗伟夺得奥运冠军后，我还转了一篇日志“林丹，李宗伟，一辈子的对手，一辈子的朋友”，喜欢这种惺惺相惜的英雄，一扯到时间就变得伤感。女排又夺冠了，又是逆转，确实让人振奋，我很激动啊。竞技运动果然热血沸腾，足球更是如此。 这是个喧嚣的世界 我从未觉得安静过 它的繁荣，它的昌盛 带给人们却只是更多的疲惫，更多的抱怨 于是我捂住双耳 不去听它的疲惫，不去听它的昌盛 不去听他的抱怨，不去听它的繁荣 于是我以为我的世界安静了 只是这世上总有那么一人 哪怕她不曾对我讲过一言一语 但我却听得到她的声音","link":"/2016/08/22/此间/"},{"title":"毕业快乐","text":"直到今天送儿子吃完饭坐上6路后，才真的体会到了离别的气氛。 这一个月天天过着吃完睡睡完吃的日子。大家都在虚度这最后的时光，没人说毕业，没人说要离开，大家都在麻痹自己，试图让自己忘记马上要毕业的事实。 忽然想起了四年前入学的那天 ，因为之前从没见过海，所以挤上隧道一路过火车站的时候突然看见海的时候很惊喜。然后经过长长的隧道到了开发区。到南门报道后，走了好远才到宿舍。 当时太羞涩，不爱言谈。暑假晒得比较黑，所以我儿子以为我是个社会人。去了金沙滩，睡在银沙滩，还和我东哥和清总爬了小珠山。记得很清楚的在隧道三路过唐岛湾你看见摩天轮时的笑容。 当时年少不懂事，不知道客套，不知道推让。认识了很多逗比，我的儿子们，还有可爱的小干事们，一起办活动，一起搞事情。前几天吃饭的时候，倩倩说想起了三年前面试那天晚上的见面会。强哥发朋友圈配了张山科夜景“山水一程，三生有幸”。一年多没见的娟姐特意发给我“畅畅，毕业快乐”。想起了一年前毕业典礼后会场响起的“See you Again”,气氛突然变了，学长学姐们哭着拥抱，签名，喊着“毕业快乐”。下午考完数字图像处理跑到A17楼下送走娟姐。第二天送走征哥威哥琪哥平哥秀姐。 人的记忆真是可怕。吃饭时政哥突然提到我大二时有一天和大宝出去，回来时拿着个哆啦A梦，非常失落。那差不多是我大学前三年最失落的一天，清楚地记得听了一整晚的《secret base》，极其失望。出去拍照时，差不多总是一个人，想去哪去哪，想拍什么拍什么。 两年前看到毕业生留校时，我想自己毕业时一定要最后一个走，送走所有认识的人。一年前我送走12级时，我甚至都想好了等自己毕业时要发的说说“青山不改，绿水长流，各位后会有期”“大学四年过去了，我很怀念它”“别了我的山科”。 在青岛的这四年是我过的最快乐最自由的四年，我甚至把青岛当成了自己的另一个故乡，在北京我跟别人都是介绍青岛，八大关，金沙滩，天主教堂，一厂的扎啤，鲅鱼饺子……在北京最无聊的时候我就跟自己说等等就回家了，等等就回青岛了，回去就能爽的飞起，看我那贴满海绵宝宝的小窗，还有那一开窗就能看见蓝天白云青山的宿舍，当时特别想回来。想着不管怎样，青岛那里总归有一个可以让我睡觉的地方，然后就很开心了。 跟乾哥打电话，跟威哥打电话，跟秀B打电话，诚哥，清总。 最后一天给师太拍的毕业照简直了。只能强颜欢笑。 大姐买的草莓冰激凌很好吃。 只要一想 满脑子都是在山科的快乐小时光。 早上醒来。空间全是各种有缘再见。袁鹏给我评论”余生且长，后会有期”。走的时候没跟别人说也没问其他人什么时候走。出校门时，看见宝爷哭的很凶。上车时正好碰见冲哥，像两年前送他时一样看着我上了车。在北门跟我的儿子们拥抱，然后告别。 这一切，不会结束。","link":"/2017/06/24/毕业快乐/"},{"title":"用 viewpager 创建欢迎页轮播图","text":"使用 viewpager 创建欢迎页轮播图布局文件 123456789101112131415&lt;android.support.v4.view.ViewPager android:id=\"@+id/view_pager_2\" android:layout_width=\"match_parent\" android:layout_height=\"0dp\" android:layout_marginLeft=\"50dp\" android:layout_marginRight=\"50dp\" android:layout_weight=\"1\"/&gt;&lt;LinearLayout android:id=\"@+id/view_dot_container\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center\" android:gravity=\"center\" android:orientation=\"horizontal\"/&gt; 其中 view_dot_container 是轮播图下显示第几页的指示点的容器 adapter 需要继承自 PagerAdapter 1234567891011121314151617181920212223242526272829303132333435363738394041public class HelloAdapter extends PagerAdapter { private Context mContext; private int[] imgs; private List&lt;ImageView&gt; mImageViews; public HelloAdapter(Context context, int[] imgs) { mContext = context; this.imgs = imgs; mImageViews = new ArrayList&lt;&gt;(); for (int img : imgs) { ImageView view = new ImageView(context); ViewGroup.LayoutParams params = new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT); view.setLayoutParams(params); Glide.with(context).load(img).into(view); mImageViews.add(view); } } @Override public int getCount() { return imgs.length; } @Override public void destroyItem(ViewGroup container, int position, Object object) { container.removeView(mImageViews.get(position)); } @Override public Object instantiateItem(ViewGroup container, int position) { container.addView(mImageViews.get(position)); return mImageViews.get(position); } @Override public boolean isViewFromObject(View view, Object object) { return view == object; }} 在这里。我是传进来一组本地的 drawable 资源 ID，也可以传进来一个 View 的集合(如 List&lt;ImageView&gt; )。 PagerAdapter 的重点是 instantiateItem 和 isViewFromObject 方法。 instantiateItem 这个方法，return 一个对象，这个对象表明了 PagerAdapter 选择哪个对象放在当前的 ViewPager 中； isViewFromObject 用来判断 instantiateItem(ViewGroup, int) 函数所返回来的 Key 与一个页面视图是否是代表的同一个视图(即它俩是否是对应的，对应的表示同一个View) destroyItem 在重写该方法的时候主动从 ViewPager 中移除该 ContentView 。 初始化 123456789101112131415161718192021222324252627282930313233343536373839404142434445private List&lt;ImageView&gt; mDotViews;//用来存放指示点的集合private void initViewPager() { int[] imgs = new int[]{R.drawable.a, R.drawable.b, R.mipmap.c}; HelloAdapter helloAdapter = new HelloAdapter(this, imgs); ViewPager viewPager = (ViewPager) findViewById(R.id.view_pager); viewPager.setAdapter(helloAdapter); viewPager.addOnPageChangeListener(this);//监听 ViewPager 的滚动事件 mDotViews = new ArrayList&lt;&gt;(); dotContainer = (LinearLayout) findViewById(R.id.view_dot_container); for (int img : imgs) { ImageView dotView = new ImageView(this); dotView.setImageResource(R.drawable.bg_radius_4); LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(30, 30); params.setMargins(15, 0, 15, 0); dotView.setLayoutParams(params); mDotViews.add(dotView); dotContainer.addView(dotView); } viewPager.setCurrentItem(0); mDotViews.get(0).setImageResource(R.drawable.check_dot);}@Overridepublic void onPageScrolled(int position, float positionOffset, intpositionOffsetPixels) {}@Overridepublic void onPageSelected(int position) { for (int i = 0; i &lt; mDotViews.size(); i++) { tvTitle.setText(titles[position]); if (i == position) { mDotViews.get(i).setImageResource(R.drawable.check); } else { mDotViews.get(i).setImageResource(R.drawable.uncheck); } }}@Overridepublic void onPageScrollStateChanged(int state) {} onPageSelected(int position)：这个方法有一个参数 position ，代表哪个页面被选中。当用手指滑动翻页的时候，如果翻动成功了（滑动的距离够长），手指抬起来就会立即执行这个方法，position 就是当前滑动到的页面。如果直接 setCurrentItem 翻页，那 position 就和 setCurrentItem 的参数一致，这种情况在 onPageScrolled 执行方法前就会立即执行。 onPageScrolled(int position,float positionOffset, int positionOffsetPixels)：这个方法会在屏幕滚动过程中不断被调用。有三个参数，第一个position，这个参数要特别注意一下。当用手指滑动时，如果手指按在页面上不动，position和当前页面index是一致的；如果手指向左拖动（相应页面向右翻动），这时候position大部分时间和当前页面是一致的，只有翻页成功的情况下最后一次调用才会变为目标页面；如果手指向右拖动（相应页面向左翻动），这时候position大部分时间和目标页面是一致的，只有翻页不成功的情况下最后一次调用才会变为原页面。当直接设置setCurrentItem翻页时，如果是相邻的情况（比如现在是第二个页面，跳到第一或者第三个页面），如果页面向右翻动，大部分时间是和当前页面是一致的，只有最后才变成目标页面；如果向左翻动，position和目标页面是一致的。这和用手指拖动页面翻动是基本一致的。如果不是相邻的情况，比如我从第一个页面跳到第三个页面，position先是0，然后逐步变成1，然后逐步变成2；我从第三个页面跳到第一个页面，position先是1，然后逐步变成0，并没有出现为2的情况。positionOffset是当前页面滑动比例，如果页面向右翻动，这个值不断变大，最后在趋近1的情况后突变为0。如果页面向左翻动，这个值不断变小，最后变为0。positionOffsetPixels是当前页面滑动像素，变化情况和positionOffset一致。 onPageScrollStateChanged(int state)：这个方法在手指操作屏幕的时候发生变化。有三个值：0（END）,1(PRESS) , 2(UP) 。当用手指滑动翻页时，手指按下去的时候会触发这个方法，state值为1，手指抬起时，如果发生了滑动（即使很小），这个值会变为2，然后最后变为0 。总共执行这个方法三次。一种特殊情况是手指按下去以后一点滑动也没有发生，这个时候只会调用这个方法两次，state值分别是1,0 。","link":"/2017/09/21/用-viewpager-创建欢迎页轮播图/"},{"title":"电影推荐","text":"大学时看了不少电影。在这里给大家推荐一下个人特别喜欢的吧。 先说几部对自己影响特别大的电影吧。在我心里都是神作 《死亡诗社》 清楚地记得这部电影是大二寒假放假前一天晚上在宿舍看的，当时只是看着 这部电影的评分好高啊，然后就找了资源。刚开始看的时候电影比较沉闷，有些无聊，前半段的亮点只有在山洞里展开的那副裸女图了。看到结尾，感觉怪怪的，心情很沉闷，不知道该说些什么，能遇到 基汀 这样的老师是每个学生的幸运。印象最深刻的两个场景，一是 基汀 老师在课堂上带着学生撕掉了他们的教科书，二是上图基汀老师被校长赶走时，学生们不顾老师的 纷纷站上课桌，喊着”captain, my captain” ，以这样的行为来表示对基汀老师的支持。 《飞越疯人院》 人们总是对生活习以为常。对某些规则总是遵守，不问规则的意义，不问为何要遵守，这时候总需要有一个人来打破这规则。让人们知道，哦，还可以这样做。 这是当时我看完电影后写下的影评。看完后心情久久不能平息，可能是因为我生活中太乖了吧，总是循规蹈矩，遵循着生活的规则，没有一点“意外”出现，日子太枯燥，所以看到这样的电影的时候,像是突然在睡梦中被惊醒一样 砰 的一声，炸开来。 《蝙蝠侠：黑暗骑士》 《本杰明·巴顿其事》 《那些年，我们一起追过的女孩》 《大话西游》 《让子弹飞》 《布达佩斯大饭店》 《闻香识女人》 无间道 开心家族 肖申克的救赎 美丽人生 窃听风暴 星际穿越 一一 小森林 美国往事 放牛班的春天 爆裂鼓手 饮食男女 少年时代","link":"/2017/08/24/电影推荐/"},{"title":"知乎用户基本分析","text":"知乎用户统计昨天爬取了知乎大v “朱炫” 的关注者的用户基本信息。 如图所示，朱炫总共有 676697 位关注者，半小时爬取了 117913 条用户的基本信息。用户信息里每个用户只有 18 个字段的信息，都是一些很基本的信息，如图 通过 requests 爬取，存进 mongodb 里。下面是一些基本分析： 性别 12万的用户里，男性有 25819 位，女性有 31095 位，还有 60999 位没有设置性别信息。 回答 其中有 63109 位用户从没有回答过问题，32376 位用户回答过 5 个以内的问题，而回答数量超过 50 的只有 2536 位用户。 关注者 有 60749 名用户是没有被任何人关注的，47116 名用户有10个以下的关注者，只有 3349 位用户有50个以上的关注者。 机构号在 12w 的关注者里有 29 个机构用号关注了大师兄，只选取了关注者最多的 10 个机构号来显示。 关注者查取了10位关注者最多的用户。 有趣用的最多的用户名你们猜用的最多的用户名是什么？ 好像没有一个真名== 用的最多的个人简介是这些： 看来知乎是学生党的天下。。 总结爬虫使用 requests； 数据库是 MongoDB； 绘图用了 matplotlib.pyplot 和 pylab MongoDB 作为非关系型数据库的代表，不用 sql 语句，使用起来确实是方便了一些。 绘图刚学，柱状图的标签还都没有居中== python 是世界上最好用的语言 python 是世界上最好用的语言 python 是世界上最好用的语言","link":"/2017/12/17/知乎用户基本分析/"},{"title":"法","text":"观念大概是从 PGONE 被封杀开始转变的。当时也跟微博上那些吃瓜群众一样，拍手叫好，喜闻乐见。是对嘻哈没有什么兴趣，倒不是说讨厌他，只是讨厌她的粉丝，就像之前的薛之谦，吹的太过，捧得太高，但更多的是有人的一种习性吧，见不得这些，或许是有些嫉妒？更多人是选择去落井下石，补上一脚。当然也有我。清楚的记得当时有人为这种 “处罚” 鸣不平，当然在那个时候，我是不会在意这些腔调的。直到后来，参加了一期《歌手》的 GAI ，突然被退赛，一夜之间，嘻哈全面被封杀，这是才真正明白，为什么当时有些人会鸣不平，不只是 PGONE 的粉丝，还有些人看到了未来，被ZF干预。封杀这件事，如果你说他是违了法，好，说出来具体违反了什么法律法规，然后按相关规章制度办事，大家都就没有异议的。但是只是凭上层人士的个人喜好来处理，这算不算滥用职权。不存在的，在中国，没人敢说的。 又记起了上个赛季发生在中超的那些处罚，罚那么重，好，罚那么重也算了，只要大家都这么罚，也没什么，但是为什么，同样的犯规，最后处罚会差那么多。 马克思主义告诉我们，事情总是相对的。社会主义国家在面对重大灾难的时候，国家就是好，集中全国干大事。但是在上述问题下，国家的干预就不那么招人喜欢了。最近一直在想一个词，饱暖思淫欲。之前，大家都在为填饱肚子在忙，没时间去了解其他事。现在不一样，“闲人”太多，消息又这么发达，也都在接触一些国外的那种“开放”、“民主”的精神，所以会出现一些问题。 《我的团长我的团》中龙文章说：英国人死于傲慢与偏见，中国人死于听天由命和漫不经心。 我只是想要宪法赋予我的那个世界。","link":"/2018/09/28/法/"},{"title":"目标啊","text":"虽然后天就要考sql server，虽然到现在我才看了一遍课本。 我实在是看不下去了。。。 看了老韩的博客，发现自己真的是弱爆了。。 要是再有一次机会，我肯定好好学编程的。。 这学期买了很多书，有的是知乎的推荐，和stormzhang的android学习之路和的程序员技术练级攻略。 买了《疯狂java讲义》，《第一行代码Android》，《Head First Java》，《Java编程思想》，《算法 第四版》 ，《数据结构与算法分析 C语言描述》。C语言基础太差，C++和没学过一样，数据结构也一样。 还有网络和组成原理。。。。听说《鸟哥的Linux基础》也挺好。。 打算再买《编程之美》，《剑指offer》。看着以后的发展方向再买书吧。 我要是能把这些书都看完那得。。。。。不说了，慢慢看吧。 怕什么真理无穷，进一寸有一寸的欢喜。 –胡适","link":"/2016/05/23/目标啊/"},{"title":"你的眼里有光","text":"反正已经都这样了，还能怎么办（︶︿︶），还不如笑呢(=^▽^=)，是吧。 总有些笑容，每次看见不管再差的心情都会立刻笑容满面，比如韩佳人啊，比如你啊，记得你在隧道3车上看见摩天轮时对我的微微一笑，记得你在换宿舍时却发现我在帮别人换宿舍时笑着拍了我一巴掌，记得你在坐客车回家的时候在休息区上厕所的时候很自然的把外套给我，我搭在胳膊上，等你出来，这就是我想象中的情侣该有的样子。 后来，我想为什么对这些细节记得这么清楚。就刚才，我想到了，你的眼里有光，看见摩天轮时的羡慕，对我的抱怨和娇气，还有那种自然。你的眼里有那种让我抵挡不了的东西。我一直认为眼漂亮的话，人就不会难看，因为眼里有光。 争取若干年之后，我可以说：“我一直在你的眼里啊”。 为了让你爱上我，人们对我说：“要让她笑啊。” 可是每次你一笑啊，明明是我又爱上了你","link":"/2016/09/16/要笑啊/"},{"title":"走了","text":"三年三年又三年，又到了离开的时候，或许可以说我的学生生涯已经结束了~ 三年前，当我和爸妈还有妹妹下了10路，看到山科这么气派的南门的时候，有一种土包子进城的感觉。当时觉得山科真是大啊，走了十多分钟才走到宿舍，而且宿舍还挺好的，比三中真是强多了（ 哈哈 不过，说实话，这三年，确实是改变了不少，起码见识到了更多的东西，认识了更多的人，看到了一个更大的世界。 现在，大家也算是为了自己各自的未来开始奋斗。 不多说了，说得越来越伤感。 山科，等我回来啊！我要衣锦还乡。 宝哥，俊哥，主任，楷儿子，升哥，政哥，浪哥。祥耀，大果子，花姐姐，考研加油啊，一定会成功。征哥威哥等我回来。 还有师太，加油啊 。我在北京等你，我还等着给你拍写真呢！","link":"/2016/07/22/走了/"},{"title":"足球","text":"又到了欧冠决赛之夜，想想这已经是我连续第三年看决赛了，大一的时候还没有这么喜欢皇马，大二的时候对两支闯入决赛的队伍没什么好感，所以算来这是我第一次以皇马死忠的身份看比赛。 我也不知道为什么就喜欢上了足球，然后就一发不可收拾的喜欢上了。 看每一场比赛，看每一条新闻。 爱鲁能，爱皇马，爱中国队。 不管结果如何，永远是美凌格， hala madrid!","link":"/2016/05/28/足球/"},{"title":"鲜衣怒马少年时","text":"鲜衣怒马少年时，一日看见长安花 很长时间没有这么充实过了，忙起来时间果然过的很快，忙起来的话也不会胡思乱想了。毕竟之前拉下太多了，荒废太长时间了，峰哥那么优秀的人比我强太多了吧，还是找不到合适的工作，我还能怎么样呢。 上周不知道为什么，心情很沉闷。想找个说话的人都没有，我记得之前在知乎看到一句话“不要对别人一直说你自己的事情，这个世界上不止你一个人有故事”。虽然现在身边的人越来越熟悉 ，但是有时候还是挺孤独的。就像之前跟升哥说过，我觉得一个人也挺好的，不用担心其他事情，只要自己饿不死就好，但是呢，有时候学到了一项新技术，拍到一张自认为很漂亮的照片，这时候连个可以分享的人都没有是会很落寞的。 然后周日的时候给家里打了电话，可是不知道要说什么。爷爷后来接了电话，听到爷爷声音的瞬间，我差点哭出来，原来都是奶奶接电话，一个多月没跟爷爷说过话了。 清楚地记得大学一共哭过三次，第一次是爸妈送我去学校，他们回去的时候，站在南门口，眼泪突然就掉下来了，第一次理解了分别的意义。第二次是听说爷爷要去天津的时候，当时是跟奶奶打电话的时候听到的，强忍着当时没有哭出来，找个理由抓紧花了电话才敢哭出来，那是在宿舍门口的阳台，我记得清清楚楚，当时还能听到操场上的人在大喊大叫，真的有一种 眼前的世界都与我无关的感觉，家永远我背后的支撑。第三次是我自己煞笔，在炮的宿舍，喝多了，自言自语说了很多话。也是因为在利清面前才敢哭吧，毕竟现在还联系的人里面差不多我俩认识时间最长。在日照的三天，跟我说了很多为人处世的经验，还有酒桌上的注意事项。以后再也不要喝醉，尤其是跟不熟的人，因为你永远也不知道你喝醉之后会有多么傻逼。 不要再哭。 一定要提高自己的知识水平，主要是要进入一个新的层次，毕竟心不止此。 两年之前，琪哥绝对不会是现在这个生活状态。相对于学生来说，他进入了一个新的阶层，有了新的生活方式，这一切是因为有钱了。他还一直跟我说 不要太在意钱 ， 一个缺钱的人永远不可能说出这句话。钱对现在的我来说是很重要，我一切的打算都要有钱作为基础，但是以后可能会觉得钱没有那么重要吧。但是首先要先得达到那个层次-不差钱。 还是要去看看更大的世界啊，要去认识更优秀的人啊。","link":"/2016/09/08/鲜衣怒马少年时/"},{"title":"鸡年大吉吧","text":"已经三个月没写博客了，也不是没有时间，也不是不想写，只是觉得不知道要怎么面对。正好才看到句话“逃避无耻但有用，玩物丧志却开心”。真的是。这三个月差不多是我最失败的一段时期了，像我这么骄傲的人，怎么能接受这么失败的事实。嗨，不要再想这些事了。“永远不要说自己很差”，我会记住的。 感谢这半年来的经历，这一年来很充实，改变了自己之前的很多想法。见识到一个更大的世界。 Pain is the payment for each precious thing.好好珍惜拥有的一切，得到自己努力中的未来。 未来生活重心 编程-足球-摄影 编程 主要是 java 和 python，java的话多看一些原理之类的书和博客，多了解一些后台知识。python 就主要是爬虫这一块，学一些数据处理之类的，深入了解python 和 http。 足球 看球的时间可能就少了。不是说要多看球，而是要空闲时间不是搞其他的了。争取把所有的业余时间用在看球和摄影上。 摄影 剩下的两个爱好之一，多拍多后期。争取买个单反。 如果有来生， 要做一棵树， 站成永恒， 没有悲欢的姿势。 一半在土里安详， 一半在风里风扬， 一半洒落阴凉， 一半沐浴阳光。 非常沉默非常骄傲， 从不依靠从不寻找。 以上","link":"/2017/01/28/鸡年大吉吧/"},{"title":"AIDL","text":"Book.java12345678910111213141516171819202122232425262728293031323334353637383940414243package com.honszeal.processdemo;import android.os.Parcel;import android.os.Parcelable;/** * date：2018/3/13 on 16:07 * desc: * author: liuch */public class Book implements Parcelable{ private int bookId; private String bookName; protected Book(Parcel in) { bookId = in.readInt(); bookName = in.readString(); } public static final Creator&lt;Book&gt; CREATOR = new Creator&lt;Book&gt;() { @Override public Book createFromParcel(Parcel in) { return new Book(in); } @Override public Book[] newArray(int size) { return new Book[size]; } }; @Override public int describeContents() { return 0; } @Override public void writeToParcel(Parcel dest, int flags) { dest.writeInt(bookId); dest.writeString(bookName); }} IDE 自动完成Book.aidl123package com.honszeal.processdemo;parcelable Book; ILibraryManager.aidl12345678910111213141516package com.honszeal.processdemo;import com.honszeal.processdemo.Book;interface ILibraryManager { List&lt;Book&gt; getNewBookList(); void donateBook(in Book book); int add(int a, int b); void log(String message);} 编译一下 切换到 project 选项卡，在 app -&gt; build -&gt; generated -&gt; source -&gt; aidl -&gt; debug -&gt; 包名 下 找到系统生成的ILibraryManager.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121package com.honszeal.processdemo;public interface ILibraryManager extends android.os.IInterface { public static abstract class Stub extends android.os.Binder implements com.honszeal.processdemo.ILibraryManager { private static final java.lang.String DESCRIPTOR = \"com.honszeal.processdemo.ILibraryManager\"; public Stub() { this.attachInterface(this, DESCRIPTOR); } public static com.honszeal.processdemo.ILibraryManager asInterface(android.os.IBinder obj) { if ((obj == null)) { return null; } android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof com.honszeal.processdemo.ILibraryManager))) { return ((com.honszeal.processdemo.ILibraryManager) iin); } return new com.honszeal.processdemo.ILibraryManager.Stub.Proxy(obj); } @Override public android.os.IBinder asBinder() { return this; } @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException { switch (code) { case INTERFACE_TRANSACTION: { reply.writeString(DESCRIPTOR); return true; } case TRANSACTION_getNewBookList: { data.enforceInterface(DESCRIPTOR); java.util.List&lt;com.honszeal.processdemo.Book&gt; _result = this.getNewBookList(); reply.writeNoException(); reply.writeTypedList(_result); return true; } case TRANSACTION_donateBook: { data.enforceInterface(DESCRIPTOR); com.honszeal.processdemo.Book _arg0; if ((0 != data.readInt())) { _arg0 = com.honszeal.processdemo.Book.CREATOR.createFromParcel(data); } else { _arg0 = null; } this.donateBook(_arg0); reply.writeNoException(); return true; } } return super.onTransact(code, data, reply, flags); } private static class Proxy implements com.honszeal.processdemo.ILibraryManager { private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) { mRemote = remote; } @Override public android.os.IBinder asBinder() { return mRemote; } public java.lang.String getInterfaceDescriptor() { return DESCRIPTOR; } @Override public java.util.List&lt;com.honszeal.processdemo.Book&gt; getNewBookList() throws android.os.RemoteException { android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); java.util.List&lt;com.honszeal.processdemo.Book&gt; _result; try { _data.writeInterfaceToken(DESCRIPTOR); mRemote.transact(Stub.TRANSACTION_getNewBookList, _data, _reply, 0); _reply.readException(); _result = _reply.createTypedArrayList(com.honszeal.processdemo.Book.CREATOR); } finally { _reply.recycle(); _data.recycle(); } return _result; } @Override public void donateBook(com.honszeal.processdemo.Book book) throws android.os.RemoteException { android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try { _data.writeInterfaceToken(DESCRIPTOR); if ((book != null)) { _data.writeInt(1); book.writeToParcel(_data, 0); } else { _data.writeInt(0); } mRemote.transact(Stub.TRANSACTION_donateBook, _data, _reply, 0); _reply.readException(); } finally { _reply.recycle(); _data.recycle(); } } } static final int TRANSACTION_getNewBookList = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0); static final int TRANSACTION_donateBook = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1); } public java.util.List&lt;com.honszeal.processdemo.Book&gt; getNewBookList() throws android.os.RemoteException; public void donateBook(com.honszeal.processdemo.Book book) throws android.os.RemoteException;} BookService.java123456789101112131415161718192021222324public class BookService extends Service { private Binder binder = new ILibraryManager.Stub() { @Override public List&lt;Book&gt; getNewBookList() throws RemoteException { return null; } @Override public void donateBook(Book book) throws RemoteException { } }; @Override public void onCreate() { super.onCreate(); } @Override public IBinder onBind(Intent intent) { return binder; }} 手写IBookManager.java1234567891011121314151617package com.honszeal.processdemo;import android.os.IInterface;import android.os.RemoteException;import java.util.List;public interface IBookManager extends IInterface { String DESCRIPTOR = \"com.honszeal.processdemo.ILibraryManager\"; int TRANSACTION_getNewBookList = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0); int TRANSACTION_donateBook = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1); List&lt;Book&gt; getNewBookList() throws RemoteException; void donateBook(Book book) throws RemoteException;} BookManagerImpl123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package com.honszeal.processdemo;import android.os.Binder;import android.os.IBinder;import android.os.IInterface;import android.os.Parcel;import android.os.RemoteException;import java.util.List;public class BookManagerImpl extends Binder implements IBookManager { public BookManagerImpl() { this.attachInterface(this, DESCRIPTOR); } public static IBookManager asInterface(IBinder obj) { if (obj == null) { return null; } IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (iin != null &amp;&amp; iin instanceof IBookManager) { return ((IBookManager) iin); } return new BookManagerImpl.Proxy(obj); } @Override protected boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException { switch (code) { case INTERFACE_TRANSACTION: reply.writeString(DESCRIPTOR); return true; case TRANSACTION_getNewBookList: data.enforceInterface(DESCRIPTOR); List&lt;Book&gt; bookList = this.getNewBookList(); reply.writeNoException(); reply.writeTypedList(bookList); return true; case TRANSACTION_donateBook: data.enforceInterface(DESCRIPTOR); Book arg0; if (0 != data.readInt()) { arg0 = Book.CREATOR.createFromParcel(data); } else { arg0 = null; } this.donateBook(arg0); reply.writeNoException(); return true; } return super.onTransact(code, data, reply, flags); } @Override public List&lt;Book&gt; getNewBookList() throws RemoteException { return null; } @Override public void donateBook(Book book) throws RemoteException { } @Override public IBinder asBinder() { return this; } private static class Proxy implements IBookManager { private IBinder mRemote; public Proxy(IBinder mRemote) { this.mRemote = mRemote; } public String getInterfaceDescriptor() { return DESCRIPTOR; } @Override public List&lt;Book&gt; getNewBookList() throws RemoteException { Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); List&lt;Book&gt; result; data.writeInterfaceToken(getInterfaceDescriptor()); mRemote.transact(TRANSACTION_getNewBookList, data, reply, 0); reply.readException(); result = reply.createTypedArrayList(Book.CREATOR); return result; } @Override public void donateBook(Book book) throws RemoteException { // } @Override public IBinder asBinder() { return mRemote; } }} 感觉，就是具体的实现在服务端写，在客户端调用。实际上就是调用了 Proxy 的对应方法，然后 Binder 的 transact 方法 再就是 onTransact 方法。 权限验证 在 onBind 中进行验证，验证不通过就直接返回 null, 这样验证失败的客户端直接无法绑定服务。 在 onTransact 中进行验证，验证不通过就直接返回 false。","link":"/2018/03/30/AIDL/"},{"title":"Android 屏幕适配","text":"屏幕适配前言由于Android系统的开放性，任何用户、开发者、硬件厂商、运营商都可以对Android系统和硬件进行定制，修改成他们想要的样子。 那么这种“碎片化”到达什么程度呢？ 以上每一个矩形都代表一种机型，且它们屏幕尺寸、屏幕分辨率大相径庭。随着Android设备的增多，设备碎片化、系统碎片化、屏幕尺寸碎片化、屏幕碎片化的程度也在不断加深。 当 Android 系统、屏幕尺寸、屏幕密度出现碎片化的时候，就很容易出现同一元素在不同手机上显示不同的问题。试想一下这么一个场景： 为 4.3 寸屏幕准备的 UI 设计图，运行在 5.0 寸的屏幕上，很可能在右侧和下侧存在大量的空白；而 5.0 寸的 UI 设计图运行到 4.3 寸的设备上，很可能显示不下。 为了保证用户获得一致的用户体验效果,使得某一元素在 Android 不同尺寸、不同分辨率的、不同系统的手机上具备相同的显示效果，能够保持界面上的效果一致,我们需要对各种手机屏幕进行适配！ 基本概念像素（px）：单位：px（pixel），像素就是手机屏幕的最小构成单元 分辨率px（pixel），1px = 1像素点，手机在横向、纵向上的像素点数总和 一般描述成 宽高 ，即横向像素点个数 纵向像素点个数（如1080 x 1920）。 屏幕尺寸单位 英寸（inch），手机对角线的物理尺寸 屏幕像素密度单位：dpi，每英寸的像素点数。 例如每英寸内有 160 个像素点，则其像素密度为 160dpi。计算公式：像素密度 = 像素 / 尺寸 （dpi = px / in） 密度无关像素density-independent pixel，叫dp或dip，与终端上的实际物理像素点无关。单位：dp，可以保证在不同屏幕像素密度的设备上显示相同的效果，是安卓特有的长度单位。dp 与 px 的转换：1dp = （dpi / 160 ） * 1px 独立比例像素scale-independent pixel，叫sp或sip。单位：sp，字体大小专用单位 Android开发时用此单位设置文字大小。 DPI 的存在，不就是为了让大屏能显示更多的内容 适配方案今日头条参考项目地址：https://github.com/JessYanCoding/AndroidAutoSize 今日头条适配方案默认项目中只能以高或宽中的一个作为基准。 density 是 DisplayMetrics 中的成员变量，而 DisplayMetrics 实例通过 Resources#getDisplayMetrics 可以获得，而Resouces 通过 Activity 或者 Application 的 Context 获得。 如果每个 View 的 dp 值是固定不变的，那我们只要保证每个设备的屏幕总 dp 宽度不变，就能保证每个 View 在所有分辨率的屏幕上与屏幕的比例都保持不变，从而完成等比例适配，并且这个屏幕总 dp 宽度如果还能保证和设计图的宽度一致的话，那我们在布局时就可以直接按照设计图上的尺寸填写 dp 值 屏幕的总 px 宽度 / density = 屏幕的总 dp 宽度 在这个公式中我们要保证 屏幕的总 dp 宽度 和 设计图总宽度 一致，并且在所有分辨率的屏幕上都保持不变，我们需要怎么做呢？屏幕的总 px 宽度 每个设备都不一致，这个值是肯定会变化的，这时今日头条的公式就派上用场了 当前设备屏幕总宽度（单位为像素）/ 设计图总宽度（单位为 dp) = density 这个公式就是把上面公式中的 屏幕的总 dp 宽度 换成 设计图总宽度，原理都是一样的，只要 density 根据不同的设备进行实时计算并作出改变，就能保证 设计图总宽度 不变，也就完成了适配。 布局文件中 dp 的转换，最终都是调用 TypedValue#applyDimension(int unit, float value, DisplayMetrics metrics) 来进行转换: 1234567891011121314151617public static float applyDimension(int unit, float value, DisplayMetrics metrics){ switch (unit) { case COMPLEX_UNIT_PX: return value; case COMPLEX_UNIT_DIP: return value * metrics.density; case COMPLEX_UNIT_SP: return value * metrics.scaledDensity; case COMPLEX_UNIT_PT: return value * metrics.xdpi * (1.0f/72); case COMPLEX_UNIT_IN: return value * metrics.xdpi; case COMPLEX_UNIT_MM: return value * metrics.xdpi * (1.0f/25.4f); } return 0;} 这里用到的 DisplayMetrics 正是从 Resources 中获得的。图片的decode，也是通过 DisplayMetrics 中的值来计算的。 当然还有些其他 dp 转换的场景，基本都是通过 DisplayMetrics 来计算的，这里不再详述。因此，想要满足上述需求，我们只需要修改 DisplayMetrics 中和 dp 转换相关的变量即可。 适配后的 density = 设备真实宽(单位px) / 360，接下来只需要把我们计算好的 density 在系统中修改下即可，代码实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940private static float sNonCompatDensity;private static float sNonCompatScaledDensity;private static void setCustomDensity(@NonNull Activity activity, @NonNull final Application application) { // 设计图宽度 int customWidth = 360; final DisplayMetrics appDisplayMetrics = application.getResources().getDisplayMetrics(); if (sNonCompatDensity == 0) { sNonCompatDensity = appDisplayMetrics.density; sNonCompatScaledDensity = appDisplayMetrics.scaledDensity; // 监听系统字体变化 application.registerComponentCallbacks(new ComponentCallbacks() { @Override public void onConfigurationChanged(Configuration newConfig) { if (newConfig != null &amp;&amp; newConfig.fontScale &gt; 0) { sNonCompatScaledDensity = application.getResources().getDisplayMetrics().scaledDensity; } } @Override public void onLowMemory() { } }); } final float targetDensity = appDisplayMetrics.widthPixels / customWidth; final float targetScaledDensity = targetDensity * (sNonCompatScaledDensity / sNonCompatDensity); final int targetDensityDpi = (int) (160 * targetDensity); appDisplayMetrics.density = targetDensity; appDisplayMetrics.scaledDensity = targetScaledDensity; appDisplayMetrics.densityDpi = targetDensityDpi; DisplayMetrics activityDisplayMetrics = activity.getResources().getDisplayMetrics(); activityDisplayMetrics.density = targetDensity; activityDisplayMetrics.scaledDensity = targetScaledDensity; activityDisplayMetrics.densityDpi = targetDensityDpi;} 优点 使用成本非常低，操作非常简单，使用该方案后在页面布局时不需要额外的代码和操作，这点可以说完虐其他屏幕适配方案。 侵入性非常低，该方案和项目完全解耦，在项目布局时不会依赖哪怕一行该方案的代码，而且使用的还是 Android 官方的 API，意味着当你遇到什么问题无法解决，想切换为其他屏幕适配方案时，基本不需要更改之前的代码，整个切换过程几乎在瞬间完成，会少很多麻烦，节约很多时间，试错成本接近于 0。 可适配三方库的控件和系统的控件(不止是是 Activity 和 Fragment，Dialog、Toast 等所有系统控件都可以适配)，由于修改的 density 在整个项目中是全局的，所以只要一次修改，项目中的所有地方都会受益。 不会有任何性能的损耗 缺点会影响第三方控件 解决方案： 我们自身作出修改，去适应三方库的设计图尺寸，我们将项目自身的设计图尺寸修改为这个三方库的设计图尺寸，就能完成项目自身和三方库的适配 按 Activity 为单位，取消当前 Activity 的适配效果，改用其他的适配方案 SmallestWidth这个方案的的使用方式和我们平时在布局中引用 dimens 无异，核心点在于生成 dimens.xml 文件，但是已经有大神帮我们做了这 一步。 123456789├── src/main│ ├── res│ ├── ├──values│ ├── ├──values-800x480│ ├── ├──values-860x540│ ├── ├──values-1024x600│ ├── ├──values-1024x768│ ├── ├──...│ ├── ├──values-2560x1440 如果有人还记得上面这种 宽高限定符屏幕适配方案 的话，就可以把 smallestWidth 限定符屏幕适配方案 当成这种方案的升级版，smallestWidth 限定符屏幕适配方案 只是把 dimens.xml 文件中的值从 px 换成了 dp，原理和使用方式都是没变的，这些在上面的文章中都有介绍，下面就直接开始剖析原理，smallestWidth 限定符屏幕适配方案 长这样 1234567891011├── src/main│ ├── res│ ├── ├──values│ ├── ├──values-sw320dp│ ├── ├──values-sw360dp│ ├── ├──values-sw400dp│ ├── ├──values-sw411dp│ ├── ├──values-sw480dp│ ├── ├──...│ ├── ├──values-sw600dp│ ├── ├──values-sw640dp 其实 smallestWidth 限定符屏幕适配方案 的原理也很简单，开发者先在项目中根据主流屏幕的 最小宽度 (smallestWidth) 生成一系列 values-swdp 文件夹 (含有 dimens.xml 文件)，当把项目运行到设备上时，系统会根据当前设备屏幕的 最小宽度 (smallestWidth) 去匹配对应的 values-swdp 文件夹，而对应的 values-swdp 文件夹中的 dimens.xml 文字中的值，又是根据当前设备屏幕的 最小宽度 (smallestWidth) 而定制的，所以一定能适配当前设备。 如果系统根据当前设备屏幕的 最小宽度 (smallestWidth) 没找到对应的 values-swdp 文件夹，则会去寻找与之 最小宽度 (smallestWidth) 相近的 values-swdp 文件夹，系统只会寻找小于或等于当前设备 最小宽度 (smallestWidth) 的 values-swdp，这就是优于 宽高限定符屏幕适配方案 的容错率，并且也可以少生成很多 values-swdp 文件夹，减轻 App 的体积。 优点 非常稳定，极低概率出现意外 不会有任何性能的损耗 适配范围可自由控制，不会影响其他三方库 在插件的配合下，学习成本低 缺点 在布局中引用 dimens 的方式，虽然学习成本低，但是在日常维护修改时较麻烦 侵入性高，如果项目想切换为其他屏幕适配方案，因为每个 Layout 文件中都存在有大量 dimens 的引用，这时修改起来工作量非常巨大，切换成本非常高昂 无法覆盖全部机型，想覆盖更多机型的做法就是生成更多的资源文件，但这样会增加 App 体积，在没有覆盖的机型上还会出现一定的误差，所以有时需要在适配效果和占用空间上做一些抉择 如果想使用 sp，也需要生成一系列的 dimens，导致再次增加 App 的体积 不能自动支持横竖屏切换时的适配，如上文所说，如果想自动支持横竖屏切换时的适配，需要使用 values-wdp 或 屏幕方向限定符 再生成一套资源文件，这样又会再次增加 App 的体积 不能以高度为基准进行适配，考虑到这个方案的名字本身就叫 最小宽度限定符适配方案，所以在使用这个方案之前就应该要知道这个方案只能以宽度为基准进行适配，为什么现在的屏幕适配方案只能以高度或宽度其中的一个作为基准进行适配 AndroidAutoSize根据 今日头条屏幕适配方案 优化的屏幕适配框架。 其他方案UI适配框架例如 Android 屏幕适配方案，不过已经停止维护 宽高限定符适配123456789├── src/main│ ├── res│ ├── ├──values│ ├── ├──values-800x480│ ├── ├──values-860x540│ ├── ├──values-1024x600│ ├── ├──values-1024x768│ ├── ├──...│ ├── ├──values-2560x1440 Android 屏幕适配终结者Android 屏幕适配终结者 ，也是基于头条的原理，不过是操作 pt，所以不是改 DisplayMetrics#density，而是 DisplayMetrics#xdpi，由于适配不会失效 参考资料 Android 目前稳定高效的UI适配方案 骚年你的屏幕适配方式该升级了!-今日头条适配方案 骚年你的屏幕适配方式该升级了!-SmallestWidth 限定符适配方案 今日头条屏幕适配方案终极版 Android 屏幕适配方案 Android 屏幕适配终结者 Android 屏幕适配从未如斯简单(8月10日最终更新版)","link":"/2018/12/26/Android-屏幕适配/"},{"title":"Android 性能优化","text":"布局优化 删除布局中无用的控件和层级，其次有选择的使用性能较低的 ViewGroup，比如 RelativeLayout, ConstraintLayout 。同样层级的话更优先选择使用 LinearLayout，因为RelativeLayout 的布局过程需要花费更多的 CPU 时间。如果需要嵌套的方式来做，更建议采用 RelativeLayout ，因为 ViewGroup 的嵌套就相当于增加了布局的层级，同样会降低程序的性能。 采用 &lt;include&gt; 标签，如果多个布局中需要一个相同的 layout ，可以使用&lt;include&gt; 来避免写重复的布局文件。 采用 &lt;merge&gt; 标签。一般和 &lt;include&gt; 标签一起使用而减少布局的层级。 ViewStub。它非常轻量级，而且高/宽都是 0，因此它本身不参与任何的布局和绘制过程。ViewStub 的意义在于按需加载所需的布局文件，在实际开发中，有很多布局文件在正常情况下不会显示，这个时候就没有必要在整个界面初始化的时候将其加载进来，通过 ViewStub 就可以做到在使用的时候再加载。123456789101112131415&lt;ViewStub android:id=\"@+id/stub_import\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_gravity=\"center\" android:inflatedId=\"@+id/id_login\" android:layout=\"@layout/refresh_layout\" /&gt; 其中 stub_import 是 ViewStub 的 id，id_login 是 refresh_layout 这个布局根元素的 id, 需要加载 ViewStub 的布局时，有两种方式：((ViewStub)findViewById(R.id.stub_import)).setVisibility(View.VISIBLE);或者View layout = ((ViewStub)findViewById(R.id.stub_import)).inflate(); 绘制优化绘制优化是指 View 的 onDraw 方法要避免执行大量的操作。 onDraw 里不要创建新的局部对象 不要做耗时的操作。 内存泄露优化内存泄露优化分为两个方面，一方面是在开发过程中避免写出有内存泄漏的代码，另一方面是通过一些分析工具找出潜在的内存泄漏继而解决。 场景1 静态变量导致的内存泄漏下面的代码将导致 Activity 无法正常销毁，因为静态变量 sContext 引用了它。1234567891011121314public class MainActivity extends Activity{ private static final String TAG = \"MainActivity\"; private static Context sContext; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); sContext = this; }} 解决方案： 在 onDestroy 中释放 sContext = null。 变成虚引用 private static WeakReference&lt;Context&gt; context。 场景2 单例模式导致的内存泄漏如下所示，提供一个单例模式的 TestManager，TestManager可以接受外部的注册并将外部的监听器存储起来。 1234567891011121314151617181920212223242526272829public class TestManager{ private List&lt;OnDataArrivedListener&gt; mOnDataArrivedListeners = new ArrayList&lt;&gt;(); private static class SingletonHolder { public static final TestManager INSTANCE = new TestManager(); } private TestManager(){ } public static TestManager getInstance(){ return SingletonHolder.INSTANCE; } public synchronized void registerListener(OnDataArrivedListener listener){ if(!mOnDataArrivedListeners.contains(listener)){ mOnDataArrivedListeners.add(listener); } } public synchronized void unregisterListener(OnDataArrivedListener listener){ mOnDataArrivedListeners.remove(listener); } public interface OnDataArrivedListener{ void onDataArrived(Object data); }} 让 Activity 实现 OnDataArrivedListener 并向 TestManager 注册监听，如下所示。下面的代码由于缺少解注册的操作而引起内存泄漏，泄露的原因是 Activity 的对象被单例模式的 TestManager 所持有，而单例模式的特点是其生命周期和 Application 保持一致，因此 Activity 无法被及时释放。 1234567891011121314public class MainActivity extends Activity{ private static final String TAG = &quot;MainActivity&quot;; private static Context sContext; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); TestManager.getInstance().registerListener(this); }} 解决方案： 在 onDestroy 中 TestManager.getInstance().unregisterListener(this);。 场景3 属性动画导致的内存泄漏属性动画中有一类无限循环的动画，如果在 Activity 中播放此类动画并且没有在 onDestroy 中去停止动画，那么动画会一直播放下去，尽管已经无法在页面上看到动画效果了，并且这个时候 Activity 的 View 会被动画持有，而 View 又持有了 Activity，最终 Activity 无法释放。 解决方法 是在 onDestroy 中停止动画。 场景4 非静态内部类导致的内存泄漏比如 Handler123456789101112131415161718192021222324252627282930313233public class MainActivity extends AppCompatActivity { private MyHandler handler; private static class MyHandler extends Handler { private WeakReference&lt;MainActivity&gt; reference; public MyHandler(MainActivity activity) { reference = new WeakReference&lt;&gt;(activity); } @Override public void handleMessage(Message msg) { //TODO: do something reference.get().doSomeThing(); } } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); handler = new MyHandler(this); } @Override protected void onDestroy() { handler.removeMessages(1); super.onDestroy(); }} 响应速度优化和 ANR 日志分析响应速度优化的核心思想是避免在主线程中做耗时操作。响应速度过慢更多的体现在 Activity 的启动速度上，如果在主线程中做太多事情，会导致 Activity 启动时出现黑屏现象，甚至出现 ANR(Application not response)。Android 规定，Activity 如果 5s 内无法响应屏幕触摸事件或者键盘输入事件就会出现 ANR， BroadcastReceiver 如果 10s 之内还未执行完操作也会出现 ANR，Service 如果 20s 之内还未执行完操作也会出现 ANR。 当一个进程发生了 ANR 以后，系统会在data/anr 目录下创建一个 traces.txt，通过分析这个文件就能定位出 ANR 的原因。 ListView 优化 和 Bitmap 优化ListView 优化方式 布局复用 使用 ViewHolder，减小 findViewById 的使用，避免在 getView 中执行耗时操作 在列表快速滑动时不适合开启大量的异步任务的。 数据可以分页加载。 可以尝试开启硬件加速来使 ListView 的滑动更加流畅。 尽量让 ItemView 的 Layout 层次结构简单。 ItemView 元素避免半透明。 尽量能保证 Adapter 的 hasStableIds() 返回 true，这样在 notifyDataSetChanged() 的时候，如果 id 不变，ListView 将不会重新绘制这个 View，达到优化的目的。 每个 ItemView 不能太高，特别是不要超过屏幕的高度。 Bitmap 优化方式 加载合适尺寸的图片（二次采样，inSampleSize）。 线程优化线程优化的思想是使用线程池，避免程序中存在大量的 Thread。线程池可以重用内部的线程，从而避免了线程的创建和销毁所带来的性能开销，同时线程池还可以有效的控制线程池的最大并发数，避免大量的线程因互相抢占系统资源从而导致堵塞现象的发生。 一些性能优化建议 避免创建过多的对象。 不要过多使用枚举，枚举占用的内存空间要比整形大。（不过枚举要是能影响性能的话，就太差了） 常量请使用 static final 来修饰。 使用 Android 特有的数据结构，比如 SparseArray 和 Pair 等。 适当使用软引用和弱引用。 尽量采用静态内部类，这样可以避免潜在的由于内部类而导致的内存泄漏。","link":"/2018/03/30/Android-性能优化/"},{"title":"Android 百度地图仿饿了么地图定位","text":"今天遇到了一个需求，就是在用户选择地理位置的时候，现在地图上选择一个位置，然后再手动输入具体门牌号信息。和饿了么类似。 想法是 在屏幕中间放一个 ImageView 固定，然后拖动屏幕的话，只有地图在动。因为如果是用 Marker 来绘制的话，有可能会出现重影而且可能会卡。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178public class MapActivity extends BaseActivity implements View.OnClickListener { private MapView mapView; private BaiduMap baiduMap; public static final int LOADING = 997; public static final int FINISH = 998; private String address; private TextView tvAddress; private GeoCoder geoCoder; private TextView tvConfirm; public LocationClient locationClient = null; //是否首次定位 boolean isFirstLoc = true; private Handler handler = new Handler() { @Override public void handleMessage(Message msg) { switch (msg.what) { case LOADING: tvAddress.setText(\"正在获取位置\"); break; case FINISH: break; } } }; private LocationListener myLitenner = new BDLocationListener { @Override public void onReceiveLocation(BDLocation bdLocation) { //MAP VIEW 销毁后不在处理新接收的位置 if (mapView == null) return; MyLocationData locData = new MyLocationData.Builder() //此处设置开发者获取到的方向信息，顺时针0-360 .accuracy(bdLocation.getRadius()) .direction(100).latitude(bdLocation.getLatitude()) .longitude(bdLocation.getLongitude()).build(); baiduMap.setMyLocationData(locData); //设置定位数据 if (isFirstLoc) { isFirstLoc = false; LatLng ll = new LatLng(bdLocation.getLatitude(), bdLocation.getLongitude()); MapStatusUpdate mapStatusUpdate = MapStatusUpdateFactory.newLatLngZoom(ll, 16); //设置地图中心点以及缩放级别 baiduMap.animateMapStatus(mapStatusUpdate); } } }; private OnMapStatusChangeListener mapChangeListener = new BaiduMap.OnMapStatusChangeListener() { @Override public void onMapStatusChangeStart(MapStatus mapStatus) { handler.sendEmptyMessage(LOADING); } @Override public void onMapStatusChangeStart(MapStatus mapStatus, int i) { handler.sendEmptyMessage(LOADING); } @Override public void onMapStatusChange(MapStatus mapStatus) { } @Override public void onMapStatusChangeFinish(MapStatus mapStatus) { searchAddress(mapStatus.target); } }; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_map); initView(); } @Override protected void onResume() { mapView.onResume(); super.onResume(); } @Override protected void onPause() { mapView.onPause(); super.onPause(); } private void initView() { findViewById(R.id.btn_back).setOnClickListener(this); tvAddress = (TextView) findViewById(R.id.tv_address); tvAddress.setText(\"正在获取位置\"); tvConfirm = (TextView) findViewById(R.id.tv_confirm); tvConfirm.setOnClickListener(this); mapView = (MapView) findViewById(R.id.map_view); baiduMap = mapView.getMap(); baiduMap.setMapType(BaiduMap.MAP_TYPE_NORMAL); baiduMap.setMyLocationEnabled(true); //定位 locationClient = new LocationClient(getApplicationContext()); locationClient.registerLocationListener(myLitenner);//注册监听函数 LocationClientOption option = new LocationClientOption(); option.setOpenGps(true);//打开GPS option.setLocationMode(LocationClientOption.LocationMode.Hight_Accuracy);//设置定位模式 option.setCoorType(\"bd09ll\");//返回的定位结果是百度经纬度，默认值是gcj02 option.setScanSpan(5000);//设置发起定位请求的时间间隔为5000ms option.setIsNeedAddress(true);//返回的定位结果包含地址信息 option.setNeedDeviceDirect(true);// 返回的定位信息包含手机的机头方向 locationClient.setLocOption(option); baiduMap.setOnMapStatusChangeListener(mapChangeListener); locationClient.start(); } private OnGetGeoCoderResultListener geoCodeListener = new OnGetGeoCoderResultListener() { @Override public void onGetGeoCodeResult(GeoCodeResult geoCodeResult) { } @Override public void onGetReverseGeoCodeResult(ReverseGeoCodeResult reverseGeoCodeResult) { if (reverseGeoCodeResult != null) { tvAddress.setText(\"当前位置:\" + reverseGeoCodeResult.getAddress()); address = reverseGeoCodeResult.getAddress(); } else { tvAddress.setText(\"暂无地址\"); } } }; //根据 Laglng 来获取位置信息 private void searchAddress(LatLng latLng) { geoCoder = GeoCoder.newInstance(); geoCoder.setOnGetGeoCodeResultListener(geoCodeListener); ReverseGeoCodeOption codeOption = new ReverseGeoCodeOption(); codeOption.location(latLng); geoCoder.reverseGeoCode(codeOption); } @Override public void onClick(View v) { switch (v.getId()) { case R.id.btn_back: finish(); break; case R.id.tv_confirm: if (address != null) { Intent intent = new Intent(); intent.putExtra(\"address\", address); setResult(RESULT_OK, intent); } finish(); break; } } @Override protected void onDestroy() { locationClient.stop(); baiduMap.setMyLocationEnabled(false); mapView.onDestroy(); if (geoCoder != null) { geoCoder.destroy(); } super.onDestroy(); }} 布局文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"@color/white\" android:orientation=\"vertical\"&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"50dp\" android:background=\"@color/head_bg\" android:gravity=\"center_horizontal\" android:paddingLeft=\"10dp\" android:paddingRight=\"10dp\"&gt; &lt;!-- 返回 --&gt; &lt;LinearLayout android:id=\"@+id/btn_back\" android:layout_width=\"50dp\" android:layout_height=\"fill_parent\" android:gravity=\"center\"&gt; &lt;ImageView android:layout_width=\"20dp\" android:layout_height=\"20dp\" android:src=\"@drawable/back\" /&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"返回\" android:textColor=\"@color/white\" /&gt; &lt;/LinearLayout&gt; &lt;!-- 页面标题 --&gt; &lt;LinearLayout android:layout_width=\"wrap_content\" android:layout_height=\"fill_parent\" android:layout_gravity=\"center_vertical\" android:layout_weight=\"2.5\" android:gravity=\"center\" android:orientation=\"horizontal\"&gt; &lt;TextView android:id=\"@+id/textView2\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/map\" android:textColor=\"@color/white\" /&gt; &lt;/LinearLayout&gt; &lt;!-- 小工具 --&gt; &lt;LinearLayout android:layout_width=\"50dp\" android:layout_height=\"fill_parent\" android:gravity=\"center\"&gt; &lt;TextView android:id=\"@+id/tv_confirm\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:background=\"@drawable/border_white_jiaofeijilu\" android:paddingBottom=\"@dimen/dimen_3_dp\" android:paddingLeft=\"@dimen/dimen_5_dp\" android:paddingRight=\"@dimen/dimen_5_dp\" android:paddingTop=\"@dimen/dimen_3_dp\" android:text=\"确定\" android:textColor=\"@color/white\" android:textSize=\"12sp\" /&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; &lt;RelativeLayout android:layout_width=\"match_parent\" android:layout_height=\"0dp\" android:layout_weight=\"1\"&gt; &lt;com.baidu.mapapi.map.MapView android:id=\"@+id/map_view\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt; &lt;ImageView android:layout_width=\"@dimen/dimen_15_dp\" android:layout_height=\"@dimen/dimen_15_dp\" android:layout_centerInParent=\"true\" android:src=\"@drawable/location\" /&gt; &lt;/RelativeLayout&gt; &lt;TextView android:id=\"@+id/tv_address\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:background=\"@color/white\" android:maxLines=\"1\" android:padding=\"10dp\" android:textColor=\"@color/text_black\" /&gt;&lt;/LinearLayout&gt; 遇到的几个坑： 百度的 sdk 文档真是垃圾，能不能用点心，好好写行不行。 option.setCoorType(&quot;bd09ll&quot;) 类型一定要写对 是 l 不是 1。因为这个问题，导致定位一直不太准确。 开始想用 POI检索 来通过 Laglng 来获取到位置信息，但是不知道为什么一直获取不到，而且 POI检索 还需要参数 keyword 就是关键词。后来通过查阅发现使用 GeoCoder 和 ReverseGeoCodeOption 反向地理编码来获取位置信息。 因为百度地图需要注册时需要用到 SHA1 ，所以每次都要打签名包，然后我并不知道AS要怎么配置才能生成 debug 签名包，很尴尬，所以每次都要生成签名包然后拷到手机上，很麻烦。","link":"/2017/09/29/Android-百度地图仿饿了么地图定位/"},{"title":"Android流行ORM框架","text":"Android ORM框架Room1234def room_version = \"1.1.1\"implementation \"android.arch.persistence.room:runtime:$room_version\"annotationProcessor \"android.arch.persistence.room:compiler:$room_version\"implementation \"android.arch.persistence.room:rxjava2:$room_version\" 123456789101112131415161718192021222324252627282930313233343536373839@Entity(tableName = \"user\")public class User { @PrimaryKey private int id; @ColumnInfo(name = \"first_name\") private String firstName; @ColumnInfo(name = \"last_name\") private String lastName; @Ignore private String nickName; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getFirstName() { return firstName; } public void setFirstName(String firstName) { this.firstName = firstName; } public String getLastName() { return lastName; } public void setLastName(String lastName) { this.lastName = lastName; }} 123456789101112131415161718192021@Daopublic interface UserDao { @Query(\"select * from user\") List&lt;User&gt; getAll(); @Query(\"select * from user where id in (:ids)\") List&lt;User&gt; queryUserByIds(int[] ids); @Query(\"select * from user where first_name like :first and last_name like :last limit 1\") User findByName(String first, String last); @Insert(onConflict = REPLACE) void insertAll(User... users); @Delete void delete(User user); @Query(\"SELECT * from user where id = :id LIMIT 1\") public Flowable&lt;User&gt; loadUserById(int id);} 123456@Database(entities = {User.class}, version = 1)public abstract class AppDatabase extends RoomDatabase { public abstract UserDao userDao();} 1234567891011121314151617181920private fun testRoom() { val db = Room.databaseBuilder(applicationContext, AppDatabase::class.java, \"database-name\").build() var all = db.userDao().all val MIGRATION_1_2 = object : Migration(1, 2) { override fun migrate(database: SupportSQLiteDatabase) { database.execSQL(\"CREATE TABLE `Fruit` (`id` INTEGER, \" + \"`name` TEXT, PRIMARY KEY(`id`))\") } } val MIGRATION_2_3 = object : Migration(2, 3) { override fun migrate(database: SupportSQLiteDatabase) { database.execSQL(\"ALTER TABLE Book \" + \" ADD COLUMN pub_year INTEGER\") } } Room.databaseBuilder(applicationContext, AppDatabase::class.java, \"database-name\") .addMigrations(MIGRATION_1_2, MIGRATION_2_3).build() } GreenDaoRealm12345678910111213141516171819202122// productbuildscript { repositories { ... maven {url 'http://oss.jfrog.org/artifactory/oss-snapshot-local'} } dependencies { ... classpath \"io.realm:realm-gradle-plugin:5.8.0-SNAPSHOT\" }}allprojects { repositories { ... maven {url 'http://oss.jfrog.org/artifactory/oss-snapshot-local'} }}// moduleapply plugin: 'realm-android' 12345678910class BaseApplication : Application() { override fun onCreate() { super.onCreate() Realm.init(this); val config = RealmConfiguration.Builder().build() Realm.setDefaultConfiguration(config) }} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// 新建一个对象，并进行存储private fun testCreateRealm() { val realm = Realm.getDefaultInstance() realm.beginTransaction() val user = realm.createObject(User::class.java) user.firstName = \"lalla\" user.lastName = \"aaaa\" realm.commitTransaction()}// 复制一个对象到Realm数据库private fun copyToRealm() { val realm = Realm.getDefaultInstance() val user = User() user.firstName = \"lalla\" user.lastName = \"aaaa\" realm.beginTransaction() realm.copyToRealm(user) realm.commitTransaction()}// 使用事务块private fun testExecuteTransaction() { val realm = Realm.getDefaultInstance() val user = realm.createObject(User::class.java) user.firstName = \"lalla\" user.lastName = \"aaaa\" realm.executeTransaction { it.copyToRealm(user) }}private fun testDelete() { val realm = Realm.getDefaultInstance() val users = realm.where(User::class.java).findAll() realm.executeTransaction { val user = users[1] user?.deleteFromRealm() //删除第一个数据 users.deleteFirstFromRealm() //删除最后一个数据 users.deleteLastFromRealm() //删除位置为1的数据 users.deleteFromRealm(1) //删除所有数据 users.deleteAllFromRealm() }}private fun testUpdate() { val realm = Realm.getDefaultInstance() val user = realm.where(User::class.java).equalTo(\"id\", \"1\").findFirst() realm.beginTransaction() user?.firstName = \"1111\" realm.commitTransaction()}private fun testQuery() { val realm = Realm.getDefaultInstance() val users = realm.where(User::class.java).findAll() var average = users.average(\"age\") var max = users.max(\"age\") var sort = users.sort(\"age\") val user = realm.where(User::class.java).equalTo(\"id\", \"1\").findFirst() val user1 = realm.where(User::class.java).between(\"age\", 1, 10).findFirst() val user2 = realm.where(User::class.java).lessThan(\"id\", 1).findFirst() val user3 = realm.where(User::class.java).contains(\"id\", \"1\").findFirst()} DBFlow1234567891011121314151617181920212223242526272829303132// productallprojects { repositories { ... maven { url \"https://www.jitpack.io\" } }}// moduledependencies { // if Java use this. If using Kotlin do NOT use this. annotationProcessor \"com.github.Raizlabs.DBFlow:dbflow-processor:${dbflow_version}\" // Use if Kotlin user. kapt \"com.github.Raizlabs.DBFlow:dbflow-processor:${dbflow_version}\" implementation \"com.github.Raizlabs.DBFlow:dbflow-core:${dbflow_version}\" implementation \"com.github.Raizlabs.DBFlow:dbflow:${dbflow_version}\" // sql-cipher database encryption (optional) implementation \"com.github.Raizlabs.DBFlow:dbflow-sqlcipher:${dbflow_version}\" implementation \"net.zetetic:android-database-sqlcipher:${sqlcipher_version}@aar\" // kotlin extensions implementation \"com.github.Raizlabs.DBFlow:dbflow-kotlinextensions:${dbflow_version}\" // RXJava 2 support implementation \"com.github.Raizlabs.DBFlow:dbflow-rx2:${dbflow_version}\" // RXJava 2 Kotlin Extensions Support implementation \"com.github.Raizlabs.DBFlow:dbflow-rx2-kotlinextensions:${dbflow_version}\"} 12345678class BaseApplication : Application() { override fun onCreate() { super.onCreate() FlowManager.init(this) }} 123456789@Database(version = VERSION, name = NAME)public class DBFlowDataBase { //数据库名称 static final String NAME = \"RuomizDataBase\"; //数据库版本 static final int VERSION = 1;} 12345678910111213141516171819@Table(database = DBFlowDataBase.class)public class DBFlowModel extends BaseModel { @PrimaryKey(autoincrement = true) public int id; @Column public String name; @Column public int age; @Column public String address; @Column public String phone;} 编译之后 12345678910111213141516171819private fun testDBFlow() { val dbFlowModel = DBFlowModel() dbFlowModel.name = \"Ruomiz\" dbFlowModel.address = \"beijing\" dbFlowModel.age = 100 dbFlowModel.phone = \"13333333333\" dbFlowModel.save() dbFlowModel.update() dbFlowModel.delete() dbFlowModel.insert() //根据name 单个查询 val dbFlowModel1 = Select().from(DBFlowModel::class.java).where(DBFlowModel_Table.name.`is`(name)).querySingle() //单个查询 val dbFlowDataBase = Select().from(DBFlowDataBase::class.java).querySingle() //返回所有结果 val dbFlowDataBases = Select().from(DBFlowDataBase::class.java).queryList()} OrmLite下载地址：http://ormlite.com/releases/ 需要下载最新的 core.jar 和 android.jar 并添加依赖 123456789101112131415161718192021222324252627282930313233343536@DatabaseTable(tableName = \"user\")public class User { @DatabaseField(generatedId = true)//表示id为主键且自动生成 private int id; @DatabaseField(columnName = \"first_name\") private String firstName; @DatabaseField(columnName = \"last_name\") private String lastName; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getFirstName() { return firstName; } public void setFirstName(String firstName) { this.firstName = firstName; } public String getLastName() { return lastName; } public void setLastName(String lastName) { this.lastName = lastName; }} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class DatabaseHelper extends OrmLiteSqliteOpenHelper { private static final String TABLE_NAME = \"sqlite-test.db\"; /** * userDao ，每张表对于一个 */ private Dao&lt;User, Integer&gt; userDao; public DatabaseHelper(Context context, String databaseName, CursorFactory factory, int databaseVersion) { super(context, databaseName, factory, databaseVersion); } @Override public void onCreate(SQLiteDatabase sqLiteDatabase, ConnectionSource connectionSource) { try { TableUtils.createTable(connectionSource, User.class); } catch (SQLException e) { e.printStackTrace(); } } @Override public void onUpgrade(SQLiteDatabase sqLiteDatabase, ConnectionSource connectionSource, int oldVersion, int newVersion) { try { TableUtils.dropTable(connectionSource, User.class, true); onCreate(sqLiteDatabase, connectionSource); } catch (SQLException e) { e.printStackTrace(); } } public void insertUser(User user) throws SQLException { getUserDao().create(user); } public void deleteUserById(int id, User user) throws SQLException { getUserDao().deleteById(id); getUserDao().delete(user); } public void updateData() throws SQLException { UpdateBuilder&lt;User, Integer&gt; updateBuilder = getUserDao().updateBuilder(); updateBuilder.setWhere(updateBuilder.where().eq(\"name\", \"jack\").and().gt(\"age\", 19)); updateBuilder.updateColumnValue(\"name\", \"Jack\"); updateBuilder.updateColumnValue(\"phone\", \"1111765765\"); updateBuilder.update(); } public void query() throws SQLException { List&lt;User&gt; users = getUserDao().queryForAll(); User user = getUserDao().queryForId(3); List&lt;User&gt; jsckUser = getUserDao().queryForEq(\"name\", \"Jack\"); } /** * 获得userDao */ public Dao&lt;User, Integer&gt; getUserDao() throws SQLException { if (userDao == null) { userDao = getDao(User.class); } return userDao; } /** * 释放资源 */ @Override public void close() { super.close(); userDao = null; }} 分析及对比 Android目前流行三方数据库ORM分析及对比","link":"/2018/09/28/Android流行ORM框架/"},{"title":"Django表单","text":"Http请求GET 方法在 HelloWorld 项目下创建 search.py:12345678910111213from django.http import HttpResponsefrom django.shortcuts import render_to_responsedef search_form(request): return render_to_response('search_form.html')def search(request): request.encoding = 'utf-8' if 'q' in request.GET: message = '你搜索的内容为：' + request.GET['q'] else: message = '你提交了空表单' return HttpResponse(message) 在模板目录 templates 中添加 search_form.html 表单：12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"/search\" method=\"get\"&gt; &lt;input type=\"text\" name=\"q\"&gt; &lt;input type=\"submit\" value=\"搜索\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 并且修改 urls.py:123456789from django.conf.urls import urlfrom . import view,testdb,search urlpatterns = [ url(r'^hello$', view.hello), url(r'^testdb$', testdb.testdb), url(r'^search-form$', search.search_form), url(r'^search$', search.search),] 访问地址 http://127.0.0.1:8000/search-form 并搜索，结果如下所示: POST 方法在tmplate 创建 post.html：12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;POST测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"/search-post\" method=\"post\"&gt; {% csrf_token %} &lt;input type=\"text\" name=\"q\"&gt; &lt;input type=\"submit\" value=\"Submit\"&gt; &lt;/form&gt; &lt;p&gt;{{ rlt }}&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 在模板的末尾，我们增加一个 rlt 记号，为表格处理结果预留位置。表格后面还有一个{\\% csrf_token \\%}的标签。csrf 全称是 Cross Site Request Forgery。这是Django提供的防止伪装提交请求的功能。POST 方法提交的表格，必须有此标签。在HelloWorld目录下新建 search2.py 文件并使用 search_post 函数来处理 POST 请求：123456789from django.shortcuts import renderfrom django.views.decorators import csrf # 接收POST请求数据def search_post(request): ctx ={} if request.POST: ctx['rlt'] = request.POST['q'] return render(request, \"post.html\", ctx) 修改 urls.py ：12345678910from django.conf.urls import urlfrom . import view,testdb,search,search2 urlpatterns = [ url(r'^hello$', view.hello), url(r'^testdb$', testdb.testdb), url(r'^search-form$', search.search_form), url(r'^search$', search.search), url(r'^search-post$', search2.search_post),] Request 对象每个 view 函数的第一个参数是一个 HttpRequest 对象，就像下面这个 hello() 函数:1234from django.http import HttpResponsedef hello(request): return HttpResponse(\"Hello world\") HttpRequest对象包含当前请求URL的一些信息： 属性 描述 path 请求页面的全路径,不包括域名—例如, “/hello/“ method 请求中使用的HTTP方法的字符串表示。全大写表示。例如:1234567if request.method == 'GET': do_something()elif request.method == 'POST': do_something_else() GET 包含所有HTTP GET参数的类字典对象。参见QueryDict 文档 POST 包含所有HTTP POST参数的类字典对象。参见QueryDict 文档。服务器收到空的POST请求的情况也是有可能发生的。也就是说，表单form通过HTTP POST方法提交请求，但是表单中可以没有数据。因此，不能使用语句if request.POST来判断是否使用HTTP POST方法；应该使用if request.method == “POST” (参见本表的method属性)。注意: POST不包括file-upload信息。参见FILES属性。 REQUEST 为了方便，该属性是POST和GET属性的集合体，但是有特殊性，先查找POST属性，然后再查找GET属性。借鉴PHP’s $_REQUEST。例如，如果GET = {“name”: “john”} 和POST = {“age”: ‘34’},则 REQUEST[“name”] 的值是”john”, REQUEST[“age”]的值是”34”.强烈建议使用GET and POST,因为这两个属性更加显式化，写出的代码也更易理解。 COOKIES 包含所有cookies的标准Python字典对象。Keys和values都是字符串。 FILES 包含所有上传文件的类字典对象。FILES中的每个Key都是 &lt;input type=&quot;file&quot; name=&quot;&quot; /&gt;标签中name属性的值. FILES中的每个value 同时也是一个标准Python字典对象，包含下面三个Keys: filename: 上传文件名,用Python字符串表示 content-type: 上传文件的Content type content: 上传文件的原始内容注意：只有在请求方法是POST，并且请求页面中有enctype=”multipart/form-data”属性时FILES才拥有数据。否则，FILES 是一个空字典。 META 包含所有可用HTTP头部信息的字典。 例如: CONTENT_LENGTH CONTENT_TYPE QUERY_STRING: 未解析的原始查询字符串 REMOTE_ADDR: 客户端IP地址 REMOTE_HOST: 客户端主机名 SERVER_NAME: 服务器主机名 SERVER_PORT: 服务器端口META 中这些头加上前缀HTTP_最为Key, 例如: HTTP_ACCEPT_ENCODING HTTP_ACCEPT_LANGUAGE HTTP_HOST: 客户发送的HTTP主机头信息 HTTP_REFERER: referring页 HTTP_USER_AGENT: 客户端的user-agent字符串 HTTP_X_BENDER: X-Bender头信息 user 是一个django.contrib.auth.models.User 对象，代表当前登录的用户。如果访问用户当前没有登录，user将被初始化为django.contrib.auth.models.AnonymousUser的实例。你可以通过user的is_authenticated()方法来辨别用户是否登录：1234if request.user.is_authenticated(): # Do something for logged-in users.else: # Do something for anonymous users.只有激活Django中的AuthenticationMiddleware时该属性才可用 session 唯一可读写的属性，代表当前会话的字典对象。只有激活Django中的session支持时该属性才可用 raw_post_data 原始HTTP POST数据，未解析过。 高级处理时会有用处。 Request对象也有一些有用的方法： 方法 描述 __getitem__(key) 返回GET/POST的键值,先取POST,后取GET。如果键不存在抛出 KeyError。这是我们可以使用字典语法访问HttpRequest对象。例如,request[“foo”]等同于先request.POST[“foo”] 然后 request.GET[“foo”]的操作。 has_key() 检查request.GET or request.POST中是否包含参数指定的Key。 get_full_path() 返回包含查询字符串的请求路径。例如， “/music/bands/the_beatles/?print=true” is_secure() 如果请求是安全的，返回True，就是说，发出的是HTTPS请求。 QueryDict对象在HttpRequest对象中, GET和POST属性是django.http.QueryDict类的实例。QueryDict类似字典的自定义类，用来处理单键对应多值的情况。QueryDict实现所有标准的词典方法。还包括一些特有的方法： 方法 描述 __getitem__ 和标准字典的处理有一点不同，就是，如果Key对应多个Value，__getitem__()返回最后一个value。 __setitem__ 设置参数指定key的value列表(一个Python list)。注意：它只能在一个mutable QueryDict 对象上被调用(就是通过copy()产生的一个QueryDict对象的拷贝). get() 如果key对应多个value，get()返回最后一个value。 update() 参数可以是QueryDict，也可以是标准字典。和标准字典的update方法不同，该方法添加字典 items，而不是替换它们 items() 和标准字典的items()方法有一点不同,该方法使用单值逻辑的__getitem__(): values() 和标准字典的values()方法有一点不同,该方法使用单值逻辑的__getitem__(): QueryDict也有一些方法，如下表： 方法 描述 copy() 返回对象的拷贝，内部实现是用Python标准库的copy.deepcopy()。该拷贝是mutable(可更改的) — 就是说，可以更改该拷贝的值。 getlist(key) 返回和参数key对应的所有值，作为一个Python list返回。如果key不存在，则返回空list。 It’s guaranteed to return a list of some sort.. setlist(key,list_) 设置key的值为list_ (unlike __setitem__()). appendlist(key,item) 添加item到和key关联的内部list. setlistdefault(key,list) 和setdefault有一点不同，它接受list而不是单个value作为参数。 lists() 和items()有一点不同, 它会返回key的所有值，作为一个list urlencode() 返回一个以查询字符串格式进行格式化后的字符串(e.g., “a=2&amp;b=3&amp;b=5”).","link":"/2017/06/04/Django表单/"},{"title":"Handler源码解析","text":"因为 Android 只允许在主线程中更新 UI ，所以每个 Android 开发者都会使用到 Handler ，最近面试也一直在问这个问题。先说一下我自己的理解吧 每个 Activity 都会自动初始化一个 Looper 对象，这个 Looper 对象通过 loop() 方法，不断的遍历 MessageQueue，来查看消息队列里是否存在 Message，在代码里 在其他线程中可以通过 handler.sendMessage(message) 来把 Message 传到 MessageQueue 里，可以在 handler 重写的 handlerMessage(Message msg) 里获取到发送的 Message 来执行所要完成的动作。 从 Handler 的无参构造方法开始看1234567891011121314151617public Handler() { if (FIND_POTENTIAL_LEAKS) { final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) { Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" + klass.getCanonicalName()); } } mLooper = Looper.myLooper(); if (mLooper == null) { throw new RuntimeException( \"Can't create handler inside thread that has not called Looper.prepare()\"); } mQueue = mLooper.mQueue; mCallback = null;} 可以看到在第十行调用了 Looper.myLooper()方法来获取一个 Looper 对象，如果这个对象为空则抛出一个异常。看一下 myLooper() 方法123public static final Looper myLooper() { return (Looper)sThreadLocal.get();} 这个方法非常简单，就是从sThreadLocal对象中取出Looper。如果sThreadLocal中有Looper存在就返回Looper，如果没有Looper存在自然就返回空了。因此你可以想象得到是在哪里给sThreadLocal设置Looper了吧，当然是Looper.prepare()方法！我们来看下它的源码：123456public static final void prepare() { if (sThreadLocal.get() != null) { throw new RuntimeException(\"Only one Looper may be created per thread\"); } sThreadLocal.set(new Looper());} 可以看到，首先判断sThreadLocal中是否已经存在Looper了，如果还没有则创建一个新的Looper设置进去。这样也就完全解释了为什么我们要先调用Looper.prepare()方法，才能创建Handler对象。同时也可以看出每个线程中最多只会有一个Looper对象。 所以在非 UI 线程中创建 Handler 对象之前要先调用 Looper.prepare() 方法，否则会出现异常。而且在程序启动时，系统已经自动在主线程中调用了Looper.prepare() 方法。所以在主线程中我们可以直接新建 Handler 。 看完了如何创建Handler之后，接下来我们看一下如何发送消息，这个流程相信大家也已经非常熟悉了，new出一个Message对象，然后可以使用setData()方法或arg参数等方式为消息携带一些数据，再借助Handler将消息发送出去就可以了，示例代码如下：1234567891011new Thread(new Runnable() { @Override public void run() { Message message = new Message(); message.arg1 = 1; Bundle bundle = new Bundle(); bundle.putString(\"data\", \"data\"); message.setData(bundle); handler.sendMessage(message); }}).start(); 可是这里Handler到底是把Message发送到哪里去了呢？为什么之后又可以在Handler的handleMessage()方法中重新得到这条Message呢？看来又需要通过阅读源码才能解除我们心中的疑惑了，Handler中提供了很多个发送消息的方法，其中除了sendMessageAtFrontOfQueue()方法之外，其它的发送消息方法最终都会辗转调用到sendMessageAtTime()方法中，这个方法的源码如下所示：123456789101112131415public boolean sendMessageAtTime(Message msg, long uptimeMillis){ boolean sent = false; MessageQueue queue = mQueue; if (queue != null) { msg.target = this; sent = queue.enqueueMessage(msg, uptimeMillis); } else { RuntimeException e = new RuntimeException( this + \" sendMessageAtTime() called with no mQueue\"); Log.w(\"Looper\", e.getMessage(), e); } return sent;} sendMessageAtTime() 方法接收两个参数，其中 msg 参数就是我们发送的 Message 对象，而 uptimeMillis 参数则表示发送消息的时间，它的值等于自系统开机到当前时间的毫秒数再加上延迟时间，如果你调用的不是sendMessageDelayed()方法，延迟时间就为0，然后将这两个参数都传递到 MessageQueue 的 enqueueMessage() 方法中。这个 MessageQueue 又是什么东西呢？其实从名字上就可以看出了，它是一个消息队列，用于将所有收到的消息以队列的形式进行排列，并提供入队和出队的方法。这个类是在 Looper 的构造函数中创建的，因此一个 Looper 也就对应了一个 MessageQueue。 那么enqueueMessage()方法毫无疑问就是入队的方法了:12345678910111213141516171819202122232425262728293031323334final boolean enqueueMessage(Message msg, long when) { if (msg.when != 0) { throw new AndroidRuntimeException(msg + \" This message is already in use.\"); } if (msg.target == null &amp;&amp; !mQuitAllowed) { throw new RuntimeException(\"Main thread not allowed to quit\"); } synchronized (this) { if (mQuiting) { RuntimeException e = new RuntimeException(msg.target + \" sending message to a Handler on a dead thread\"); Log.w(\"MessageQueue\", e.getMessage(), e); return false; } else if (msg.target == null) { mQuiting = true; } msg.when = when; Message p = mMessages; if (p == null || when == 0 || when &lt; p.when) { msg.next = p; mMessages = msg; this.notify(); } else { Message prev = null; while (p != null &amp;&amp; p.when &lt;= when) { prev = p; p = p.next; } msg.next = prev.next; prev.next = msg; this.notify(); } } return true;} 首先你要知道，MessageQueue 并没有使用一个集合把所有的消息都保存起来，它只使用了一个 mMessages 对象表示当前待处理的消息。然后观察上面的代码的 16~31 行我们就可以看出，所谓的入队其实就是将所有的消息按时间来进行排序，这个时间当然就是我们刚才介绍的 uptimeMilli 参数。具体的操作方法就根据时间的顺序调用 msg.next，从而为每一个消息指定它的下一个消息是什么。当然如果你是通过sendMessageAtFrontOfQueue()方法来发送消息的，它也会调用enqueueMessage()来让消息入队，只不过时间为0，这时会把 mMessages 赋值为新入队的这条消息，然后将这条消息的 next 指定为刚才的 mMessages，这样也就完成了添加消息到队列头部的操作。现在入队操作我们就已经看明白了，那出队操作是在哪里进行的呢?这个就需要看一看Looper.loop()方法的源码了，如下所示：123456789101112131415161718192021public static final void loop() { Looper me = myLooper(); MessageQueue queue = me.mQueue; while (true) { Message msg = queue.next(); // might block if (msg != null) { if (msg.target == null) { return; } if (me.mLogging!= null) me.mLogging.println( \"&gt;&gt;&gt;&gt;&gt; Dispatching to \" + msg.target + \" \" + msg.callback + \": \" + msg.what ); msg.target.dispatchMessage(msg); if (me.mLogging!= null) me.mLogging.println( \"&lt;&lt;&lt;&lt;&lt; Finished to \" + msg.target + \" \" + msg.callback); msg.recycle(); } }} 可以看到，这个方法从第4行开始，进入了一个死循环，然后不断地调用的MessageQueue的next()方法，我想你已经猜到了，这个next()方法就是消息队列的出队方法。不过由于这个方法的代码稍微有点长，我就不贴出来了，它的简单逻辑就是如果当前MessageQueue中存在mMessages(即待处理消息)，就将这个消息出队，然后让下一条消息成为mMessages，否则就进入一个阻塞状态，一直等到有新的消息入队。继续看loop()方法的第14行，每当有一个消息出队，就将它传递到msg.target的dispatchMessage()方法中，那这里msg.target又是什么呢？其实就是Handler啦，你观察一下上面sendMessageAtTime()方法的第6行就可以看出来了。接下来当然就要看一看Handler中dispatchMessage()方法的源码了，如下所示：123456789101112public void dispatchMessage(Message msg) { if (msg.callback != null) { handleCallback(msg); } else { if (mCallback != null) { if (mCallback.handleMessage(msg)) { return; } } handleMessage(msg); }} 在第5行进行判断，如果mCallback不为空，则调用mCallback的handleMessage()方法，否则直接调用Handler的handleMessage()方法，并将消息对象作为参数传递过去。这样我相信大家就都明白了为什么handleMessage()方法中可以获取到之前发送的消息了吧！ 另外除了发送消息之外，我们还有以下几种方法可以在子线程中进行UI操作： Handler的post()方法 View的post()方法 Activity的runOnUiThread()方法 Handler中的post()方法，代码如下所示：1234public final boolean post(Runnable r){ return sendMessageDelayed(getPostMessage(r), 0);} 原来这里还是调用了sendMessageDelayed()方法去发送一条消息啊，并且还使用了getPostMessage()方法将 Runnable 对象转换成了一条消息，我们来看下这个方法的源码：12345private final Message getPostMessage(Runnable r) { Message m = Message.obtain(); m.callback = r; return m;} 在这个方法中将消息的 callback 字段的值指定为传入的 Runnable 对象。咦？这个 callback 字段看起来有些眼熟啊，喔！在 Handler 的dispatchMessage()方法中原来有做一个检查，如果 Message 的 callback 等于 null 才会去调用handleMessage()方法，否则就调用handleCallback()方法。那我们快来看下handleCallback()方法中的代码吧：123private final void handleCallback(Message message) { message.callback.run();} 再来看一下View中的post()方法，代码如下所示：12345678910public boolean post(Runnable action) { Handler handler; if (mAttachInfo != null) { handler = mAttachInfo.mHandler; } else { ViewRoot.getRunQueue().post(action); return true; } return handler.post(action);} 原来就是调用了Handler中的post()方法，我相信已经没有什么必要再做解释了。最后再来看一下Activity中的runOnUiThread()方法，代码如下所示：1234567public final void runOnUiThread(Runnable action) { if (Thread.currentThread() != mUiThread) { mHandler.post(action); } else { action.run(); }} 如果当前的线程不等于UI线程(主线程)，就去调用Handler的post()方法，否则就直接调用Runnable对象的run()方法。 参考文章：Android Handler、Message完全解析，带你从源码的角度彻底理解","link":"/2017/07/13/Handler源码解析/"},{"title":"Lottie 详解","text":"简介Lottie 是 Airbnb 开源的一个面向 iOS、Android、React Native 的动画库，能分析 Adobe After Effects 导出的动画，并且能让原生 App 像使用静态素材一样使用这些动画，完美实现动画效果。 现在使用各平台的 native 代码实现一套复杂的动画是一件很困难并且耗时的事，我们需要为不同尺寸的屏幕加载不同的素材资源，还需要写大量难维护的代码，而 Lottie 可以做到同一个动画文件在不同平台上实现相同的效果，极大减少开发时间，实现不同的动画，只需要设置不同的动画文件即可，极大减少开发和维护成本。 官方效果图： 使用Lottie 支持多平台，使用同一个 JSON 动画文件，可在不同平台实现相同的效果。其中，Android 通过 Airbnb 的开源项目 lottie-android 实现，最低支持 API 16。 引入依赖implementation 'com.airbnb.android:lottie:2.5.4' 添加 Adobe After Effects 导出的动画文件Lottie 默认读取 Assets 中的文件，我们需要把动画文件 react.json 保存在 app/src/main/assets 文件里。在 官网 可以免费下载动画文件。 123456789101112131415161718192021222324252627282930// react.json{ \"v\": \"4.6.0\", \"fr\": 29.9700012207031, \"ip\": 0, \"op\": 141.000005743048, \"w\": 800, \"h\": 800, \"ddd\": 0, \"assets\": [ ], \"layers\": [ { \"ddd\": 0, \"ind\": 0, \"ty\": 4, \"nm\": \"center_circle\", \"ks\": {...}, \"ao\": 0, \"shapes\": [...], \"ip\": 0, \"op\": 900.000036657751, \"st\": 0, \"bm\": 0, \"sr\": 1 }, {...}, {...}, {...} ]} 使用Lottie在布局文件中直接添加 Lottie 的 LottieAnimationView 控件，即可在界面显示 React logo 动画效果 1234567&lt;com.airbnb.lottie.LottieAnimationView android:id=\"@+id/animation_view\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" app:lottie_fileName=\"react.json\" app:lottie_loop=\"true\" app:lottie_autoPlay=\"true\" /&gt; 属性说明： app:lottie_fileName: assets 文件夹下对应的动画文件的文件名 app:lottie_loop: 是否循环播放动画 app:lottie_autoPlay: 是否自动播放动画 app:lottie_cacheStrategy: 设置缓存策略。默认为none，可选值有strong和weak app:lottie_colorFilter: 设置背景颜色 app:lottie_progress: 设置动画播放进度 app:lottie_imageAssetsFolder: 动画所需图片资源在assets中的绝对路径。如果没有图片资源，可以省略 代码使用: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051LottieAnimationView animationView = (LottieAnimationView) findViewById(R.id.animation_view);animationView.playAnimation(); //播放动画animationView.setAnimation(\"data1.json\", CacheStrategy.Strong); // 设置动画文件以及缓存策略PorterDuffColorFilter colorFilter = new PorterDuffColorFilter(ContextCompat.getColor(this,android.R.color.holo_blue_light), PorterDuff.Mode.ADD);animationView.addColorFilter(colorFilter); // 设置背景颜色animationView.loop(true); // 循环播放animationView.setProgress(0.5f); // 设置动画播放进度。需要注意值是float型。// 监听动画的状态animationView.addAnimatorListener(new Animator.AnimatorListener() { @Override public void onAnimationStart(Animator animation) { // 开始 } @Override public void onAnimationEnd(Animator animation) { // 结束 } @Override public void onAnimationCancel(Animator animation) { // 取消 } @Override public void onAnimationRepeat(Animator animation) { // 重复 }});// 动态监听动画演示过程，可以动态获取动画进度animationView.addAnimatorUpdateListener(new AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator animation) { }});animationView.pauseAnimation(); // 暂停动画animationView.isAnimating() // 是否正在播放动画animationView.resumeAnimation() // 恢复动画animationView.cancelAnimation() // 取消动画 使用小技巧加载SDCard动画文件12345678910StringBuilder stringBuilder = new StringBuilder();BufferedReader bufferedReader = new BufferedReader(new FileReader(new File(JSON_PATH + \"react.json\")));String content = null;while ((content = bufferedReader.readLine()) != null){ stringBuilder.append(content);}JSONObject jsonObject = new JSONObject(stringBuilder.toString());animationView.setAnimation(jsonObject);animationView.loop(true);animationView.playAnimation(); 加载SDCard图片123456789101112animationView.setImageAssetDelegate(new ImageAssetDelegate() { @Override public Bitmap fetchBitmap(LottieImageAsset asset) { try { FileInputStream fileInputStream = new FileInputStream(IMAGE_PATH + asset.getFileName()); return BitmapFactory.decodeStream(fileInputStream); ///把流转化为Bitmap图片 } catch (Exception e) { e.printStackTrace(); } return null; }}); 加载SDCard字体123456animationView.setFontAssetDelegate(new FontAssetDelegate(){ public Typeface fetchFont(String fontFamily) { Typeface customFont = Typeface.createFromFile(FONT_PATH + fontFamily); return customFont; }}); 缓存动画12345/** *Lottie内部有两个缓存map（强引用缓存，弱引用缓存），在动画文件加载完成后会根据设置的缓存策略缓存动画，方便下次使用。 */animationView.setAnimation(animation, LottieAnimationView.CacheStrategy.Strong); //强缓存animationView.setAnimation(animation, LottieAnimationView.CacheStrategy.Weak); //弱缓存 Lottie实现原理Lottie 的使用的资源是需要先通过 bodymovin( bodymovin 插件本身是用于网页上呈现各种AE效果的一个开源库) 将 Adobe After Effects (AE) 生成的aep动画工程文件转换为通用的json格式描述文件。Lottie则负责解析动画的数据，计算每个动画在某个时间点的状态，准确地绘制到屏幕上。 Lottie 对外通过控件 LottieAnimationView 暴露接口，控制动画。LottieAnimationView 继承自 ImageView，通过当前时间绘制 canvas 显示到界面上。这里有两个关键类：LottieComposition 负责解析json描述文件，把json内容转成Java数据对象；LottieDrawable负责绘制，把LottieComposition转成的数据对象绘制成drawable显示到View上。顺序如下： 探究更多原理解析内容请在 Lottie–让动画如此简单 查看。 性能内容来自 腾讯音乐技术团队 。 官方说明 如果没有 mask 和 mattes，那么性能和内存非常好，没有 bitmap 创建，大部分操作都是简单的 cavas 绘制。 如果存在 mattes，将会创建2～3个 bitmap。bitmap 在动画加载到 window 时被创建，被 window 删除时回收。所以不宜在 RecyclerView 中使用包涵 mattes 或者 mask 的动画，否则会引起 bitmap 抖动。除了内存抖动，mattes和mask中必要的 bitmap.eraseColor() 和 canvas.drawBitmap() 也会降低动画性能。对于简单的动画，在实际使用时性能不太明显。 如果在列表中使用动画，推荐使用缓存 LottieAnimationView.setAnimation(String, CacheStrategy) 。 属性动画和Lottie动画对比以下性能对比是以K歌内单个礼物动画效果 - 属性动画 lottie使用硬件加速 lottie未使用硬件加速 帧率 内存 cpu 总结Lottie使用简单，易于上手，非常值得尝试。 优势 开发效率高—代码实现简单，更换动画方便，易于调试和维护。 数据源多样性—可从assets,sdcard,网络加载动画资源，能做到不发版本，动态更新 跨平台—设计稿导出一份动画描述文件，android,ios,react native通用 劣势 性能不够好—某些动画特效，内存和性能不够好； 相对于属性动画，在展示大动画时，帧率较低 参考文章 Android开发之Lottie动画解析库 Lottie–让动画如此简单 Lottie 官网","link":"/2018/05/08/Lottie-详解/"},{"title":"妹子图爬虫第三弹","text":"前面两篇的教程教大家写了一个基础的爬虫程序，但是有问题啊，每次开始时都要重新下载，很难受。所以我们要解决这个问题，关键点在于要把我们爬过的页面记录下来，避免重复。在这里，原文作者使用 MongoDB (一个基于分布式文件存储的非关系型数据库) 来存储数据的，我也是不怎么明白什么是 非关系型数据库…不过这里有教程，大家可以看看。 首先是 MongoDB 的安装。例如把它安在 C 盘下 D:\\software\\MongoDB\\Server ，之后需要创建两个目录： D:\\software\\MongoDB\\mongod.log(文件) 存储日志 D:\\software\\MongoDB\\db 存储数据 然后以管理员身份打开命令行窗口，执行以下命令 &quot;D:\\software\\MongoDB\\Server\\3.4\\bin\\mongod.exe&quot; --config &quot;D:\\software\\MongoDB\\Server\\3.4\\mongod.cfg&quot; --install 如图安装成功 用命令 net start MongoDB 来启动服务。 对了，还需要安装 MongoDB 的 python 模块 pip install PyMongo 现在我们在上一篇博文完成的代码中导入模块： from pymongo import MongoClient 代码改造第一步，在类 mzitu 里添加一个函数：1234567def __init__(self): client = MongoClient() ##与MongDB建立连接（这是默认连接本地MongDB数据库） db = client['meinvxiezhenji'] ## 选择一个数据库 self.meizitu_collection = db['meizitu'] ##在meizixiezhenji这个数据库中，选择一个集合 self.title = '' ##用来保存页面主题 self.url = '' ##用来保存页面地址 self.img_urls = [] ##初始化一个 列表 用来保存图片地址 之后要改一下 all_url 函数：12345678910111213141516def all_url(self, url): html = down.get(url, 3) all_a = BeautifulSoup(html.text, 'lxml').find('div', class_='all').find_all('a') for a in all_a: title = a.get_text() self.title = title ##将主题保存到self.title中 print(u'开始保存：', title) path = str(title).replace(\"?\", '_') self.mkdir(path) os.chdir(\"D:\\mzitu\\\\\"+path) href = a['href'] self.url = href ##将页面地址保存到self.url中 if self.meizitu_collection.find_one({'主题页面': href}): ##判断这个主题是否已经在数据库中、不在就运行else下的内容，在则忽略。 print(u'这个页面已经爬取过了') else: self.html(href) 接着改 html 函数：12345678def html(self, href): html = down.get(href, 3) max_span = BeautifulSoup(html.text, 'lxml').find_all('span')[10].get_text() page_num = 0 ##这个当作计数器用 （用来判断图片是否下载完毕） for page in range(1, int(max_span) + 1): page_num = page_num + 1 ##每for循环一次就+1 （当page_num等于max_span的时候，就证明我们的在下载最后一张图片了） page_url = href + '/' + str(page) self.img(page_url, max_span, page_num) ##把上面我们我们需要的两个变量，传递给下一个函数。 改 img 函数…12345678910111213141516def img(self, page_url, max_span, page_num): ##添加上面传递的参数 img_html = down.get(page_url, 3) img_url = BeautifulSoup(img_html.text, 'lxml').find('div', class_='main-image').find('img')['src'] self.img_urls.append(img_url) ##每一次 for page in range(1, int(max_span) + 1)获取到的图片地址都会添加到 img_urls这个初始化的列表 if int(max_span) == page_num: ##我们传递下来的两个参数用上了 当max_span和Page_num相等时，就是最后一张图片了，最后一次下载图片并保存到数据库中。 self.save(img_url) post = { ##这是构造一个字典，里面有啥都是中文，很好理解吧！ '标题': self.title, '主题页面': self.url, '图片地址': self.img_urls, '获取时间': datetime.datetime.now() } self.meizitu_collection.save(post) ##将post中的内容写入数据库。 print(u'插入数据库成功') else: ##max_span 不等于 page_num执行这下面 self.save(img_url) 完整的代码在此12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182from bs4 import BeautifulSoupimport osfrom Download import down ##导入模块变了一下from pymongo import MongoClientimport datetimeclass mzitu(): def __init__(self): client = MongoClient() ##与MongDB建立连接（这是默认连接本地MongDB数据库） db = client['meinvxiezhenji'] ## 选择一个数据库 self.meizitu_collection = db['meizitu'] ##在meizixiezhenji这个数据库中，选择一个集合 self.title = '' ##用来保存页面主题 self.url = '' ##用来保存页面地址 self.img_urls = [] ##初始化一个 列表 用来保存图片地址 def all_url(self, url): html = down.get(url, 3) all_a = BeautifulSoup(html.text, 'lxml').find('div', class_='all').find_all('a') for a in all_a: title = a.get_text() self.title = title ##将主题保存到self.title中 print(u'开始保存：', title) path = str(title).replace(\"?\", '_') self.mkdir(path) os.chdir(\"D:\\mzitu\\\\\"+path) href = a['href'] self.url = href ##将页面地址保存到self.url中 if self.meizitu_collection.find_one({'主题页面': href}): ##判断这个主题是否已经在数据库中、不在就运行else下的内容，在则忽略。 print(u'这个页面已经爬取过了') else: self.html(href) def html(self, href): html = down.get(href, 3) max_span = BeautifulSoup(html.text, 'lxml').find_all('span')[10].get_text() page_num = 0 ##这个当作计数器用 （用来判断图片是否下载完毕） for page in range(1, int(max_span) + 1): page_num = page_num + 1 ##每for循环一次就+1 （当page_num等于max_span的时候，就证明我们的在下载最后一张图片了） page_url = href + '/' + str(page) self.img(page_url, max_span, page_num) ##把上面我们我们需要的两个变量，传递给下一个函数。 def img(self, page_url, max_span, page_num): ##添加上面传递的参数 img_html = down.get(page_url, 3) img_url = BeautifulSoup(img_html.text, 'lxml').find('div', class_='main-image').find('img')['src'] self.img_urls.append(img_url) ##每一次 for page in range(1, int(max_span) + 1)获取到的图片地址都会添加到 img_urls这个初始化的列表 if int(max_span) == page_num: ##我们传递下来的两个参数用上了 当max_span和Page_num相等时，就是最后一张图片了，最后一次下载图片并保存到数据库中。 self.save(img_url) post = { ##这是构造一个字典，里面有啥都是中文，很好理解吧！ '标题': self.title, '主题页面': self.url, '图片地址': self.img_urls, '获取时间': datetime.datetime.now() } self.meizitu_collection.save(post) ##将post中的内容写入数据库。 print(u'插入数据库成功') else: ##max_span 不等于 page_num执行这下面 self.save(img_url) def save(self, img_url): name = img_url[-9:-4] print(u'开始保存：', img_url) img = down.get(img_url, 3) f = open(name + '.jpg', 'ab') f.write(img.content) f.close() def mkdir(self, path): path = path.strip() isExists = os.path.exists(os.path.join(\"D:\\mzitu\", path)) if not isExists: print(u'建了一个名字叫做', path, u'的文件夹！') os.makedirs(os.path.join(\"D:\\mzitu\", path)) return True else: print(u'名字叫做', path, u'的文件夹已经存在了！') return FalseMzitu = mzitu() ##实例化Mzitu.all_url('http://www.mzitu.com/all') ##给函数all_url传入参数 你可以当作启动爬虫（就是入口）","link":"/2017/08/29/妹子图爬虫第三弹/"},{"title":"妹子图爬虫第四弹","text":"多线程多进程爬虫之前我们的程序都可以用，但是速度太慢了，因为我们只用了一个线程一个进程来进行爬虫，大部分时间都在等待，效率太低。所以接下来我们要加快我们的爬虫效率。 同上篇，我们用数据库的方式来解决线程以及进程间的通信问题。 要爬取的 url 总共有三种状态： OUTSTANDING(初始状态) PROCESSING(正在下载状态) COMPLETE(下载完成状态) 当一个所有初始的URL状态都为outstanding；当开始爬取的时候状态改为：processing；爬取完成状态改为：complete；失败的URL重置状态为：outstanding。为了能够处理URL进程被终止的情况、我们设置一个计时参数，当超过这个值时；我们则将状态重置为outstanding。下面是代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788from datetime import datetime, timedeltafrom pymongo import MongoClient, errorsclass MogoQueue(): OUTSTANDING = 1 ##初始状态 PROCESSING = 2 ##正在下载状态 COMPLETE = 3 ##下载完成状态 def __init__(self, db, collection, timeout=300):##初始mongodb连接 self.client = MongoClient() self.Client = self.client[db] self.db = self.Client[collection] self.timeout = timeout def __bool__(self): \"\"\" 这个函数，我的理解是如果下面的表达为真，则整个类为真 至于有什么用，后面我会注明的（如果我的理解有误，请指点出来谢谢，我也是Python新手） $ne的意思是不匹配 \"\"\" record = self.db.find_one( {'status': {'$ne': self.COMPLETE}} ) return True if record else False def push(self, url, title): ##这个函数用来添加新的URL进队列 try: self.db.insert({'_id': url, 'status': self.OUTSTANDING, '主题': title}) print(url, '插入队列成功') except errors.DuplicateKeyError as e: ##报错则代表已经存在于队列之中了 print(url, '已经存在于队列中了') pass def push_imgurl(self, title, url): try: self.db.insert({'_id': title, 'statue': self.OUTSTANDING, 'url': url}) print('图片地址插入成功') except errors.DuplicateKeyError as e: print('地址已经存在了') pass def pop(self): \"\"\" 这个函数会查询队列中的所有状态为OUTSTANDING的值， 更改状态，（query后面是查询）（update后面是更新） 并返回_id（就是我们的ＵＲＬ），MongDB好使吧，^_^ 如果没有OUTSTANDING的值则调用repair()函数重置所有超时的状态为OUTSTANDING， $set是设置的意思，和MySQL的set语法一个意思 \"\"\" record = self.db.find_and_modify( query={'status': self.OUTSTANDING}, update={'$set': {'status': self.PROCESSING, 'timestamp': datetime.now()}} ) if record: return record['_id'] else: self.repair() raise KeyError def pop_title(self, url): record = self.db.find_one({'_id': url}) return record['主题'] def peek(self): \"\"\"这个函数是取出状态为 OUTSTANDING的文档并返回_id(URL)\"\"\" record = self.db.find_one({'status': self.OUTSTANDING}) if record: return record['_id'] def complete(self, url): \"\"\"这个函数是更新已完成的URL完成\"\"\" self.db.update({'_id': url}, {'$set': {'status': self.COMPLETE}}) def repair(self): \"\"\"这个函数是重置状态$lt是比较\"\"\" record = self.db.find_and_modify( query={ 'timestamp': {'$lt': datetime.now() - timedelta(seconds=self.timeout)}, 'status': {'$ne': self.COMPLETE} }, update={'$set': {'status': self.OUTSTANDING}} ) if record: print('重置URL状态', record['_id']) def clear(self): \"\"\"这个函数只有第一次才调用、后续不要调用、因为这是删库啊！\"\"\" self.db.drop() 接下来就需要来爬取所有的链接地址来存进我们的数据库里了。 1234567891011121314151617181920from Download import requestfrom mongodb_queue import MogoQueuefrom bs4 import BeautifulSoupspider_queue = MogoQueue('meinvxiezhenji', 'crawl_queue')def start(url): response = request.get(url, 3) Soup = BeautifulSoup(response.text, 'lxml') all_a = Soup.find('div', class_='all').find_all('a') for a in all_a: title = a.get_text() url = a['href'] spider_queue.push(url, title) \"\"\"上面这个调用就是把URL写入MongoDB的队列了\"\"\"if __name__ == \"__main__\": start('http://www.mzitu.com/all')\"\"\"这一段儿就不解释了哦！超级简单的\"\"\" 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import osimport timeimport threadingimport multiprocessingfrom mongodb_queue import MogoQueuefrom Download import requestfrom bs4 import BeautifulSoupSLEEP_TIME = 1def mzitu_crawler(max_threads=10): crawl_queue = MogoQueue('meinvxiezhenji', 'crawl_queue') ##这个是我们获取URL的队列 ##img_queue = MogoQueue('meinvxiezhenji', 'img_queue') def pageurl_crawler(): while True: try: url = crawl_queue.pop() print(url) except KeyError: print('队列没有数据') break else: img_urls = [] req = request.get(url, 3).text title = crawl_queue.pop_title(url) mkdir(title) os.chdir('D:\\mzitu\\\\' + title) max_span = BeautifulSoup(req, 'lxml').find('div', class_='pagenavi').find_all('span')[-2].get_text() for page in range(1, int(max_span) + 1): page_url = url + '/' + str(page) img_url = BeautifulSoup(request.get(page_url, 3).text, 'lxml').find('div', class_='main-image').find('img')['src'] img_urls.append(img_url) save(img_url) crawl_queue.complete(url) ##设置为完成状态 ##img_queue.push_imgurl(title, img_urls) ##print('插入数据库成功') def save(img_url): name = img_url[-9:-4] print(u'开始保存：', img_url) img = request.get(img_url, 3) f = open(name + '.jpg', 'ab') f.write(img.content) f.close() def mkdir(path): path = path.strip() isExists = os.path.exists(os.path.join(\"D:\\mzitu\", path)) if not isExists: print(u'建了一个名字叫做', path, u'的文件夹！') os.makedirs(os.path.join(\"D:\\mzitu\", path)) return True else: print(u'名字叫做', path, u'的文件夹已经存在了！') return False threads = [] while threads or crawl_queue: \"\"\" 这儿crawl_queue用上了，就是我们__bool__函数的作用，为真则代表我们MongoDB队列里面还有数据 threads 或者 crawl_queue为真都代表我们还没下载完成，程序就会继续执行 \"\"\" for thread in threads: if not thread.is_alive(): ##is_alive是判断是否为空,不是空则在队列中删掉 threads.remove(thread) while len(threads) &lt; max_threads or crawl_queue.peek(): ##线程池中的线程少于max_threads 或者 crawl_qeue时 thread = threading.Thread(target=pageurl_crawler) ##创建线程 thread.setDaemon(True) ##设置守护线程 thread.start() ##启动线程 threads.append(thread) ##添加进线程队列 time.sleep(SLEEP_TIME)def process_crawler(): process = [] num_cpus = multiprocessing.cpu_count() print('将会启动进程数为：', num_cpus) for i in range(num_cpus): p = multiprocessing.Process(target=mzitu_crawler) ##创建进程 p.start() ##启动进程 process.append(p) ##添加进进程队列 for p in process: p.join() ##等待进程队列里面的进程结束if __name__ == \"__main__\": process_crawler()","link":"/2017/09/02/妹子图爬虫第四弹/"},{"title":"妹子图爬虫第一弹","text":"本教程是根据 小白爬虫第一弹之抓取妹子图 编写 杂首先上边卧槽哥写的这个爬虫教程看过好几遍了，自己也跟着写了两三次了。开始觉得 哈，这么厉害，python 爬虫原来这么简单，因垂丝汀。但是后来发现“自己跟着写过”这个过程，其实能记住的知识很少。加上最近自己一直很迷茫，不知道该往哪个方面发展，不知道该学什么，在 python 和 java 中纠结，在 爬虫 还是 服务器 中纠结。前两周还看了两周的 用Python和Pygame写游戏，慢慢学着发现，教程是基于 python2 的，而我的电脑安装的环境是 python3.5 的，很多教程上需要的包 和一些方法都不能用，而且教程已经是六年前的了，不能说已经被放弃了吧，还是有些过时，python 执行效率又不高，只能写一些小游戏。所以说还是从基础开始，往深里学，用心学习。 想起了之前看到的一张图 自己听过的不如读过的，读过的不如讨论过的，讨论过的不如教给其他人的。所以我决定以后要把自己学过的知识，自己写出来，写在博客里。这样自己也印象比较深刻，要是我写的博文能帮到其他人那就更好了。 基础环境首先，我承认，我看上面所说的那个教程的时候，完全是被要爬取的网站吸引了。毕竟xx是学习第一动力(/滑稽)。 下面先来看看完成这篇教程所需要的基础环境 Python。本教程是基于 python3 来写。windows用户可以安装 anaconda,这是一个Python的科学计算发行版本，作者打包好多好多的包。 Requests。网络请求包。 beautifulsoup。可以从 html 文件中提取数据，非常方便，不用再搞那些恶心的正则表达式了。 LXML。一个HTML解析包 用于辅助beautifulsoup解析网页。 安装这些模块的话可以通过命令行来安装1234567conda install requestsconda install beautifulsoup4conda install lxml或者pip install requestspip install beautifulsoup4pip install lxml 代码重点来了！！我们要爬的网站是 妹子图 , 开不开心，激不激动。 网站的 http://www.mzitu.com/all 页面有整个网站全部的数据，贼良心。我们就在这个页面开启我们的爬虫之旅。Just do it！ 1234567891011import requestsimport osfrom bs4 import BeautifulSoupheaders = {'User-Agent': \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1\"} ## 浏览器请求头all_url = 'http://www.mzitu.com/all'start_html = requests.get(all_url, headers=headers)##使用 requests 来获取 all_url 的内容，并且把 headers 作为请求头print(start_html.text) ##把爬取到的内容打印出来 !!!记住网页内容是 .text 执行上面的代码会在控制台输出 all_url 页面的 html 源码。 目前只是爬到了网页的 html 源文件，但是我们是要爬图的啊！！！我们要美女图啊！！！爬虫才刚开始，慢慢来。 在 chrome 中打开 http://www.mzitu.com/all，按下 F12 调出开发者调试工具。 如图： 点击调试窗口左上角的那个小箭头，这样浏览器会根据你鼠标选中的视图显示相应的 html 代码。 如图，所有的图片链接地址都在 &lt;li&gt;...&lt;/li&gt; 里 随便点开一个 &lt;li&gt; 标签 会发现图片页面的地址在&lt;a&gt;标签的href属性中、主题在&lt;a&gt;标签中。所以我们只要爬取所有&lt;li&gt;标签里的内容就能爬取我们想要的地址了。 但是页面里还有好多不符合要求的&lt;li&gt;标签，所以要筛选一下。通过观察发现，所有的文章主题地址都在 &lt;div class='all'&gt;...&lt;/div&gt; 标签里。就是 &lt;div class='all'&gt; 里的 &lt;a&gt; 1234567891011121314import requestsfrom bs4 import BeautifulSoupheaders = {'User-Agent': \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1\"} ## 浏览器请求头all_url = 'http://www.mzitu.com/all'start_html = requests.get(all_url, headers=headers)##使用 requests 来获取 all_url 的内容，并且把 headers 作为请求头all_soup = BeutifulSoup(start_html.text,'lxml') ##使用BeautifulSoup来解析我们获取到的网页（‘lxml’是指定的解析器 具体请参考官方文档哦）all_a = Soup.find('div', class_='all').find_all('a') ##意思是先查找 class为 all 的div标签，然后查找所有的&lt;a&gt;标签。for a in all_a: print(a) 运行结果如下： 然后就该提取我们想要的内容了 123456789101112131415import requestsfrom bs4 import BeautifulSoupheaders = {'User-Agent': \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1\"} ## 浏览器请求头all_url = 'http://www.mzitu.com/all'start_html = requests.get(all_url, headers=headers)##使用 requests 来获取 all_url 的内容，并且把 headers 作为请求头all_soup = BeutifulSoup(start_html.text,'lxml') ##使用BeautifulSoup来解析我们获取到的网页（‘lxml’是指定的解析器 具体请参考官方文档哦）all_a = Soup.find('div', class_='all').find_all('a') ##意思是先查找 class为 all 的div标签，然后查找所有的&lt;a&gt;标签。for a in all_a: title = a.get_text() href = a['href] 结果： 然后我们在随便打开一个上面打印出来的链接地址，会发现页面中只有一张图啊，点击 下一页 会发现 url 一直在变，就是在第一张图的 url 后跟 ‘/‘ + 数字，就代表第几张图。所以只需拿到最后一张图的页码，然后访问第一张图到最后一张图所有的url就可以爬到全部的图了。 观察发现页码栏都在&lt;div class='pagenavi'&gt; 标签下，而最后一页的页码是 标签中倒数第二个 &lt;span&gt; 中的内容，所以这一波操作来了 123456789101112131415161718192021import requestsfrom bs4 import BeautifulSoupheaders = {'User-Agent': \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1\"} ## 浏览器请求头all_url = 'http://www.mzitu.com/all'start_html = requests.get(all_url, headers=headers)##使用 requests 来获取 all_url 的内容，并且把 headers 作为请求头all_soup = BeutifulSoup(start_html.text,'lxml') ##使用BeautifulSoup来解析我们获取到的网页（‘lxml’是指定的解析器 具体请参考官方文档哦）all_a = Soup.find('div', class_='all').find_all('a') ##意思是先查找 class 为 all 的div标签，然后查找所有的&lt;a&gt;标签。for a in all_a: title = a.get_text() href = a['href] html = requests.get(href,headers=headers) html_soup = BeautifulSoup(html.text,'lxml) max_span = html_soup.find('div',class_='pagenavi').find_all('span')[-2].get_text()##[-2]代表倒数第二个 for page in range(1, int(max_span)+1): page_url = href + '/' + str(page) print(page_url) 这时我们就得到了每张图所在的链接地址，距离爬到我们心心念念的图片地址还有最后一步。发现我们需要的地址在 &lt;div class=”main-image”&gt; 中的 &lt;img&gt; 标签的 src 属性中。 继续操作一波 123456789101112131415161718192021222324import requestsfrom bs4 import BeautifulSoupheaders = {'User-Agent': \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1\"} ## 浏览器请求头all_url = 'http://www.mzitu.com/all'start_html = requests.get(all_url, headers=headers)##使用 requests 来获取 all_url 的内容，并且把 headers 作为请求头all_soup = BeutifulSoup(start_html.text,'lxml') ##使用BeautifulSoup来解析我们获取到的网页（‘lxml’是指定的解析器 具体请参考官方文档哦）all_a = Soup.find('div', class_='all').find_all('a') ##意思是先查找 class 为 all 的div标签，然后查找所有的&lt;a&gt;标签。for a in all_a: title = a.get_text() href = a['href] html = requests.get(href,headers=headers) html_soup = BeautifulSoup(html.text,'lxml) max_span = html_soup.find('div',class_='pagenavi').find_all('span')[-2].get_text()##[-2]代表倒数第二个 for page in range(1, int(max_span)+1): page_url = href + '/' + str(page) page_html = requests.get(page_url,headers=headers) page_soup = BeautifulSoup(page_html.text, 'lxml') img_url = page_soup.find('div', class_='main-image').find('img')['src'] print(img_url) hahahah，完美，这不就是我们想要的嘛。但是还要继续操作，我们只拿到了图片的 url ，还要把这些图片下载到本地才算“爬虫”啊。 1234567891011121314151617181920212223242526272829import requests ##导入requestsfrom bs4 import BeautifulSoup ##导入bs4中的BeautifulSoupimport osheaders = {'User-Agent':\"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1\"}##浏览器请求头（大部分网站没有这个请求头会报错、请务必加上哦）all_url = 'http://www.mzitu.com/all' ##开始的URL地址start_html = requests.get(all_url, headers=headers) ##使用requests中的get方法来获取all_url(就是：http://www.mzitu.com/all这个地址)的内容 headers为上面设置的请求头、请务必参考requests官方文档解释Soup = BeautifulSoup(start_html.text, 'lxml') ##使用BeautifulSoup来解析我们获取到的网页（‘lxml’是指定的解析器 具体请参考官方文档哦）all_a = Soup.find('div', class_='all').find_all('a') ##意思是先查找 class为 all 的div标签，然后查找所有的&lt;a&gt;标签。for a in all_a: title = a.get_text() #取出a标签的文本 path = str(title).strip() ##去掉空格 os.makedirs(os.path.join(\"D:\\mzitu\", path)) ##创建一个存放套图的文件夹 os.chdir(\"D:\\mzitu\\\\\"+path) ##切换到上面创建的文件夹 href = a['href'] #取出a标签的href 属性 html = requests.get(href, headers=headers) ##上面说过了 html_Soup = BeautifulSoup(html.text, 'lxml') ##上面说过了 max_span = html_Soup.find('div', class_='pagenavi').find_all('span')[-2].get_text() ##查找所有的&lt;span&gt;标签获取第十个的&lt;span&gt;标签中的文本也就是最后一个页面了。 for page in range(1, int(max_span)+1): ##不知道为什么这么用的小哥儿去看看基础教程吧 page_url = href + '/' + str(page) ##同上 img_html = requests.get(page_url, headers=headers) img_Soup = BeautifulSoup(img_html.text, 'lxml') img_url = img_Soup.find('div', class_='main-image').find('img')['src'] ##这三行上面都说过啦不解释了哦 name = img_url[-9:-4] ##取URL 倒数第四至第九位 做图片的名字 img = requests.get(img_url, headers=headers) f = open(name+'.jpg', 'ab')##写入多媒体文件必须要 b 这个参数！！必须要！！ f.write(img.content) ##多媒体文件要是用conctent哦！ f.close() 然后进行进一步的封装 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import requestsfrom bs4 import BeautifulSoupimport osclass mzitu(): def all_url(self, url): html = self.request(url)##调用request函数把套图地址传进去会返回给我们一个response all_a = BeautifulSoup(html.text, 'lxml').find('div', class_='all').find_all('a') for a in all_a: title = a.get_text() print(u'开始保存：', title) ##加点提示不然太枯燥了 path = str(title).replace(\"?\", '_') ##我注意到有个标题带有 ？ 这个符号Windows系统是不能创建文件夹的所以要替换掉 self.mkdir(path) ##调用mkdir函数创建文件夹！这儿path代表的是标题title哦！！！！！不要糊涂了哦！ href = a['href'] self.html(href) ##调用html函数把href参数传递过去！href是啥还记的吧？ 就是套图的地址哦！！不要迷糊了哦！ def html(self, href): ##这个函数是处理套图地址获得图片的页面地址 html = self.request(href) max_span = BeautifulSoup(html.text, 'lxml').find('div', class='pagenavi').find_all('span')[-2].get_text() for page in range(1, int(max_span) + 1): page_url = href + '/' + str(page) self.img(page_url) ##调用img函数 def img(self, page_url): ##这个函数处理图片页面地址获得图片的实际地址 img_html = self.request(page_url) img_url = BeautifulSoup(img_html.text, 'lxml').find('div', class_='main-image').find('img')['src'] self.save(img_url) def save(self, img_url): ##这个函数保存图片 name = img_url[-9:-4] img = self.request(img_url) f = open(name + '.jpg', 'ab') f.write(img.content) f.close() def mkdir(self, path): ##这个函数创建文件夹 path = path.strip() isExists = os.path.exists(os.path.join(\"D:\\mzitu\", path)) if not isExists: print(u'建了一个名字叫做', path, u'的文件夹！') os.makedirs(os.path.join(\"D:\\mzitu\", path)) os.chdir(os.path.join(\"D:\\mzitu\", path)) ##切换到目录 return True else: print(u'名字叫做', path, u'的文件夹已经存在了！') return False def request(self, url): ##这个函数获取网页的response 然后返回 headers = {'User-Agent': \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1\"} content = requests.get(url, headers=headers) return contentMzitu = mzitu() ##实例化Mzitu.all_url('http://www.mzitu.com/all') ##给函数all_url传入参数 你可以当作启动爬虫（就是入口） 大功告成！","link":"/2017/08/28/妹子图爬虫第一弹/"},{"title":"懒加载 fragment","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public abstract class BaseLazyFragment extends Fragment { protected View mRootView; protected Context mContext; protected boolean isVisible; private boolean isPrepared; private boolean isFirst = true; @Override public void onActivityCreated(@Nullable Bundle savedInstanceState) { super.onActivityCreated(savedInstanceState); isPrepared = true; initPrepare(); } @Override public void setUserVisibleHint(boolean isVisibleToUser) { super.setUserVisibleHint(isVisibleToUser); if (getUserVisibleHint()) { isVisible = true; lazyLoad(); } else { isVisible = false; onInvisible(); } } @Override public void onResume() { super.onResume(); if (getUserVisibleHint()) { setUserVisibleHint(true); } } @Override public void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); mContext = getActivity(); } @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { if (mRootView == null) { mRootView = initView(inflater, container, savedInstanceState); } return mRootView; } //--------------------------------method---------------------------// /** * 懒加载 */ protected void lazyLoad() { if (!isPrepared || !isVisible || !isFirst) { return; } initData(); isFirst = false; } //--------------------------abstract method------------------------// /** * 在onActivityCreated中调用的方法，可以用来进行初始化操作。 */ protected abstract void initPrepare(); /** * fragment被设置为不可见时调用 */ protected abstract void onInvisible(); /** * 这里获取数据，刷新界面 */ protected abstract void initData(); /** * 初始化布局，请不要把耗时操作放在这个方法里，这个方法用来提供一个 * 基本的布局而非一个完整的布局，以免ViewPager预加载消耗大量的资源。 */ protected abstract View initView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState);} 多层嵌套后的 Fragment 懒加载实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210import android.os.Bundle;import android.support.annotation.NonNull;import android.support.annotation.Nullable;import android.support.v4.app.Fragment;import android.support.v4.app.FragmentManager;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import java.util.List;/** * @author wangshijia * @date 2018/2/2 * Fragment 第一次可见状态应该在哪里通知用户 在 onResume 以后？ */public abstract class LazyLoadBaseFragment extends BaseLifeCircleFragment { protected View rootView = null; private boolean mIsFirstVisible = true; private boolean isViewCreated = false; private boolean currentVisibleState = false; @Override public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { super.onCreateView(inflater, container, savedInstanceState); if (rootView == null) { rootView = inflater.inflate(getLayoutRes(), container, false); } initView(rootView); return rootView; } @Override public void setUserVisibleHint(boolean isVisibleToUser) { super.setUserVisibleHint(isVisibleToUser); // 对于默认 tab 和 间隔 checked tab 需要等到 isViewCreated = true 后才可以通过此通知用户可见 // 这种情况下第一次可见不是在这里通知 因为 isViewCreated = false 成立,等从别的界面回到这里后会使用 onFragmentResume 通知可见 // 对于非默认 tab mIsFirstVisible = true 会一直保持到选择则这个 tab 的时候，因为在 onActivityCreated 会返回 false if (isViewCreated) { if (isVisibleToUser &amp;&amp; !currentVisibleState) { dispatchUserVisibleHint(true); } else if (!isVisibleToUser &amp;&amp; currentVisibleState) { dispatchUserVisibleHint(false); } } } @Override public void onActivityCreated(@Nullable Bundle savedInstanceState) { super.onActivityCreated(savedInstanceState); isViewCreated = true; // !isHidden() 默认为 true 在调用 hide show 的时候可以使用 if (!isHidden() &amp;&amp; getUserVisibleHint()) { dispatchUserVisibleHint(true); } } @Override public void onHiddenChanged(boolean hidden) { super.onHiddenChanged(hidden); LogUtils.e(getClass().getSimpleName() + \" onHiddenChanged dispatchChildVisibleState hidden \" + hidden); if (hidden) { dispatchUserVisibleHint(false); } else { dispatchUserVisibleHint(true); } } @Override public void onResume() { super.onResume(); if (!mIsFirstVisible) { if (!isHidden() &amp;&amp; !currentVisibleState &amp;&amp; getUserVisibleHint()) { dispatchUserVisibleHint(true); } } } @Override public void onPause() { super.onPause(); // 当前 Fragment 包含子 Fragment 的时候 dispatchUserVisibleHint 内部本身就会通知子 Fragment 不可见 // 子 fragment 走到这里的时候自身又会调用一遍 ？ if (currentVisibleState &amp;&amp; getUserVisibleHint()) { dispatchUserVisibleHint(false); } } /** * 统一处理 显示隐藏 * * @param visible */ private void dispatchUserVisibleHint(boolean visible) { //当前 Fragment 是 child 时候 作为缓存 Fragment 的子 fragment getUserVisibleHint = true //但当父 fragment 不可见所以 currentVisibleState = false 直接 return 掉 // 这里限制则可以限制多层嵌套的时候子 Fragment 的分发 if (visible &amp;&amp; isParentInvisible()) return; //此处是对子 Fragment 不可见的限制，因为 子 Fragment 先于父 Fragment回调本方法 currentVisibleState 置位 false // 当父 dispatchChildVisibleState 的时候第二次回调本方法 visible = false 所以此处 visible 将直接返回 if (currentVisibleState == visible) { return; } currentVisibleState = visible; if (visible) { if (mIsFirstVisible) { mIsFirstVisible = false; onFragmentFirstVisible(); } onFragmentResume(); dispatchChildVisibleState(true); } else { dispatchChildVisibleState(false); onFragmentPause(); } } /** * 用于分发可见时间的时候父获取 fragment 是否隐藏 * * @return true fragment 不可见， false 父 fragment 可见 */ private boolean isParentInvisible() { Fragment parentFragment = getParentFragment(); if (parentFragment instanceof LazyLoadBaseFragment ) { LazyLoadBaseFragment fragment = (LazyLoadBaseFragment) parentFragment; return !fragment.isSupportVisible(); }else { return false; } } private boolean isSupportVisible() { return currentVisibleState; } /** * 当前 Fragment 是 child 时候 作为缓存 Fragment 的子 fragment 的唯一或者嵌套 VP 的第一 fragment 时 getUserVisibleHint = true * 但是由于父 Fragment 还进入可见状态所以自身也是不可见的， 这个方法可以存在是因为庆幸的是 父 fragment 的生命周期回调总是先于子 Fragment * 所以在父 fragment 设置完成当前不可见状态后，需要通知子 Fragment 我不可见，你也不可见， * &lt;p&gt; * 因为 dispatchUserVisibleHint 中判断了 isParentInvisible 所以当 子 fragment 走到了 onActivityCreated 的时候直接 return 掉了 * &lt;p&gt; * 当真正的外部 Fragment 可见的时候，走 setVisibleHint (VP 中)或者 onActivityCreated (hide show) 的时候 * 从对应的生命周期入口调用 dispatchChildVisibleState 通知子 Fragment 可见状态 * * @param visible */ private void dispatchChildVisibleState(boolean visible) { FragmentManager childFragmentManager = getChildFragmentManager(); List&lt;Fragment&gt; fragments = childFragmentManager.getFragments(); if (!fragments.isEmpty()) { for (Fragment child : fragments) { if (child instanceof LazyLoadBaseFragment &amp;&amp; !child.isHidden() &amp;&amp; child.getUserVisibleHint()) { ((LazyLoadBaseFragment) child).dispatchUserVisibleHint(visible); } } } } public void onFragmentFirstVisible() { LogUtils.e(getClass().getSimpleName() + \" 对用户第一次可见\"); } public void onFragmentResume() { LogUtils.e(getClass().getSimpleName() + \" 对用户可见\"); } public void onFragmentPause() { LogUtils.e(getClass().getSimpleName() + \" 对用户不可见\"); } @Override public void onDestroyView() { super.onDestroyView(); isViewCreated = false; mIsFirstVisible = true; } /** * 返回布局 resId * * @return layoutId */ protected abstract int getLayoutRes(); /** * 初始化view * * @param rootView */ protected abstract void initView(View rootView);} 对于可见状态的生命周期调用顺序，父 Fragment总是优先于子 Fragment，而对于不可见事件，内部的 Fragment 生命周期总是先于外层 Fragment。","link":"/2018/09/26/懒加载-fragment/"},{"title":"妹子图爬虫第二弹","text":"上一篇文章中教大家去爬取妹子图，但是会出现很多问题，比如爬着爬着发现一直在报错，重新再来的话又得从第一张图开始下，太麻烦。通常是因为网站的反爬虫策略起了作用。 一般反爬虫策略有以下几种： 后台对访问进行统计，如果单个IP访问超过阈值，予以封锁。 后台对访问进行统计，如果单个session访问超过阈值，予以封锁。 后台对访问进行统计，如果单个userAgent访问超过阈值，予以封锁。 以上的组合。 针对上面的第一二条，来写个基本的下载模块。原理就是利用的不同的 User-Ahent 和 IP 来进行爬虫。 首先随便就可以在网上找到很多 User-Agent 。 123456789101112131415161718&quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1&quot;,&quot;Mozilla/5.0 (X11; CrOS i686 2268.111.0) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.57 Safari/536.11&quot;,&quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6&quot;,&quot;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1090.0 Safari/536.6&quot;,&quot;Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/19.77.34.5 Safari/537.1&quot;,&quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.9 Safari/536.5&quot;,&quot;Mozilla/5.0 (Windows NT 6.0) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.36 Safari/536.5&quot;,&quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3&quot;,&quot;Mozilla/5.0 (Windows NT 5.1) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3&quot;,&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_0) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3&quot;,&quot;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3&quot;,&quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3&quot;,&quot;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3&quot;,&quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3&quot;,&quot;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3&quot;,&quot;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.0 Safari/536.3&quot;,&quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.24 (KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24&quot;,&quot;Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/535.24 (KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24&quot; 新建个下载的类然后改下代码 1234567891011121314151617181920212223242526272829303132import requestsimport reimport randomclass download(object): def __init__(self): self.user_agent_list = [ \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1\", \"Mozilla/5.0 (X11; CrOS i686 2268.111.0) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.57 Safari/536.11\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6\", \"Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1090.0 Safari/536.6\", \"Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/19.77.34.5 Safari/537.1\", \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.9 Safari/536.5\", \"Mozilla/5.0 (Windows NT 6.0) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.36 Safari/536.5\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3\", \"Mozilla/5.0 (Windows NT 5.1) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_0) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3\", \"Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3\", \"Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3\", \"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3\", \"Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.0 Safari/536.3\", \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.24 (KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24\", \"Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/535.24 (KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24\" ] def get(self, url): UA = random.choice(self.user_agent_list) ##从self.user_agent_list中随机取出一个字符串（聪明的小哥儿一定发现了这是完整的User-Agent中：后面的一半段） headers = {'User-Agent': UA} ##构造成一个完整的User-Agent （UA代表的是上面随机取出来的字符串哦） response = requests.get(url, headers=headers) ##这样服务器就会以为我们是真的浏览器了 return response 下一步就是要找一些能用的 IP 了。网上有一些 IP 代理的网站，通常会发一些免费的代理 IP，比如 http://haoip.cc/tiqu.htm 。 下面的代码可以爬下来这些 IP。 12345678iplist = [] ##初始化一个list用来存放我们获取到的IPhtml = requests.get(\"http://haoip.cc/tiqu.htm\")##不解释咯iplistn = re.findall(r'r/&gt;(.*?)&lt;b', html.text, re.S) ##表示从html.text中获取所有r/&gt;&lt;b中的内容，re.S的意思是包括匹配包括换行符，findall返回的是个list哦！for ip in iplistn: i = re.sub('\\n', '', ip)##re.sub 是re模块替换的方法，这儿表示将\\n替换为空 iplist.append(i.strip()) ##添加到我们上面初始化的list里面, i.strip()的意思是去掉字符串的空格哦！！ print(i.strip())print(iplist) 然后一顿操作 Download.py1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import requestsimport reimport randomimport time class download(): def __init__(self): self.iplist = [] ##初始化一个list用来存放我们获取到的IP html = requests.get(\"http://haoip.cc/tiqu.htm\") ##不解释咯 iplistn = re.findall(r'r/&gt;(.*?)&lt;b', html.text, re.S) ##表示从html.text中获取所有r/&gt;&lt;b中的内容，re.S的意思是包括匹配包括换行符，findall返回的是个list哦！ for ip in iplistn: i = re.sub('\\n', '', ip) ##re.sub 是re模块替换的方法，这儿表示将\\n替换为空 self.iplist.append(i.strip()) ##添加到我们上面初始化的list里面 self.user_agent_list = [ \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1\", \"Mozilla/5.0 (X11; CrOS i686 2268.111.0) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.57 Safari/536.11\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6\", \"Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1090.0 Safari/536.6\", \"Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/19.77.34.5 Safari/537.1\", \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.9 Safari/536.5\", \"Mozilla/5.0 (Windows NT 6.0) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.36 Safari/536.5\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3\", \"Mozilla/5.0 (Windows NT 5.1) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_0) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3\", \"Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3\", \"Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3\", \"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3\", \"Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.0 Safari/536.3\", \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.24 (KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24\", \"Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/535.24 (KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24\" ] def get(self, url, timeout, proxy=None, num_retries=6): ##给函数一个默认参数proxy为空 UA = random.choice(self.user_agent_list) ##从self.user_agent_list中随机取出一个字符串 headers = {'User-Agent': UA} ##构造成一个完整的User-Agent （UA代表的是上面随机取出来的字符串哦） if proxy == None: ##当代理为空时，不使用代理获取response（别忘了response啥哦！之前说过了！！） try: return requests.get(url, headers=headers, timeout=timeout)##这样服务器就会以为我们是真的浏览器了 except:##如过上面的代码执行报错则执行下面的代码 if num_retries &gt; 0: ##num_retries是我们限定的重试次数 time.sleep(10) ##延迟十秒 print(u'获取网页出错，10S后将获取倒数第：', num_retries, u'次') return self.get(url, timeout, num_retries-1) ##调用自身 并将次数减1 else: print(u'开始使用代理') time.sleep(10) IP = ''.join(str(random.choice(self.iplist)).strip()) ##下面有解释哦 proxy = {'http': IP} return self.get(url, timeout, proxy,) ##代理不为空的时候 else: ##当代理不为空 try: IP = ''.join(str(random.choice(self.iplist)).strip()) ##将从self.iplist中获取的字符串处理成我们需要的格式（处理了些什么自己看哦，这是基础呢） proxy = {'http': IP} ##构造成一个代理 return requests.get(url, headers=headers, proxies=proxy, timeout=timeout) ##使用代理获取response except: if num_retries &gt; 0: time.sleep(10) IP = ''.join(str(random.choice(self.iplist)).strip()) proxy = {'http': IP} print(u'正在更换代理，10S后将重新获取倒数第', num_retries, u'次') print(u'当前代理是：', proxy) return self.get(url, timeout, proxy, num_retries - 1) else: print(u'代理也不好使了！取消代理') return self.get(url, 3) request = download() 再改下 mzitu.py 中的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from bs4 import BeautifulSoupimport osfrom Download import request ##导入模块变了一下from pymongo import MongoClientclass mzitu(): def all_url(self, url): html = request.get(url, 3) all_a = BeautifulSoup(html.text, 'lxml').find('div', class_='all').find_all('a') for a in all_a: title = a.get_text() print(u'开始保存：', title) path = str(title).replace(\"?\", '_') self.mkdir(path) os.chdir(\"D:\\mzitu\\\\\"+path) href = a['href'] self.html(href) def html(self, href): html = request.get(href, 3) max_span = BeautifulSoup(html.text, 'lxml').find_all('span')[10].get_text() for page in range(1, int(max_span) + 1): page_url = href + '/' + str(page) self.img(page_url) def img(self, page_url): img_html = request.get(page_url, 3) img_url = BeautifulSoup(img_html.text, 'lxml').find('div', class_='main-image').find('img')['src'] self.save(img_url) def save(self, img_url): name = img_url[-9:-4] print(u'开始保存：', img_url) img = request.get(img_url, 3) f = open(name + '.jpg', 'ab') f.write(img.content) f.close() def mkdir(self, path): path = path.strip() isExists = os.path.exists(os.path.join(\"D:\\mzitu\", path)) if not isExists: print(u'建了一个名字叫做', path, u'的文件夹！') os.makedirs(os.path.join(\"D:\\mzitu\", path)) return True else: print(u'名字叫做', path, u'的文件夹已经存在了！') return FalseMzitu = mzitu() ##实例化Mzitu.all_url('http://www.mzitu.com/all') ##给函数all_url传入参数 你可以当作启动爬虫（就是入口） 注意：两个 py 文件要放在一个文件夹下，文件夹中还要新建一个叫 init.py 的空文件","link":"/2017/08/28/妹子图爬虫第二弹/"},{"title":"数据结构基础","text":"本文将介绍常用的数据结构。慢慢完善。 栈先进后出 队列先进先出 二叉树树形结构，每个节点最多只能有两个子分支 遍历等等 图 由顶点的有穷非空集合和顶点之间的边的集合组成 图中和边有关的数叫做权，带权的图称作 网 无向图中，与顶点 V 相关联的边的数目称作 V 的 度 有向图中，以顶点 V 为起点的弧的数目叫做 V 的 入度；以顶点 V 为终点的弧的数目叫做 V 的 出度 存储结构邻接矩阵图的邻接矩阵存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组（邻接矩阵）存储图中的边或弧的信息。 设图G有n个顶点，则邻接矩阵是一个n*n的方阵，定义为： 看一个实例，下图左就是一个无向图。 从上面可以看出，无向图的边数组是一个对称矩阵。所谓对称矩阵就是n阶矩阵的元满足aij = aji。即从矩阵的左上角到右下角的主对角线为轴，右上角的元和左下角相对应的元全都是相等的。 从这个矩阵中，很容易知道图中的信息。 （1）要判断任意两顶点是否有边无边就很容易了； （2）要知道某个顶点的度，其实就是这个顶点vi在邻接矩阵中第i行或（第i列）的元素之和； （3）求顶点vi的所有邻接点就是将矩阵中第i行元素扫描一遍，arc[i][j]为1就是邻接点； 而有向图讲究入度和出度，顶点vi的入度为1，正好是第i列各数之和。顶点vi的出度为2，即第i行的各数之和。 若图G是网图，有n个顶点，则邻接矩阵是一个n*n的方阵，定义为 这里的wij表示 (vi,vj) 上的权值。无穷大表示一个计算机允许的、大于所有边上权值的值，也就是一个不可能的极限值。下面左图就是一个有向网图，右图就是它的邻接矩阵。 邻接表邻接矩阵是不错的一种图存储结构，但是，对于边数相对顶点较少的图，这种结构存在对存储空间的极大浪费。因此，找到一种数组与链表相结合的存储方法称为邻接表。 邻接表的处理方法是这样的：（1）图中顶点用一个一维数组存储，当然，顶点也可以用单链表来存储，不过，数组可以较容易的读取顶点的信息，更加方便。（2）图中每个顶点vi的所有邻接点构成一个线性表，由于邻接点的个数不定，所以，用单链表存储，无向图称为顶点vi的边表，有向图则称为顶点vi作为弧尾的出边表。例如，下图就是一个无向图的邻接表的结构。 从图中可以看出，顶点表的各个结点由data和firstedge两个域表示，data是数据域，存储顶点的信息，firstedge是指针域，指向边表的第一个结点，即此顶点的第一个邻接点。边表结点由adjvex和next两个域组成。adjvex是邻接点域，存储某顶点的邻接点在顶点表中的下标，next则存储指向边表中下一个结点的指针。 对于带权值的网图，可以在边表结点定义中再增加一个weight的数据域，存储权值信息即可。如下图所示。 十字链表对于有向图来说，邻接表是有缺陷的。关心了出度问题，想了解入度就必须要遍历整个图才知道，反之，逆邻接表解决了入度却不了解出度情况。下面介绍的这种有向图的存储方法：十字链表，就是把邻接表和逆邻接表结合起来的。 重新定义顶点表结点结构，如下所示。 其中firstin表示入边表头指针，指向该顶点的入边表中第一个结点，firstout表示出边表头指针，指向该顶点的出边表中的第一个结点。 重新定义边表结构，如下所示。 其中，tailvex是指弧起点在顶点表的下表，headvex是指弧终点在顶点表的下标，headlink是指入边表指针域，指向终点相同的下一条边，taillink是指边表指针域，指向起点相同的下一条边。如果是网，还可以增加一个weight域来存储权值。 比如下图，顶点依然是存入一个一维数组，实线箭头指针的图示完全与邻接表相同。就以顶点v0来说，firstout指向的是出边表中的第一个结点v3。所以，v0边表结点hearvex = 3，而tailvex其实就是当前顶点v0的下标0，由于v0只有一个出边顶点，所有headlink和taillink都是空的。 重点需要解释虚线箭头的含义。它其实就是此图的逆邻接表的表示。对于v0来说，它有两个顶点v1和v2的入边。因此的firstin指向顶点v1的边表结点中headvex为0的结点，如上图圆圈1。接着由入边结点的headlink指向下一个入边顶点v2，如上图圆圈2。对于顶点v1，它有一个入边顶点v2，所以它的firstin指向顶点v2的边表结点中headvex为1的结点，如上图圆圈3。 十字链表的好处就是因为把邻接表和逆邻接表整合在一起，这样既容易找到以v为尾的弧，也容易找到以v为头的弧，因而比较容易求得顶点的出度和入度。 而且除了结构复杂一点外，其实创建图算法的时间复杂度是和邻接表相同的，因此，在有向图应用中，十字链表是非常好的数据结构模型。 这里就介绍以上三种存储结构，除了第三种存储结构外，其他的两种存储结构比较简单。 遍历图的遍历和树的遍历类似，希望从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次，这一过程就叫图的遍历。 深度优先遍历深度优先遍历也叫深度优先搜索(Depth First Search)。它的遍历规则：不断地沿着顶点的深度方向遍历。顶点的深度方向是指它的邻接点方向。 具体点，给定一图G=&lt;V,E&gt;，用visited[i]表示顶点i的访问情况，则初始情况下所有的visited[i]都为false。假设从顶点V0开始遍历，则下一个遍历的顶点是V0的第一个邻接点Vi，接着遍历Vi的第一个邻接点Vj，……直到所有的顶点都被访问过。 所谓的第一个是指在某种存储结构中(邻接矩阵、邻接表)，所有邻接点中存储位置最近的，通常指的是下标最小的。在遍历的过程中有两种情况经常出现 某个顶点的邻接点都已被访问过的情况，此时需回溯已访问过的顶点。 图不连通，所有的已访问过的顶点都已回溯完了，仍找不出未被访问的顶点。此时需从下标0开始检测visited[i]，找到未被访问的顶点i，从i开始新一轮的深度搜索。 看一个例子 从V0开始遍历 遍历分析：V0有两个邻接点V1和V2，选择下标最小的V1遍历。接着从V1开始深度遍历，V1只有邻接点V3，也就是没有选的：遍历V3。接着从V3开始遍历，V3只有邻接点V0，而V0已经被遍历过。此时出现了上面提到的情况一，开始回溯V1，V1无未被遍历的邻接点，接着回溯V0，V0有一个未被遍历的邻接点V2，新的一轮深度遍历从V2开始。V2无邻接点，且无法回溯。此时出现了情况二，检测visited[i]，只有V4了。深度遍历完成。看到回溯，应该可以想到需要使用栈。 遍历序列是V0-&gt;V1-&gt;V3-&gt;V2-&gt;V4。 广度优先遍历广度优先遍历也叫广度优先搜索(Breadth First Search)。它的遍历规则： 先访问完当前顶点的所有邻接点。(应该看得出广度的意思) 先访问顶点的邻接点先于后访问顶点的邻接点被访问。 具体点，给定一图G=&lt;V,E&gt;，用visited[i]表示顶点i的访问情况，则初始情况下所有的visited[i]都为false。假设从顶点V0开始遍历，且顶点V0的邻接点下表从小到大有Vi、Vj…Vk。按规则1，接着应遍历Vi、Vj和Vk。再按规则2，接下来应遍历Vi的所有邻接点，之后是Vj的所有邻接点，…，最后是Vk的所有邻接点。接下来就是递归的过程… 在广度遍历的过程中，会出现图不连通的情况，此时也需按上述情况二来进行：测试visited[i]…。在上述过程中，可以看出需要用到队列。 举个例子，还是同样一幅图： 从V0开始遍历 遍历分析：V0有两个邻接点V1和V2，于是按序遍历V1、V2。V1先于V2被访问，于是V1的邻接点应先于V2的邻接点被访问，那就是接着访问V3。V2无邻接点，只能看V3的邻接点了，而V0已被访问过了。此时需检测visited[i]，只有V4了。广度遍历完毕。 遍历序列是V0-&gt;V1-&gt;V2-&gt;V3-&gt;V4。 参考文章：数据结构之图（存储结构、遍历）","link":"/2017/07/18/数据结构基础/"},{"title":"Scrapy Spiders","text":"SpidersSpider 类定义了如何爬取某个(或某些)网站。包括了爬取的动作(例如:是否跟进链接)以及如何从网页的内容中提取结构化数据(爬取item)。 换句话说，Spider 就是您定义爬取的动作及分析某个网页(或者是有些网页)的地方。 对spider来说，爬取的循环类似下文: 以初始的 URL 初始化 Request，并设置回调函数。当该 response 下载完毕并返回时，将生成 response ，并作为参数传给该回调函数。spider 中初始的 request 是通过调用 start_requests() 来获取的。 start_requests() 读取 start_urls 中的 URL， 并以 parse 为回调函数生成 Request 。 在回调函数内分析返回的（网页）内容，返回 Item 对象、 dict 、Request 或者一个包含三者的可迭代容器。返回的 Request 对象之后会经过 Scrapy 处理，下载相应的内容，并调用设置的回调函数进行下一步的操作。 在回调函数内，您可以使用 选择器(Selectors) (您也可以使用 BeautifulSoup, lxml 或者您想用的任何解析器) 来分析网页内容，并根据分析的数据生成 item。 最后，由 spider 返回的 item 将被存到数据库(由某些 Item Pipeline 处理)或使用 Feed exports 存入到文件中。 该循环对任何类型的spider都(多少)适用。 scrapy.SpiderSpider 是最简单的 spider。每个其他的 spider 必须继承自该类(包括 Scrapy 自带的其他 spider 以及您自己编写的 spider )。 Spider 并没有提供什么特殊的功能。 其仅仅提供了 start_requests() 的默认实现，读取并请求 spider 属性中的 start_urls, 并根据返回的结果(resulting responses)调用 spider 的 parse 方法。 name 定义 spider 名字的字符串(string)。spider 的名字定义了 Scrapy 如何定位(并初始化) spider，所以其必须是唯一的。 不过您可以生成多个相同的 spider 实例(instance)，这没有任何限制。 name 是 spider 最重要的属性，而且是必须的。 如果该 spider 爬取单个网站(single domain)，一个常见的做法是以该网站(domain)(加或不加后缀)来命名 spider。 例如，如果 spider 爬取 mywebsite.com ，该 spider 通常会被命名为 mywebsite 。 allowed_domains 可选。包含了 spider 允许爬取的域名(domain)列表(list)。 当 OffsiteMiddleware 启用时， 域名不在列表中的URL不会被跟进。 start_urls URL 列表。当没有制定特定的 URL 时，spider 将从该列表中开始进行爬取。 因此，第一个被获取到的页面的 URL 将是该列表之一。 后续的URL将会从获取到的数据中提取。就是爬虫的入口网址。 custom_settings 该设置是一个 dict .当启动 spider 时,该设置将会覆盖项目级的设置. 由于设置必须在初始化(instantiation)前被更新,所以该属性 必须定义为 class 属性. crawler 该属性在初始化 class 后,由类方法 from_crawler() 设置, 并且链接了本 spider 实例对应的 Crawler 对象. Crawler 包含了很多项目中的组件, 作为单一的入口点 (例如插件,中间件,信号管理器等). start_requests() 该方法必须返回一个可迭代对象(iterable)。该对象包含了 spider 用于爬取的第一个 Request。 当 spider 启动爬取并且未指定 URL 时，该方法被调用。 当指定了 URL 时，make_requests_from_url() 将被调用来创建 Request 对象。 该方法仅仅会被 Scrapy 调用一次，因此您可以将其实现为生成器。 该方法的默认实现是使用 start_urls 中的 url 生成 Request。 如果您想要修改最初爬取某个网站的 Request 对象，您可以重写(override)该方法。 例如，如果您需要在启动时以 POST 登录某个网站，你可以这么写: 12345678910class MySpider(scrapy.MySpider): name = 'myspider' def start_request(self): return [scrapy.FormRequest(\"http://www.example.com/login\", formdata={'user': 'john', 'pass': 'secret'}, callback=self.logged_in)] def logged_in(self, response): pass make_requests_from_url(url) 该方法接受一个 URL 并返回用于爬取的 Request 对象。 该方法在初始化 request 时被 start_requests() 调用，也被用于转化 url 为 request 。 默认未被复写(overridden)的情况下，该方法返回的 Request 对象中， parse() 作为回调函数，dont_filter 参数也被设置为开启。 parse(response) 当 response 没有指定回调函数时，该方法是 Scrapy 处理下载的 response 的默认函数。 parse 负责处理 response 并返回处理的数据以及(/或)跟进的 URL。 Spider 对其他的 Request 的回调函数也有相同的要求。 该方法及其他的 Request 回调函数必须返回一个包含 Request、dict 或 Item 的可迭代的对象。 log(message[, level, component]) 使用 scrapy.log.msg() 方法记录(log)message。 log 中自动带上该 spider 的 name 属性。 closed(reason) 当 spider 关闭时，该函数被调用。 该方法提供了一个替代调用 signals.connect() 来监听 spider_closed 信号的快捷方式。 Spider argumentsSpider arguments are passed through the crawl command using the -a option. For example: scrapy crawl myspider -a category=electronics 12345678import scrapyclass MySpider(scrapy.Spider): name = 'myspider' def __init__(self, category=None, *args, **kwargs): super(MySpider, self).__init__(*args, **kwargs) self.start_urls = ['http://www.example.com/categories/%s' % category] Generic SpidersCrawlSpiderclass scrapy.spiders.CrawlSpider 爬取一般网站常用的 spider 。其定义了一些规则(rule)来提供跟进 link 的方便的机制。 也许该 spider 并不是完全适合您的特定网站或项目，但其对很多情况都使用。 因此您可以以其为起点，根据需求修改部分方法。当然您也可以实现自己的 spider。 除了从 Spider 继承过来的(您必须提供的)属性外，其提供了一个新的属性: rules 一个包含一个(或多个) Rule 对象的集合(list)。 每个 Rule 对爬取网站的动作定义了特定表现。 Rule 对象在下边会介绍。 如果多个rule匹配了相同的链接，则根据他们在本属性中被定义的顺序，第一个会被使用。 该spider也提供了一个可复写(overrideable)的方法: parse_start_url(response) 当start_url的请求返回时，该方法被调用。 该方法分析最初的返回值并必须返回一个 Item 对象或者 一个 Request 对象或者 一个可迭代的包含二者对象。 爬取规则(Crawling rules)class scrapy.spiders.Rule(link_extractor, callback=None, cb_kwargs=None, follow=None, process_links=None, process_request=None) link_extractor 是一个 Link Extractor 对象。 其定义了如何从爬取到的页面提取链接。 callback 是一个 callable 或 string (该spider中同名的函数将会被调用)。 从 link_extractor 中每获取到链接时将会调用该函数。该回调函数接受一个 response 作为其第一个参数， 并返回一个包含 Item 以及(或) Request 对象(或者这两者的子类)的列表(list)。 cb_kwargs 包含传递给回调函数的参数(keyword argument)的字典。 follow 是一个布尔(boolean)值，指定了根据该规则从 response 提取的链接是否需要跟进。 如果 callback 为None， follow 默认设置为 True ，否则默认为 False 。 process_links 是一个 callable 或 string (该spider中同名的函数将会被调用)。 从 link_extractor 中获取到链接列表时将会调用该函数。该方法主要用来过滤。 process_request 是一个 callable 或 string (该spider中同名的函数将会被调用)。 该规则提取到每个 request 时都会调用该函数。该函数必须返回一个request或者None。 (用来过滤request) CrawlSpider样例接下来给出配合rule使用CrawlSpider的例子: 12345678910111213141516171819202122232425import scrapyfrom scrapy.spiders import CrawlSpider, Rulefrom scrapy.linkextractors import LinkExtractorclass MySpider(CrawlSpider): name = 'myspider' allowed_domains = ['example.com'] start_urls = ['http://www.example.com'] rules = [ # 提取匹配 'category.php' (但不匹配 'subsection.php') 的链接并跟进链接(没有callback意味着follow默认为True) Rule(LinkExtractor(allow=('category\\.php', ), deny=('subsection\\.php', ))), # 提取匹配 'item.php' 的链接并使用spider的parse_item方法进行分析 Rule(LinkExtractor(allow=('item\\.php', )), callback='parse_item'), ] def parse_item(self, response): self.logger.info('Hi, this is an item page! %s', response.url) item = scrapy.Item() item['id'] = response.xpath('//td[@id=\"item_id\"]/text()').re(r'ID: (\\d+)') item['name'] = response.xpath('//td[@id=\"item_name\"]/text()').extract() item['description'] = response.xpath('//td[@id=\"item_description\"]/text()').extract() return item 该 spider 将从 example.com 的首页开始爬取，获取 category 以及 item 的链接并对后者使用 parse_item 方法。 当 item 获得返回(response)时，将使用 XPath 处理 HTML 并生成一些数据填入 Item 中。 XMLFeedSpiderclass scrapy.spiders.XMLFeedSpider XMLFeedSpider 被设计用于通过迭代各个节点来分析 XML 源(XML feed)。 迭代器可以从 iternodes ， xml ， html 选择。 鉴于 xml 以及 html 迭代器需要先读取所有DOM再分析而引起的性能问题， 一般还是推荐使用 iternodes 。 不过使用 html 作为迭代器能有效应对错误的 XML。 您必须定义下列类属性来设置迭代器以及标签名(tag name): iterator 用于确定使用哪个迭代器的string。可选项有: iternodes - 一个高性能的基于正则表达式的迭代器 html - 使用 Selector 的迭代器。 需要注意的是该迭代器使用DOM进行分析，其需要将所有的DOM载入内存， 当数据量大的时候会产生问题。 xml - 使用 Selector 的迭代器。 需要注意的是该迭代器使用DOM进行分析，其需要将所有的DOM载入内存， 当数据量大的时候会产生问题。 默认值为 iternodes 。 itertag 一个包含开始迭代的节点名的string。例如:itertag = 'product' namespaces 一个由 (prefix, url) 元组(tuple)所组成的 list。 其定义了在该文档中会被 spider 处理的可用的 namespace 。 prefix 及 uri 会被自动调用 register_namespace() 生成 namespace。 您可以通过在 itertag 属性中制定节点的 namespace。 例如: 12345class YourSpider(XMLFeedSpider): namespaces = [('n', 'http://www.sitemaps.org/schemas/sitemap/0.9')] itertag = 'n:url' # ... 除了这些新的属性之外，该spider也有以下可以覆盖(overrideable)的方法: adapt_response(response) 该方法在 spider 分析 response 前被调用。您可以在 response 被分析之前使用该函数来修改内容(body)。 该方法接受一个 response 并返回一个 response (可以相同也可以不同)。 parse_node(response, selector) 当节点符合提供的标签名时(itertag)该方法被调用。 接收到的 response 以及相应的 Selector 作为参数传递给该方法。 该方法返回一个 Item 对象或者 Request 对象 或者一个包含二者的可迭代对象(iterable)。 process_results(response, results) 当 spider 返回结果(item或request)时该方法被调用。 设定该方法的目的是在结果返回给框架核心(framework core)之前做最后的处理， 例如设定 item 的 ID 。其接受一个结果的列表(list of results)及对应的 response。 其结果必须返回一个结果的列表(list of results)(包含Item或者Request对象)。 XMLFeedSpider例子123456789101112131415161718from scrapy.spiders import XmlFeedSpiderfrom myproject.items import TestItemclass MySpider(XmlFeedSpider): name = 'example.com' allowed_domains = ['example.com'] start_urls = ['http://www.example.com/feed.xml'] iterator = 'iternodes' # This is actually unnecessary, since it's the default value itertag = 'item' def parse_node(self, response, node): self.logger.info('Hi, this is a &lt;%s&gt; node!: %s', self.itertag, ''.join(node.extract())) item = TestItem() item['id'] = node.xpath('@id').extract() item['name'] = node.xpath('name').extract() item['description'] = node.xpath('description').extract() return item 简单来说，我们在这里创建了一个 spider ，从给定的 start_urls 中下载 feed ， 并迭代 feed 中每个 item 标签，输出，并在 Item 中存储有些随机数据。 CSVFeedSpiderclass scrapy.spiders.CSVFeedSpider 该 spider 除了其按行遍历而不是节点之外其他和 XMLFeedSpider 十分类似。 而其在每次迭代时调用的是 parse_row() 。 delimiter在CSV文件中用于区分字段的分隔符。类型为string。 默认为 ‘,’ (逗号)。 quotecharA string with the enclosure character for each field in the CSV file Defaults to ‘“‘ (quotation mark). headers在CSV文件中包含的用来提取字段的行的列表。参考下边的例子。 parse_row(response, row)该方法接收一个 response 对象及一个以提供或检测出来的 header 为键的字典(代表每行)。 该 spider 中，您也可以覆盖 adapt_response 及 process_results 方法来进行预处理(pre-processing)及后(post-processing)处理。 CSVFeedSpider例子12345678910111213141516171819from scrapy.spiders import CSVFeedSpiderfrom myproject.items import TestItemclass MySpider(CSVFeedSpider): name = 'example.com' allowed_domains = ['example.com'] start_urls = ['http://www.example.com/feed.csv'] delimiter = ';' quotechar = \"'\" headers = ['id', 'name', 'description'] def parse_row(self, response, row): self.logger.info('Hi, this is a row!: %r', row) item = TestItem() item['id'] = row['id'] item['name'] = row['name'] item['description'] = row['description'] return item SitemapSpiderclass scrapy.spiders.SitemapSpider SitemapSpider 使您爬取网站时可以通过 Sitemaps 来发现爬取的URL。 其支持嵌套的 sitemap，并能从 robots.txt 中获取 sitemap 的url。 sitemap_urls包含您要爬取的 url 的 sitemap 的 url 列表(list)。 您也可以指定为一个 robots.txt ，spider 会从中分析并提取url。 sitemap_rules一个包含 (regex, callback) 元组的列表(list): regex 是一个用于匹配从sitemap提供的url的正则表达式。 regex 可以是一个字符串或者编译的正则对象(compiled regex object)。 callback指定了匹配正则表达式的url的处理函数。 callback 可以是一个字符串(spider中方法的名字)或者是callable。 例如:sitemap_rules = [('/product/', 'parse_product')] 规则按顺序进行匹配，之后第一个匹配才会被应用。 如果您忽略该属性，sitemap中发现的所有url将会被 parse 函数处理。 sitemap_follow 一个用于匹配要跟进的sitemap的正则表达式的列表(list)。其仅仅被应用在使用 Sitemap index files 来指向其他 sitemap文件的站点。 默认情况下所有的 sitemap 都会被跟进。 sitemap_alternate_links 指定当一个 url 有可选的链接时，是否跟进。 有些非英文网站会在一个 url 块内提供其他语言的网站链接。 例如: 1234&lt;url&gt; &lt;loc&gt;http://example.com/&lt;/loc&gt; &lt;xhtml:link rel=\"alternate\" hreflang=\"de\" href=\"http://example.com/de\"/&gt;&lt;/url&gt; 当 sitemap_alternate_links 设置时，两个 URL 都会被获取。 当 sitemap_alternate_links 关闭时，只有 http://example.com/ 会被获取。 默认 sitemap_alternate_links 关闭。 SitemapSpider样例 简单的例子: 使用 parse 处理通过sitemap发现的所有url: 1234567from scrapy.spiders import SitemapSpiderclass MySpider(SitemapSpider): sitemap_urls = ['http://www.example.com/sitemap.xml'] def parse(self, response): pass # ... scrape item here ... 用特定的函数处理某些url，其他的使用另外的callback: 1234567891011121314from scrapy.spiders import SitemapSpiderclass MySpider(SitemapSpider): sitemap_urls = ['http://www.example.com/sitemap.xml'] sitemap_rules = [ ('/product/', 'parse_product'), ('/category/', 'parse_category'), ] def parse_product(self, response): pass # ... scrape product ... def parse_category(self, response): pass # ... scrape category ... 跟进 robots.txt 文件定义的 sitemap 并只跟进包含有 ..sitemap_shop 的 url: 1234567891011from scrapy.spiders import SitemapSpiderclass MySpider(SitemapSpider): sitemap_urls = ['http://www.example.com/robots.txt'] sitemap_rules = [ ('/shop/', 'parse_shop'), ] sitemap_follow = ['/sitemap_shops'] def parse_shop(self, response): pass # ... scrape shop here ... 在SitemapSpider中使用其他url: 1234567891011121314151617181920from scrapy.spiders import SitemapSpiderclass MySpider(SitemapSpider): sitemap_urls = ['http://www.example.com/robots.txt'] sitemap_rules = [ ('/shop/', 'parse_shop'), ] other_urls = ['http://www.example.com/about'] def start_requests(self): requests = list(super(MySpider, self).start_requests()) requests += [scrapy.Request(x, self.parse_other) for x in self.other_urls] return requests def parse_shop(self, response): pass # ... scrape shop here ... def parse_other(self, response): pass # ... scrape other here ...","link":"/2017/09/28/Scrapy-Spiders/"},{"title":"Scrapy 入门","text":"scrapy 介绍scrapy 是一个基于 Python 语言的爬虫框架。有了框架的存在，我们可以更方便的爬虫了，框架帮我们封装好了下载等模块，而且更重要的是框架使用了异步的模式，加快了爬虫的速度。 环境搭建在命令行中执行 conda install Scrapy 这样就安装好了 Scrapy 模块，是不是特别简单。ahahahha 开始接下来就要开始我们的 scrapy 之路了。 新建项目使用 Scrapy 第一步：创建项目，命令行进入你需要放置项目的目录，然后执行 scrapy startproject ScrapyDemo #ScrapyDemo是项目名称 目录结构这时会在目录下多出一个 ScrapyDemo 文件夹，这就是 Scrapy 项目了，项目的结构如下1234567891011.|-- ScrapyDemo| `-- ScrapyDemo| |-- spiders| | `-- __init__.py| |-- __init__.py| |-- items.py| |-- middlewares.py| |-- pipelines.py| `-- settings.py`-- scrapy.cfg 目录说明： ScrapyDemo(外层) 项目总目录 ScrapyDemo(内层) 项目目录 scrapy.cfg 项目的配置文件 spiders 放置我们的爬虫代码的目录 items.py 定义我们需要获取的字段 middlewares.py pipelines.py 用来定义存储 settings.py 项目设置文件 还有一点要注意的是，Scrapy 默认是不能在 IDE 中调试的，所以要在项目总目录下新建一个 entrypoint.py 文件，写下以下内容：1234from scrapy.cmdline import execute# 前两个参数是不变的，第三个参数是自己定义的 spider 的名字execute(['scrapy', 'crawl', 'dingdian']) 现在整个目录应该是这样（盗图..） 架构下面我们先来看一下框架的架构图 Scrapy Engine: 这是引擎，负责Spiders、ItemPipeline、Downloader、Scheduler中间的通讯，信号、数据传递等等！（像不像人的身体？） Scheduler(调度器): 它负责接受引擎发送过来的requests请求，并按照一定的方式进行整理排列，入队、并等待Scrapy Engine(引擎)来请求时，交给引擎。 Downloader（下载器）：负责下载Scrapy Engine(引擎)发送的所有Requests请求，并将其获取到的Responses交还给Scrapy Engine(引擎)，由引擎交给Spiders来处理， Spiders：它负责处理所有Responses,从中分析提取数据，获取Item字段需要的数据，并将需要跟进的URL提交给引擎，再次进入Scheduler(调度器)， Item Pipeline：它负责处理Spiders中获取到的Item，并进行处理，比如去重，持久化存储（存数据库，写入文件，总之就是保存数据用的） Downloader Middlewares（下载中间件）：你可以当作是一个可以自定义扩展下载功能的组件 Spider Middlewares（Spider中间件）：你可以理解为是一个可以自定扩展和操作引擎和Spiders中间‘通信’的功能组件（比如进入Spiders的Responses;和从Spiders出去的Requests） 数据在整个Scrapy的流向： 程序运行的时候， 引擎：Hi！Spider, 你要处理哪一个网站？ Spiders：我要处理23wx.com 引擎：你把第一个需要的处理的URL给我吧。 Spiders：给你第一个URL是XXXXXXX.com 引擎：Hi！调度器，我这有request你帮我排序入队一下。 调度器：好的，正在处理你等一下。 引擎：Hi！调度器，把你处理好的request给我， 调度器：给你，这是我处理好的request 引擎：Hi！下载器，你按照下载中间件的设置帮我下载一下这个request 下载器：好的！给你，这是下载好的东西。（如果失败：不好意思，这个request下载失败，然后引擎告诉调度器，这个request下载失败了，你记录一下，我们待会儿再下载。） 引擎：Hi！Spiders，这是下载好的东西，并且已经按照Spider中间件处理过了，你处理一下（注意！这儿responses默认是交给def parse这个函数处理的） Spiders：（处理完毕数据之后对于需要跟进的URL），Hi！引擎，这是我需要跟进的URL，将它的responses交给函数 def xxxx(self, responses)处理。还有这是我获取到的Item。 引擎：Hi ！Item Pipeline 我这儿有个item你帮我处理一下！调度器！这是我需要的URL你帮我处理下。然后从第四步开始循环，直到获取到你需要的信息， 注意！只有当调度器中不存在任何request了，整个程序才会停止，（也就是说，对于下载失败的 URL，Scrapy会重新下载。） 写代码建立一个项目之后： 第一件事就是在 items.py 文件中定义我们需要的字段，用来临时存储要保存的数据，方便以后数据的持久化存储，比如 数据库 文本文件等。 第二件事是在 spiders.py 中编写自己的爬虫代码 第三件事是在 pipelines.py 中存储自己的数据 建议：在大家调试的时候在settings.py中取消下面几行的注释：12345HTTPCACHE_ENABLED = TrueHTTPCACHE_EXPIRATION_SECS = 0HTTPCACHE_DIR = 'httpcache'HTTPCACHE_IGNORE_HTTP_CODES = []HTTPCACHE_STORAGE = 'scrapy.extensions.httpcache.FilesystemCacheStorage' 上面代码的作用是 Scrapy 会缓存你有的 Requests！ 当你再次请求时，如果存在缓存文档则返回缓存文档，而不是去网站请求，这样既加快了本地调试速度，也减轻了 网站的压力。一举多得 定义字段要根据自己要爬取的内容来定义字段。比如，在这里我们要爬的是小说站点就需要定义，小说名字，作者，小说地址，连载状态，字数，文章类别 等字段。 就像下面这样：123456789101112131415class ScrapydemoItem(scrapy.Item): # 小说名字 name = scrapy.Field() # 作者 author = scrapy.Field() # 小说地址 novelurl = scrapy.Field() # 连载状态 serialstatus = scrapy.Field() # 连载字数 serialnumber = scrapy.Field() # 类别 category = scrapy.Field() # 编号 novel_id = scrapy.Field() 编写 spider在 spiders 目录下新建一个 ScrapyDemo.py 文件，并导入我们需用的模块 1234567import scrapy import refrom bs4 import BeautifulSoupfrom scrapy.http import Requestfrom ScrapyDemo.items import ScrapydemoItemclass Muspider(scrapy.Spider): 我们需要从一个地址入手开始爬取，我在顶点小说上没有发现有全站小说地址，但是我找到每个分类地址全部小说： 玄幻魔幻：http://www.x23us.com/class/1_1.html 武侠修真：http://www.x23us.com/class/2_1.html 都市言情：http://www.x23us.com/class/3_1.html 历史军事：http://www.x23us.com/class/4_1.html 侦探推理：http://www.x23us.com/class/5_1.html 网游动漫：http://www.x23us.com/class/6_1.html 科幻小说：http://www.x23us.com/class/7_1.html 恐怖灵异：http://www.x23us.com/class/8_1.html 散文诗词：http://www.x23us.com/class/9_1.html 其他：http://www.x23us.com/class/10_1.html 全本：http://www.x23us.com/quanben/1 好啦！入口地址我们找到了，现在开始写第一部分代码： 12345678910111213141516171819import scrapyimport refrom bs4 import BeautifulSoupfrom scrapy.http import Requestfrom ScrapyDemo.items import ScrapydemoItemclass Myspider(scrapy.Spider): name = 'ScrapyDemo' allowed_domains = ['x23us.com'] bash_url = 'http://www.x23us.com/class/' bashurl = '.html' def start_requests(self): for i in range(1, 11): url = self.bash_url + str(i) + '_1' + self.bashurl yield Request(url,self.parse) def parse(self, response): print(response.text) 首先我们创建一个类 Myspider；这个类继承自 scrapy.Spider 定义了一个 allowed_domains ；这个不是必须的；但是在某写情况下需要用得到，比如使用爬取规则的时候就需要了；它的作用是只会跟进存在于 allowed_domains 中的 URL。不存在的 URL 会被忽略。 第九行定义的 name 是之前我们在 entrypoint.py 文件中的第三个参数 此 name 在整个项目中有且只能有一个、名字不可重复！！！ 之后可以运行 entrypoint.py 文件来检查一下代码时候可以正常工作。 请求就这么轻而易举的实现了啊！简直So Easy！ 继续 继续！ 我们需要历遍所有页面才能取得所有的小说页面连接： 123456789101112131415161718192021222324252627282930313233343536373839404142434445import scrapyimport refrom bs4 import BeautifulSoupfrom scrapy.http import Requestfrom ScrapyDemo.items import ScrapydemoItemclass Muspider(scrapy.Spider): name = 'ScrapyDemo' allowed_domains = ['x23us.com'] bash_url = 'http://www.x23us.com/class/' bashurl = '.html' def start_requests(self): for i in range(1, 11): url = self.bash_url + str(i) + '_1' + self.bashurl yield Request(url, self.parse) def parse(self, response): max_span = BeautifulSoup(response.text, 'lxml').find('div', class_='pagelink').find_all('a')[-1].get_text() bashurl = str(response.url)[:-6] for num in range(1, int(max_span) + 1): url = bashurl + str(num) + self.bashurl yield Request(url, self.get_name) def get_name(self, response): novels = BeautifulSoup(str(response), 'lxml').find_all('tr', bgcolor='#F2F2F2') for navel in novels: a = navel.find('a') name = a['title'] url = a['href'] yield Request(url, callback=self.get_chapterurl, meta={'name': name, 'url': url}) def get_chapterurl(self, response): item = ScrapydemoItem() item['name'] = str(response.meta['name']).replace('\\xa0', '') item['novelurl'] = response.meta['url'] category = BeautifulSoup(response.text, 'lxml').find('table').find('a').get_text() author = BeautifulSoup(response.text, 'lxml').find('table').find_all('td')[1].get_text() bash_url = BeautifulSoup(response.text, 'lxml').find('p', class_='btnlinks').find('a', class_='read')['href'] name_id = str(bash_url)[-6:-1].replace('/', '') item['category'] = str(category).replace('/', '') item['author'] = str(author).replace('/', '') item['name_id'] = name_id return item 自定义 Pipeline做一个自定义的MySQL的Pipeline。首先为了能好区分框架自带的Pipeline，我们把MySQL的Pipeline单独放到一个目录里面。 pipelines.py 这个是我们写存放数据的文件 sql.py 看名字就知道，需要的sql语句。 首先是需要的 MySQL 表,123456789DROP TABLE IF EXISTS `dd_name`;CREATE TABLE `dd_name` ( `id` int(11) NOT NULL AUTO_INCREMENT, `xs_name` varchar(255) DEFAULT NULL, `xs_author` varchar(255) DEFAULT NULL, `category` varchar(255) DEFAULT NULL, `name_id` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=38 DEFAULT CHARSET=utf8mb4; 记得在 settings.py 文件中定义好 MySQL 的配置文件12345MYSQL_HOSTS = '127.0.0.1'MYSQL_USER = 'root'MYSQL_PORT = '3306'MYSQL_PASSWORD = '****'MYSQL_DB = 'xiaoshuo' 在开始写sql.py之前，我们需要安装一个Python操作MySQL的包，来自MySQL官方的一个包：点我下载 下载完成后解压出来，从 cmd 进入该目录的绝对路径，然后 python setup.py install ；即可完成安装(记得以管理员身份打开命令行) sql.py1234567891011121314151617181920212223242526272829303132333435import mysql.connectorfrom ScrapyDemo import settingsMYSQL_USER = settings.MYSQL_USERMYSQL_PASSWORD = settings.MYSQL_PASSWORDMYSQL_HOST = settings.MYSQL_HOSTSMYSQL_PORT = settings.MYSQL_PORTMYSQL_DB = settings.MYSQL_DBcnx = mysql.connector.connect(user=MYSQL_USER, password=MYSQL_PASSWORD, host=MYSQL_HOST, database=MYSQL_DB)cur = cnx.cursor(buffered=True)class Sql: @classmethod def insert_dd_name(cls, xs_name, xs_author, category, name_id): sql = 'INSERT INTO dd_name (`xs_name`,`xs_author`,`category`,``name_id) VALUES (%(xs_name)s,%(xs_author)s,,%(category)s,,%(name_id)s)' VALUE = { 'xs_name': xs_name, 'xs_author': xs_author, 'category': category, 'name_id': name_id } cur.execute(sql, VALUE) cnx.commit() @classmethod def select_name(cls, name_id): sql = 'SELECT EXISTS(SELECT 1 FROM dd_name WHERE name_id=%(name_id)s)' value = { 'name_id': name_id } cur.execute(sql, value) cnx.commit() 来开始写pipeline123456789101112131415161718from ScrapyDemo.items import ScrapydemoItemfrom .sql import Sqlclass ScrapyPipeline(object): def process_item(self, item, sqider): if isinstance(item, ScrapydemoItem): name_id = item['name_id'] ret = Sql.select_name(name_id) if ret[0] == 1: print('已经存在了') pass else: xs_name = item['xs_name'] xs_author = item['xs_author'] category = item['category'] Sql.insert_dd_name(xs_name, xs_author, category, name_id) print('开始存小说标题') 定义了一个process_item函数并有，item和spider这两个参数（请注意啊！这两玩意儿 务必！！！要加上！！千万不能少！！！！务必！！！务必！！！） 搞完！下面我们启用这个Pipeline在settings中作如下设置： 后面的 1 是优先级程度（1-1000随意设置，数值越低，组件的优先级越高） 下面我们开始还剩下的一些内容获取：小说章节 和章节内容 首先我们在 item.py 中新定义一些需要获取内容的字段： 12345678910111213141516171819202122232425import scrapyclass ScrapydemoItem(scrapy.Item): # 小说名字 name = scrapy.Field() # 作者 author = scrapy.Field() # 小说地址 novelurl = scrapy.Field() # 连载状态 serialstatus = scrapy.Field() # 连载字数 serialnumber = scrapy.Field() # 类别 category = scrapy.Field() # 编号 novel_id = scrapy.Field()class Content(scrapy.Item): id_name = scrapy.Field() chaptercontent = scrapy.Field() num = scrapy.Field() chapter_url = scrapy.Field() chapter_name = scrapy.Field() 继续编写Spider文件： 12345678910111213141516171819202122232425262728293031323334353637def get_chapterurl(self, response): item = ScrapydemoItem() item['name'] = str(response.meta['name']).replace('\\xa0', '') item['novelurl'] = response.meta['url'] category = BeautifulSoup(response.text, 'lxml').find('table').find('a').get_text() author = BeautifulSoup(response.text, 'lxml').find('table').find_all('td')[1].get_text() bash_url = BeautifulSoup(response.text, 'lxml').find('p', class_='btnlinks').find('a', class_='read')['href'] name_id = str(bash_url)[-6:-1].replace('/', '') item['category'] = str(category).replace('/', '') item['author'] = str(author).replace('/', '') item['name_id'] = name_id yield item yield Request(bash_url, callback=self.get_chapter, meta={'name_id': name_id})def get_chapter(self, response): urls = re.findall(r'&lt;td class=\"L\"&gt;&lt;a href=\"(.*?)\"&gt;(.*?)&lt;/a&gt;&lt;/td&gt;', response.text) num = 0 for url in urls: num = num + 1 chapterurl = response.url + url[0] chaptername = url[1] yield Request(chapterurl, callback=self.get_chaptercontent, meta={ 'num': num, 'name_id': response.meta['name_id'], 'chapter_url': chapterurl, 'chaptername': chaptername })def get_chaptercontent(self, response): item = Content() item['id_name'] = response.meta['name_id'] item['num'] = response.meta['num'] item['chapter_url'] = response.meta['chapter_url'] item['chapter_name'] = response.meta['chaptername'] content = BeautifulSoup(response.text, 'lxml').find('dd', id='contents').get_text() item['content'] = str(content).replace('\\xa0', '') return item 注意 13\\14 行，这个地方返回item是不能用return的哦！用了就结束了，程序就不会继续下去了，得用 yield 下面我们来写存储这部分spider的Pipeline： 数据表：1234567891011DROP TABLE IF EXISTS `dd_chaptername`;CREATE TABLE `dd_chaptername` ( `id` int(11) NOT NULL AUTO_INCREMENT, `xs_chaptername` varchar(255) DEFAULT NULL, `xs_content` text, `id_name` int(11) DEFAULT NULL, `num_id` int(11) DEFAULT NULL, `url` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=2726 DEFAULT CHARSET=gb18030;SET FOREIGN_KEY_CHECKS=1; 下面是Pipeline： 有小伙伴注意，这儿比上面一个Pipeline少一个判断，因为我把判断移动到Spider中去了，这样就可以减少一次Request，减轻服务器压力。 改变后的Spider长这样：","link":"/2017/09/02/Scrapy-入门/"},{"title":"RxJava系列(一) 入门","text":"RxJava 入门 入门（概念、基础使用） 进阶（操作符（map、flatmap、zip、defer、contatMap等等），背压等） 实战（网络请求等） 源码解析（变换、线程调度，源码探讨） 概念下面是摘自 ReactiveX 官网 的一段话。 ReactiveX is a library for composing asynchronous and event-based programs by using observable sequences.(一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库) 其中提到了几个概念，观察者模式、响应式编程。 响应式编程 概念：响应式编程是一种通过异步和数据流来构建事物关系的编程模型。 一般的编码模式中，“人”在其中扮演了过重的角色，关心程序中的每一部分。某种意义上这是一种顺序性思维的编程，我要做什么，然后做什么，最后做什么，按部就班编写就好了。具体如下图： 而响应式编程，全都是事物与事物之间的关系，解脱了”人”，之后一个事物发生变化另一个事物就自动响应。如下： 个人感觉响应式编程就是用异步数据流进行编程。流是响应式的核心，可以基于任何东西创建数据流，响应式编程就是根据数据流的流向进行一系列的操作。 观察者模式 观察者模式(Observer Pattern)：定义了对象间的一种一对多的依赖关系，当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。 观察者模式面向的需求是：A 对象（观察者）对 B 对象（被观察者）的某种变化高度敏感，需要在 B 变化的一瞬间做出反应。举个例子，新闻里喜闻乐见的警察抓小偷，警察需要在小偷伸手作案的时候实施抓捕。在这个例子里，警察是观察者，小偷是被观察者，警察需要时刻盯着小偷的一举一动，才能保证不会漏过任何瞬间。程序的观察者模式和这种真正的『观察』略有不同，观察者不需要时刻盯着被观察者（例如 A 不需要每过 2ms 就检查一次 B 的状态），而是采用 注册(Register) 或者称为 订阅(Subscribe) 的方式，告诉被观察者：我需要你的某某状态，你要在它变化的时候通知我。 Android 开发中一个比较典型的例子是点击监听器 OnClickListener 。对设置 OnClickListener 来说， View 是被观察者， OnClickListener 是观察者，二者通过 setOnClickListener() 方法达成订阅关系。订阅之后用户点击按钮的瞬间，Android Framework 就会将点击事件发送给已经注册的 OnClickListener 。采取这样被动的观察方式，既省去了反复检索状态的资源消耗，也能够得到最高的反馈速度。当然，这也得益于我们可以随意定制自己程序中的观察者和被观察者，而警察叔叔明显无法要求小偷『你在作案的时候务必通知我』。 RxJava 简介 我所理解的RxJava的核心优势应该是它可以对复杂逻辑进行拆分成为一个一个的Observable后，RxJava的各种操作符予这些解耦的Observable能够合理的进行再组织的能力，并且它给予了你足够丰富的再组织能力。这种分拆再组织的能力是十分强大的，只有运用好RxJava这种强大的能力，才能真正意义上使你原来非常复杂的揉在一团的逻辑代码变得清晰、简洁，本质上是因为RxJava给你提供了这种强大方便的组织能力，我觉得有点像一种编程模式，你可以放心的将复杂的逻辑拆块，最后RxJava给你提供了丰富的组织、变换、串联、控制这些块的能力，只有这个时候你才会真正觉得这是个好东西，而不应该是跟风使用，但是心里也说不清楚为什么要使用。 RxJava 有三个基本概念: Observable （被观察者），Observer （观察者），subscribe （订阅）。Observable 和 Observer 通过 subscribe() 方法实现订阅关系，从而 Observable 可以在需要的时候发出事件来通知 Observer。 Github 链接： RxJava https://github.com/ReactiveX/RxJava RxAndroid https://github.com/ReactiveX/RxAndroid gradle 依赖： implementation 'io.reactivex.rxjava2:rxjava:2.x.y' implementation 'io.reactivex.rxjava2:rxandroid:2.x.y' RxJava 使用创建被观察者123456789Observable&lt;String&gt; observable = Observable .create(new ObservableOnSubscribe&lt;String&gt;() { @Override public void subscribe(ObservableEmitter&lt;String&gt; emitter) { emitter.onNext(\"Hello\"); emitter.onNext(\"World\"); emitter.onComplete(); } }); 可以看到，这里传入了一个 ObservableOnSubscribe 对象作为参数。ObservableOnSubscribe 会被存储在返回的 Observable 对象中，当 Observable 被订阅的时候，subscribe 方法就会自动被调用，事件序列就会依照设定依次触发（对于上面的代码，就是观察者 observer 将会被调用三次 onNext() 和一次 onComplete()）。 此外，还可以通过其他方法来创建被观察者。 just(T...): 将传入的参数依次发送出来。 1Observable observable = Observable.just(\"Hello\", \"World\"); fromArray(T...items) : 将传入的数组或 Iterable 拆分成具体对象后，依次发送出来。 12String[] words = {\"Hello\", \"Hi\", \"Aloha\"};Observable&lt;String&gt; observable = Observable.fromArray(words); 除 Observable 外还有 Flowable 等被观察者类型。 创建观察者123456789101112131415161718192021Observer&lt;String&gt; observer = new Observer&lt;String&gt;() { @Override public void onSubscribe(Disposable d) { } @Override public void onNext(String s) { } @Override public void onError(Throwable e) { } @Override public void onComplete() { } }; 在观察者中进行响应事件对应的相关操作。 订阅1observable.subscribe(observer); 这里的写法是被观察者订阅了观察者，而不是观察者订阅被观察者，是为了保证流式API调用风格。 12345observable .observeOn(AndroidSchedulers.mainThread()) .subscribeOn(Schedulers.io()) .filter(s -&gt; s != null) .subscribe(observer); 上面就是一个非常简易的RxJava流式API的调用：同一个调用主体一路调用下来，一气呵成。 RxJava 的这个实现，是一条从上到下的链式调用，没有任何嵌套，这在逻辑的简洁性上是具有优势的。 整个流程如下图所示： 结合流程图的相应代码实例如下： 12345678910111213141516171819202122232425262728//创建被观察者，是事件传递的起点Observable.just(\"On\",\"Off\",\"On\",\"On\") //这就是在传递过程中对事件进行过滤操作 .filter(new Func1&lt;String, Boolean&gt;() { @Override public Boolean call(String s) { return s！=null; } }) //实现订阅 .subscribe( //创建观察者，作为事件传递的终点处理事件 new Subscriber&lt;String&gt;() { @Override public void onCompleted() { Log.d(\"DDDDDD\",\"结束观察...\\n\"); } @Override public void onError(Throwable e) { //出现错误会调用这个方法 } @Override public void onNext(String s) { //处理事件 Log.d(\"DDDDD\",\"handle this---\"+s) } ); 注意：当调用订阅操作（即调用Observable.subscribe()方法）的时候，被观察者才真正开始发出事件。 线程调度至此，在 RxJava 的默认规则中，事件的发出和消费都是在同一个线程的。 在 RxJava 中，通过 Scheduler 来指定每一段代码应该运行在什么样的线程。下表展示了RxJava中可用的调度器种类： 调度器类型 效果 Schedulers.computation( ) 用于计算任务，如事件循环或和回调处理，不要用于IO操作(IO操作请使用Schedulers.io())；默认线程数等于处理器的数量 Schedulers.from(executor) 使用指定的Executor作为调度器 Schedulers.immediate( ) 在当前线程立即开始执行任务 Schedulers.io( ) 用于IO密集型任务，如异步阻塞IO操作，这个调度器的线程池会根据需要增长；对于普通的计算任务，请使用Schedulers.computation()；Schedulers.io( )默认是一个CachedThreadScheduler，很像一个有线程缓存的新线程调度器 Schedulers.newThread( ) 为每个任务创建一个新线程 Schedulers.trampoline( ) 当其它排队的任务完成后，在当前线程排队开始执行 AndroidSchedulers.mainThread() Android 主线程 subscribeOn(): 指定 subscribe() 所发生的线程，或者叫做事件产生的线程。 observeOn(): 指定 Observer 所运行在的线程。或者叫做事件消费的线程。 123456789101112131415//new Observable.just()执行在新线程Observable.just(getFilePath()) //指定在新线程中创建被观察者 .subscribeOn(Schedulers.newThread()) //将接下来执行的线程环境指定为io线程 .observeOn(Schedulers.io()) //map就处在io线程 .map(mMapOperater) //将后面执行的线程环境切换为主线程， //但是这一句依然执行在io线程 .observeOn(AndroidSchedulers.mainThread()) //指定线程无效，但这句代码本身执行在主线程 .subscribeOn(Schedulers.io()) //执行在主线程 .subscribe(mSubscriber); 注意： subscribeOn() 它指示 Observable 在一个指定的调度器上创建（只作用于被观察者创建阶段）。只能指定一次，如果指定多次则以第一次为准 observeOn() 指定在事件传递（加工变换）和最终被处理（观察者）的发生在哪一个调度器。可指定多次，每次指定完都在下一步生效。 ======================================================= 进阶（操作符（map、flatmap、zip、defer、contatMap等等），背压等） 操作符 说明 Create 使用一个函数从头开始创建一个Observable Defer 直到有观察者订阅时才创建Observable，并且为每个观察者创建一个新的Observable Empty 创建一个不发射任何数据但是正常终止的Observable Never 创建一个不发射数据也不终止的Observable Throw 创建一个不发射数据以一个错误终止的Observable From 将其它种类的对象和数据类型转换为Observable Interval 创建一个按固定时间间隔发射整数序列的Observable Just 创建一个发射指定值的Observable Range 创建一个发射特定整数序列的Observable Repeat 创建一个发射特定数据重复多次的Observable Start 返回一个Observable，它发射一个类似于函数声明的值 Timer 创建一个Observable，它在一个给定的延迟后发射一个特殊的值 操作符 说明 操作符 说明 ======================================================= 123456789101112131415161718192021222324252627282930313233343536373839private void testRxJava() { Observable.create(new ObservableOnSubscribe&lt;String&gt;() { @Override public void subscribe(ObservableEmitter&lt;String&gt; emitter) { } }).subscribe(new Observer&lt;String&gt;() { @Override public void onSubscribe(Disposable d) { } @Override public void onNext(String s) { } @Override public void onError(Throwable e) { } @Override public void onComplete() { } })// 伪代码Observable.create( ObservableOnSubscribe(ObservableEmitter -&gt; *) ){ ObservableCreate&lt;T&gt;(observableOnSubscribe) } .subscribe(Observer){ subscribeActual(observer){ parent = new CreateEmitter&lt;T&gt;(observer) observer.onSubscribe(parent); observableOnSubscribe.subscribe(parent); } } 12345678910111213141516171819202122232425262728293031323334353637383940414243// subscribeOn 是改变上流的线程调度，所以只有第一个 subscribeOn 是有用的// observeOn 是改变下流的线程调度，所以每一个 observeOn 对它下流的 操作都是有用的ObservableCreate subscribeActual(SubscribeOnObserver){ ObservableOnSubscribe.subscribe(observableEmitter) }ObservableSubscribeOn subscribeActual(ObserveOnObserver)ObservableObserveOn subscribeActual(MapObserver)ObservableMap subscribeActual(SubscribeOnObserver)ObservableSubscribeOn subscribeActual(ObserveOnObserver)ObservableObserveOn subscribeActual(MergeObserver)ObservableFlatMap subscribeActual(Observer)subscribe(Observer)Observable.create(...) .subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) .map(s -&gt; s + \"!\") .subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) .flatMap(Function&lt;String, ObservableSource&lt;String&gt;&gt;) s -&gt; Observable.just(s + \"!\")) .subscribe(new Observer&lt;String&gt;() { @Override public void onSubscribe(Disposable d) { } @Override public void onNext(String s) { } @Override public void onError(Throwable e) { } @Override public void onComplete() { } }); 参考资料： 图解 RxJava2 图解 RxJava2 - subscribeOn 响应式编程 - RxJava 高阶指南 拆轮子系列：RxJava ReactiveX/RxJava文档中文版 自己动手实现RxJava 给 Android 开发者的 RxJava 详解 RxJava2 只看这一篇文章就够了 响应式编程在Android 中的一些探索 关于RxJava最友好的文章——背压（Backpressure） 关于RxJava最友好的文章 响应式编程(Reactive Programming) 入门","link":"/2018/12/06/RxJava系列-一-入门/"},{"title":"RxJava详解","text":"RxJavaRxJava 到底是什么一个词：异步。 RxJava 在 GitHub 主页上的自我介绍是 “a library for composing asynchronous and event-based programs using observable sequences for the Java VM”（一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库）。这就是 RxJava ，概括得非常精准。 然而，对于初学者来说，这太难看懂了。因为它是一个『总结』，而初学者更需要一个『引言』。 其实， RxJava 的本质可以压缩为异步这一个词。说到根上，它就是一个实现异步操作的库，而别的定语都是基于这之上的。 RxJava 好在哪换句话说，『同样是做异步，为什么人们用它，而不用现成的 AsyncTask / Handler / XXX / … ？』 一个词：简洁。 异步操作很关键的一点是程序的简洁性，因为在调度过程比较复杂的情况下，异步代码经常会既难写也难被读懂。 Android 创造的 AsyncTask 和Handler ，其实都是为了让异步代码更加简洁。RxJava 的优势也是简洁，但它的简洁的与众不同之处在于，随着程序逻辑变得越来越复杂，它依然能够保持简洁。 API 介绍和原理简析1.概念：扩展的观察者模式RxJava 的异步实现，是通过一种扩展的观察者模式来实现的。 观察者模式观察者模式面向的需求是：A 对象(观察者)对 B 对象(被观察者)的某种变化高度敏感，需要在 B 变化的一瞬间做出反应。举个例子，新闻里喜闻乐见的警察抓小偷，警察需要在小偷伸手作案的时候实施抓捕。在这个例子里，警察是观察者，小偷是被观察者，警察需要时刻盯着小偷的一举一动，才能保证不会漏过任何瞬间。程序的观察者模式和这种真正的『观察』略有不同，观察者不需要时刻盯着被观察者( 例如 A 不需要每过 2ms 就检查一次 B 的状态)，而是采用注册 ( Register ) 或者称为订阅 ( Subscribe )的方式，告诉被观察者：我需要你的某某状态，你要在它变化的时候通知我。 Android 开发中一个比较典型的例子是点击监听器 OnClickListener 。对设置 OnClickListener 来说， View 是被观察者， OnClickListener 是观察者，二者通过 setOnClickListener() 方法达成订阅关系。订阅之后用户点击按钮的瞬间，Android Framework 就会将点击事件发送给已经注册的 OnClickListener 。采取这样被动的观察方式，既省去了反复检索状态的资源消耗，也能够得到最高的反馈速度。当然，这也得益于我们可以随意定制自己程序中的观察者和被观察者，而警察叔叔明显无法要求小偷『你在作案的时候务必通知我』。 OnClickListener 的模式大致如下图： 如图所示，通过 setOnClickListener() 方法，Button 持有 OnClickListener 的引用；当用户点击时，Button 调用 OnClickListener 的 onClick() 方法。另外，如果把这张图中的概念抽象出来（Button -&gt; 被观察者、OnClickListener -&gt; 观察者、setOnClickListener() -&gt; 订阅，onClick() -&gt; 事件），就由专用的观察者模式（例如只用于监听控件点击）转变成了通用的观察者模式。如下图： RxJava 的观察者模式RxJava 有四个基本概念：Onservable(被观察者)、Observer(观察者)、subscribe(订阅)、Event(事件)。Observable 和 Observer 通过 subscribe() 方法实现订阅关系，从而 Observable 可以在需要的时候发出 Event 来通知 Observer。 与传统观察者模式不同， RxJava 的事件回调方法除了普通事件 onNext() （相当于 onClick() / onEvent()）之外，还定义了两个特殊的事件：onCompleted() 和 onError()。 onCompleted(): 事件队列完结。RxJava 不仅把每个事件单独处理，还会把它们看做一个队列。RxJava 规定，当不会再有新的 onNext() 发出时，需要触发 onCompleted() 方法作为标志。 onError(): 事件队列异常。在事件处理过程中出异常时，onError() 会被触发，同时队列自动终止，不允许再有事件发出。 在一个正确运行的事件序列中, onCompleted() 和 onError() 有且只有一个，并且是事件序列中的最后一个。需要注意的是，onCompleted() 和 onError() 二者也是互斥的，即在队列中调用了其中一个，就不应该再调用另一个。 RxJava 的观察者模式大致如下图： 2. 基本实现基于以上的概念， RxJava 的基本实现主要有三点： 1) 创建 ObserverObserver 即观察者，它决定事件触发的时候将有怎样的行为。 RxJava 中的 Observer 接口的实现方式： 12345678910111213141516Observer&lt;String&gt; observer = new Observer&lt;String&gt;() { @Override public void onNext(String s) { Log.d(tag, \"Item: \" + s); } @Override public void onCompleted() { Log.d(tag, \"Completed!\"); } @Override public void onError(Throwable e) { Log.d(tag, \"Error!\"); }}; 除了 Observer 接口之外，RxJava 还内置了一个实现了 Observer 的抽象类：Subscriber。 Subscriber 对 Observer 接口进行了一些扩展，但他们的基本使用方式是完全一样的： 123456789101112131415161718192021Subscriber&lt;String&gt; subscriber = new Subscriber&lt;String&gt;() { @Override public void onSubscribe(Subscription s) { Log.d(tag, \"onSubscribe\"); } @Override public void onNext(String s) { Log.d(tag, \"Item: \" + s); } @Override public void onError(Throwable e) { Log.d(tag, \"Error!\"); } @Override public void onComplete() { Log.d(tag, \"Completed!\"); }}; 不仅基本使用方式一样，实质上，在 RxJava 的 subscribe 过程中，Observer 也总是会先被转换成一个 Subscriber 再使用。所以如果你只想使用基本功能，选择 Observer 和 Subscriber 是完全一样的。它们的区别对于使用者来说主要有： onSubscribe(): 这是 Subscriber 增加的方法。它会在 subscribe 刚开始，而事件还未发送之前被调用，可以用于做一些准备工作，例如数据的清零或重置。这是一个可选方法，默认情况下它的实现为空。需要注意的是，如果对准备工作的线程有要求（例如弹出一个显示进度的对话框，这必须在主线程执行）， onSubscribe() 就不适用了，因为它总是在 subscribe 所发生的线程被调用，而不能指定线程。要在指定的线程来做准备工作，可以使用 doOnSubscribe() 方法，具体可以在后面的文中看到。 2) 创建 ObservableObservable 即被观察者，它决定什么时候触发事件以及触发怎样的事件。 RxJava 使用 create() 方法来创建一个 Observable ，并为它定义事件触发规则： 123456789Observable observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() { @Override public void call(Subscriber&lt;? super String&gt; subscriber) { subscriber.onNext(\"Hello\"); subscriber.onNext(\"Hi\"); subscriber.onNext(\"Aloha\"); subscriber.onCompleted(); }}); 可以看到，这里传入了一个 OnSubscribe 对象作为参数。OnSubscribe 会被存储在返回的 Observable 对象中，它的作用相当于一个计划表，当 Observable 被订阅的时候，OnSubscribe 的 call() 方法会自动被调用，事件序列就会依照设定依次触发（对于上面的代码，就是观察者 Subscriber 将会被调用三次 onNext() 和一次 onCompleted()）。这样，由被观察者调用了观察者的回调方法，就实现了由被观察者向观察者的事件传递，即观察者模式。 这个例子很简单：事件的内容是字符串，而不是一些复杂的对象；事件的内容是已经定好了的，而不像有的观察者模式一样是待确定的（例如网络请求的结果在请求返回之前是未知的）；所有事件在一瞬间被全部发送出去，而不是夹杂一些确定或不确定的时间间隔或者经过某种触发器来触发的。总之，这个例子看起来毫无实用价值。但这是为了便于说明，实质上只要你想，各种各样的事件发送规则你都可以自己来写。至于具体怎么做，后面都会讲到，但现在不行。只有把基础原理先说明白了，上层的运用才能更容易说清楚。 create() 方法是 RxJava 最基本的创造事件序列的方法。基于这个方法， RxJava 还提供了一些方法用来快捷创建事件队列，例如： just(T...): 将传入的参数依次发送出来。 123456Observable observable = Observable.just(\"Hello\", \"Hi\", \"Aloha\");// 将会依次调用：// onNext(\"Hello\");// onNext(\"Hi\");// onNext(\"Aloha\");// onCompleted(); from(T[]) / from(Iterable&lt;? extends T&gt;) : 将传入的数组或 Iterable 拆分成具体对象后，依次发送出来。 1234567String[] words = {\"Hello\", \"Hi\", \"Aloha\"};Observable observable = Observable.from(words);// 将会依次调用：// onNext(\"Hello\");// onNext(\"Hi\");// onNext(\"Aloha\");// onCompleted(); 3) Subscribe (订阅)创建了 Observable 和 Observer 之后，再用 subscribe() 方法将它们联结起来，整条链子就可以工作了。代码形式很简单： 123observable.subscribe(observer);// 或者：observable.subscribe(subscriber); 有人可能会注意到， subscribe() 这个方法有点怪：它看起来是『observalbe 订阅了 observer / subscriber』而不是『observer / subscriber 订阅了 observalbe』，这看起来就像『杂志订阅了读者』一样颠倒了对象关系。这让人读起来有点别扭，不过如果把 API 设计成 observer.subscribe(observable) / subscriber.subscribe(observable) ，虽然更加符合思维逻辑，但对流式 API 的设计就造成影响了，比较起来明显是得不偿失的。 Observable.subscribe(Subscriber) 的内部实现是这样的（仅核心代码）： 1234567// 注意：这不是 subscribe() 的源码，而是将源码中与性能、兼容性、扩展性有关的代码剔除后的核心代码。// 如果需要看源码，可以去 RxJava 的 GitHub 仓库下载。public Subscription subscribe(Subscriber subscriber) { subscriber.onStart(); onSubscribe.call(subscriber); return subscriber;} 可以看到，subscriber() 做了3件事： 调用 Subscriber.onStart() 。这个方法在前面已经介绍过，是一个可选的准备方法。 调用 Observable 中的 OnSubscribe.call(Subscriber) 。在这里，事件发送的逻辑开始运行。从这也可以看出，在 RxJava 中， Observable 并不是在创建的时候就立即开始发送事件，而是在它被订阅的时候，即当 subscribe() 方法执行的时候。 将传入的 Subscriber 作为 Subscription 返回。这是为了方便 unsubscribe(). 整个过程中对象间的关系如下图： 或者可以看动图： 4) 场景示例a. 打印字符串数组 将字符串数组 names 中的所有字符串依次打印出来： 12345678String[] names = ...;Observable.from(names) .subscribe(new Action1&lt;String&gt;() { @Override public void call(String name) { Log.d(tag, name); } }); b. 由 id 取得图片并显示 由指定的一个 drawable 文件 id drawableRes 取得图片，并显示在 ImageView 中，并在出现异常的时候打印 Toast 报错： 12345678910111213141516171819202122232425int drawableRes = ...;ImageView imageView = ...;Observable.create(new OnSubscribe&lt;Drawable&gt;() { @Override public void call(Subscriber&lt;? super Drawable&gt; subscriber) { Drawable drawable = getTheme().getDrawable(drawableRes)); subscriber.onNext(drawable); subscriber.onCompleted(); }}).subscribe(new Observer&lt;Drawable&gt;() { @Override public void onNext(Drawable drawable) { imageView.setImageDrawable(drawable); } @Override public void onCompleted() { } @Override public void onError(Throwable e) { Toast.makeText(activity, \"Error!\", Toast.LENGTH_SHORT).show(); }}); 注意：在 RxJava 的默认规则中，事件的发出和消费都是在同一个线程的。也就是说，如果只用上面的方法，实现出来的只是一个同步的观察者模式。观察者模式本身的目的就是『后台处理，前台回调』的异步机制，因此异步对于 RxJava 是至关重要的。而要实现异步，则需要用到 RxJava 的另一个概念：Scheduler 。 3. 线程控制 —— Scheduler (一)在不指定线程的情况下， RxJava 遵循的是线程不变的原则，即：在哪个线程调用 subscribe()，就在哪个线程生产事件；在哪个线程生产事件，就在哪个线程消费事件。如果需要切换线程，就需要用到 Scheduler （调度器）。 Scheduler 的 API在RxJava 中，Scheduler ——调度器，相当于线程控制器，RxJava 通过它来指定每一段代码应该运行在什么样的线程。RxJava 已经内置了几个 Scheduler ，它们已经适合大多数的使用场景： Schedulers.immediate(): 直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。 Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。 Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。 Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。 另外， Android 还有一个专用的 AndroidSchedulers.mainThread()，它指定的操作将在 Android 主线程运行。 有了这几个 Scheduler ，就可以使用 subscribeOn() 和 observeOn() 两个方法来对线程进行控制了。 subscribeOn(): 指定 subscribe() 所发生的线程，即 Observable.OnSubscribe 被激活时所处的线程。或者叫做事件产生的线程。 observeOn(): 指定 Subscriber 所运行在的线程。或者叫做事件消费的线程。 12345678910Observable.just(1, 2, 3, 4) .subscribeOn(Schedulers.io()) // 指定 subscribe() 发生在 IO 线程 .observeOn(AndroidSchedulers.mainThread()) // 指定 Subscriber 的回调发生在主线程 .subscribe(new Action1&lt;Integer&gt;() { @Override public void call(Integer number) { Log.d(TAG, \"number: \" + number); Log.d(TAG, \"Thread: \" + Thread.currentThread()); } }); 4. 变换RxJava 提供了对事件序列进行变换的支持，这是它的核心功能之一，也是大多数人说『RxJava 真是太好用了』的最大原因。所谓变换，就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列。概念说着总是模糊难懂的，来看 API。 1) API首先看一个 map() 的例子： 12345678910111213Observable.just(\"images/logo.png\") // 输入类型 String .map(new Func1&lt;String, Bitmap&gt;() { @Override public Bitmap call(String filePath) { // 参数类型 String return getBitmapFromPath(filePath); // 返回类型 Bitmap } }) .subscribe(new Action1&lt;Bitmap&gt;() { @Override public void call(Bitmap bitmap) { // 参数类型 Bitmap showBitmap(bitmap); } }); map(): 事件对象的直接变换，具体功能上面已经介绍过。它是 RxJava 最常用的变换。 map() 的示意图： flatMap(): 这是一个很有用但非常难理解的变换，因此我决定花多些篇幅来介绍它。 首先假设这么一种需求：假设有一个数据结构『学生』，现在需要打印出一组学生的名字。实现方式很简单： 12345678910111213141516Student[] students = ...;Subscriber&lt;String&gt; subscriber = new Subscriber&lt;String&gt;() { @Override public void onNext(String name) { Log.d(tag, name); } ...};Observable.from(students) .map(new Func1&lt;Student, String&gt;() { @Override public String call(Student student) { return student.getName(); } }) .subscribe(subscriber); 很简单。那么再假设：如果要打印出每个学生所需要修的所有课程的名称呢？（需求的区别在于，每个学生只有一个名字，但却有多个课程。）首先可以这样实现： 1234567891011121314Student[] students = ...;Subscriber&lt;Student&gt; subscriber = new Subscriber&lt;Student&gt;() { @Override public void onNext(Student student) { List&lt;Course&gt; courses = student.getCourses(); for (int i = 0; i &lt; courses.size(); i++) { Course course = courses.get(i); Log.d(tag, course.getName()); } } ...};Observable.from(students) .subscribe(subscriber); 依然很简单。那么如果我不想在 Subscriber 中使用 for 循环，而是希望 Subscriber 中直接传入单个的 Course 对象呢（这对于代码复用很重要）？用 map() 显然是不行的，因为 map() 是一对一的转化，而我现在的要求是一对多的转化。那怎么才能把一个 Student 转化成多个 Course 呢？ 这个时候，就需要用 flatMap() 了： 12345678910111213141516Student[] students = ...;Subscriber&lt;Course&gt; subscriber = new Subscriber&lt;Course&gt;() { @Override public void onNext(Course course) { Log.d(tag, course.getName()); } ...};Observable.from(students) .flatMap(new Func1&lt;Student, Observable&lt;Course&gt;&gt;() { @Override public Observable&lt;Course&gt; call(Student student) { return Observable.from(student.getCourses()); } }) .subscribe(subscriber); 12345678910111213141516//RxJava2Flowable.fromIterable(students) .flatMap(new Function&lt;Student, Publisher&lt;?&gt;&gt;() { @Override public Publisher&lt;?&gt; apply(Student student) throws Exception { return Flowable.fromIterable(student.mSources); } }) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;Object&gt;() { @Override public void accept(Object o) throws Exception { Log.d(TAG, \"accept: \" + ((Cource) o).name); } }); 从上面的代码可以看出， flatMap() 和 map() 有一个相同点：它也是把传入的参数转化之后返回另一个对象。但需要注意，和 map() 不同的是， flatMap() 中返回的是个 Observable 对象，并且这个 Observable 对象并不是被直接发送到了 Subscriber 的回调方法中。 flatMap() 的原理是这样的： 使用传入的事件对象创建一个 Observable 对象； 并不发送这个 Observable, 而是将它激活，于是它开始发送事件； 每一个创建出来的 Observable 发送的事件，都被汇入同一个 Observable ，而这个 Observable 负责将这些事件统一交给 Subscriber 的回调方法。这三个步骤，把事件拆成了两级，通过一组新创建的 Observable 将初始的对象『铺平』之后通过统一路径分发了下去。而这个『铺平』就是 flatMap() 所谓的 flat。 flatMap() 示意图： 5. 线程控制：Scheduler (二)1) Scheduler 的 API (二)前面讲到了，可以利用 subscribeOn() 结合 observeOn() 来实现线程控制，让事件的产生和消费发生在不同的线程。可是在了解了 map() flatMap() 等变换方法后，有些好事的（其实就是当初刚接触 RxJava 时的我）就问了：能不能多切换几次线程？ 答案是：能。因为 observeOn() 指定的是 Subscriber 的线程，而这个 Subscriber 并不是（严格说应该为『不一定是』，但这里不妨理解为『不是』）subscribe() 参数中的 Subscriber ，而是 observeOn() 执行时的当前 Observable 所对应的 Subscriber ，即它的直接下级 Subscriber 。换句话说，observeOn() 指定的是它之后的操作所在的线程。因此如果有多次切换线程的需求，只要在每个想要切换线程的位置调用一次 observeOn() 即可。上代码： 12345678Observable.just(1, 2, 3, 4) // IO 线程，由 subscribeOn() 指定 .subscribeOn(Schedulers.io()) .observeOn(Schedulers.newThread()) .map(mapOperator) // 新线程，由 observeOn() 指定 .observeOn(Schedulers.io()) .map(mapOperator2) // IO 线程，由 observeOn() 指定 .observeOn(AndroidSchedulers.mainThread) .subscribe(subscriber); // Android 主线程，由 observeOn() 指定 如上，通过 observeOn() 的多次调用，程序实现了线程的多次切换。 不过，不同于 observeOn() ， subscribeOn() 的位置放在哪里都可以，但它是只能调用一次的。 2) Scheduler 的原理（二）其实， subscribeOn() 和 observeOn() 的内部实现，也是用的 lift()。具体看图（不同颜色的箭头表示不同的线程）： subscribeOn() 原理图： observeOn() 原理图： 从图中可以看出，subscribeOn() 和 observeOn() 都做了线程切换的工作（图中的 “schedule…” 部位）。不同的是， subscribeOn() 的线程切换发生在 OnSubscribe 中，即在它通知上一级 OnSubscribe 时，这时事件还没有开始发送，因此 subscribeOn() 的线程控制可以从事件发出的开端就造成影响；而 observeOn() 的线程切换则发生在它内建的 Subscriber 中，即发生在它即将给下一级 Subscriber 发送事件时，因此 observeOn() 控制的是它后面的线程。 最后，我用一张图来解释当多个 subscribeOn() 和 observeOn() 混合使用时，线程调度是怎么发生的（由于图中对象较多，相对于上面的图对结构做了一些简化调整）： 图中共有 5 处含有对事件的操作。由图中可以看出，①和②两处受第一个 subscribeOn() 影响，运行在红色线程；③和④处受第一个 observeOn() 的影响，运行在绿色线程；⑤处受第二个 onserveOn() 影响，运行在紫色线程；而第二个 subscribeOn() ，由于在通知过程中线程就被第一个 subscribeOn() 截断，因此对整个流程并没有任何影响。这里也就回答了前面的问题：当使用了多个 subscribeOn() 的时候，只有第一个 subscribeOn() 起作用。 链接Github 源码地址： RxJava RxAndroid 引入依赖： implementation &quot;io.reactivex.rxjava2:rxjava:2.1.7&quot; implementation 'io.reactivex.rxjava2:rxandroid:2.0.2' 参考资料： 给 Android 开发者的 RxJava 详解 RxJava 操作符flatMap 与 concatMap详解 Rxjava2的学习与总结 ReactiveX/RxJava文档中文版","link":"/2018/02/26/RxJava详解/"},{"title":"Glide 源码解析 一","text":"前言在众多的图片加载框架中，Glide 是 Google 推荐的，并在自家的项目中大量使用的一个非常强大的框架，专注于平滑滚动，并且还提供 Gif，本地 Vedio 首帧的解码和显示。Glide 提供了非常便捷的链式调用接口，以及丰富的拓展和自定义功能，开发者可以非常简单地对框架进行配置和图片再加工。 如今 Gilde 已经更新到4.x，了解其源码对更好的使用 Glide ，以及学习相关的图片处理技术，学习更优雅的编码会有很大的帮助。 不得不说，Glide 整个框架的极其复杂的，特别是在对资源的转换和解码过程中，涉及了许多的嵌套循环，同时也使用了大量的工厂模式用于生产转换模块，编码模块，解码模块等，笔者在阅读过程中，多次迷失在茫茫的代码流中。 为此，萌生了将对 Glide 的理解记录成文的想法，借以理清思路。 那么接下来，我们就先看看 Glide 是如何进行框架初始化的。 探究Glide.with发生了什么？1. Glide单例的加载使用过 Glide 的都知道，调用 Glide 加载一张图片时，第一句代码便是 Glide.with(this)，这里肯定就是 Glide 的入口了，通过这句代码，Glide 开始了“漫漫的”初始化之路。 Glide 重载了多个 with 的方法，分别用于不同的情境下使用，我们看其中最常用的在 Activity 中调用的方法，即 1234@NonNullpublic static RequestManager with(@NonNull Activity activity) { return getRetriever(activity).get(activity);} 首先，跟进 getRetriever(activity) 1234567891011@NonNullprivate static RequestManagerRetriever getRetriever(@Nullable Context context) { // Context could be null for other reasons (ie the user passes in null), but in practice it will // only occur due to errors with the Fragment lifecycle. Preconditions.checkNotNull( context, \"You cannot start a load on a not yet attached View or a Fragment where getActivity() \" + \"returns null (which usually occurs when getActivity() is called before the Fragment \" + \"is attached or after the Fragment is destroyed).\"); return Glide.get(context).getRequestManagerRetriever();} 这里首先检查了 context 是否为空，如果为 null，抛出异常。 我们重点来看 Glide.get(context) 123456789101112@NonNullpublic static Glide get(@NonNull Context context) { if (glide == null) { synchronized (Glide.class) { if (glide == null) { checkAndInitializeGlide(context); } } } return glide;} 这里是一个典型的双检锁单例模式。 继续跟进 checkAndInitialzeGlide(context) 123456789101112131415private static void checkAndInitializeGlide(@NonNull Context context) { // In the thread running initGlide(), one or more classes may call Glide.get(context). // Without this check, those calls could trigger infinite recursion. if (isInitializing) { throw new IllegalStateException(\"You cannot call Glide.get() in registerComponents(),\" + \" use the provided Glide instance instead\"); } isInitializing = true; initializeGlide(context); isInitializing = false;}private static void initializeGlide(@NonNull Context context) { initializeGlide(context, new GlideBuilder());} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@SuppressWarnings(\"deprecation\")private static void initializeGlide(@NonNull Context context, @NonNull GlideBuilder builder) { Context applicationContext = context.getApplicationContext(); // 获取注解的 module GeneratedAppGlideModule annotationGeneratedModule = getAnnotationGeneratedGlideModules(); List&lt;com.bumptech.glide.module.GlideModule&gt; manifestModules = Collections.emptyList(); if (annotationGeneratedModule == null || annotationGeneratedModule.isManifestParsingEnabled()) { // AndroidMenifest.xml 中注册的 module manifestModules = new ManifestParser(applicationContext).parse(); } // 移除相同的GlideModule if (annotationGeneratedModule != null &amp;&amp; !annotationGeneratedModule.getExcludedModuleClasses().isEmpty()) { Set&lt;Class&lt;?&gt;&gt; excludedModuleClasses = annotationGeneratedModule.getExcludedModuleClasses(); Iterator&lt;com.bumptech.glide.module.GlideModule&gt; iterator = manifestModules.iterator(); while (iterator.hasNext()) { com.bumptech.glide.module.GlideModule current = iterator.next(); if (!excludedModuleClasses.contains(current.getClass())) { continue; } iterator.remove(); } } if (Log.isLoggable(TAG, Log.DEBUG)) { for (com.bumptech.glide.module.GlideModule glideModule : manifestModules) { Log.d(TAG, \"Discovered GlideModule from manifest: \" + glideModule.getClass()); } } RequestManagerRetriever.RequestManagerFactory factory = annotationGeneratedModule != null ? annotationGeneratedModule.getRequestManagerFactory() : null; builder.setRequestManagerFactory(factory); for (com.bumptech.glide.module.GlideModule module : manifestModules) { module.applyOptions(applicationContext, builder); } if (annotationGeneratedModule != null) { annotationGeneratedModule.applyOptions(applicationContext, builder); } Glide glide = builder.build(applicationContext); for (com.bumptech.glide.module.GlideModule module : manifestModules) { module.registerComponents(applicationContext, glide, glide.registry); } if (annotationGeneratedModule != null) { annotationGeneratedModule.registerComponents(applicationContext, glide, glide.registry); } applicationContext.registerComponentCallbacks(glide); Glide.glide = glide;} 留意最后将初始化得到的glide赋值给了Glide.glide的单例。 接下里就来看看在这初始化方法中，Glide都加载了哪些配置。 2. GlideModule配置加载在使用 Glide 的时候，我们都会有一些想要设置的系统级配置，如设置缓存的存储位置，缓存区的大小，网络加载模块等等，那么我们通常就是使用 GldieModule 进行配置。在 Glide3.x 中，我们首先会定义一个继承于 GlideModule 的类，然后在项目的 AndroidMenifest.xml 中进行指定： 12&lt;meta-data android:name=\"com.test.GlideConfiguration\" android:value=\"GlideModule\"/&gt; 而在 Glide4 中，提供另外一个配置的模式，那就是注解，并且不再继承 GlideModule ，而是继承 AppGlideModule 和 LibraryGlideModule，分别对应 Application 和 Library，使用 @GlideModule 注解进行标记。而 Glide3.x 中的配置方式已经建议放弃使用。示例如下： 12345678@GlideModulepublic class GlideConfiguration extends AppGlideModule { @Override public void applyOptions(Context context, GlideBuilder builder) { //设置缓存到外部存储器 builder.setDiskCache(new ExternalPreferredCacheDiskCacheFactory(context)); }} Glide 是如何对 GlideModule 的配置进行初始化的呢？ 123456789101112131415161718192021Context applicationContext = context.getApplicationContext();GeneratedAppGlideModule annotationGeneratedModule = getAnnotationGeneratedGlideModules();List&lt;com.bumptech.glide.module.GlideModule&gt; manifestModules = Collections.emptyList();if (annotationGeneratedModule == null || annotationGeneratedModule.isManifestParsingEnabled()) { manifestModules = new ManifestParser(applicationContext).parse();}if (annotationGeneratedModule != null &amp;&amp; !annotationGeneratedModule.getExcludedModuleClasses().isEmpty()) { Set&lt;Class&lt;?&gt;&gt; excludedModuleClasses = annotationGeneratedModule.getExcludedModuleClasses(); Iterator&lt;com.bumptech.glide.module.GlideModule&gt; iterator = manifestModules.iterator(); while (iterator.hasNext()) { com.bumptech.glide.module.GlideModule current = iterator.next(); if (!excludedModuleClasses.contains(current.getClass())) { continue; } iterator.remove(); }} 第二行代码中，getAnnotationGeneratedGlideModules() 会获取 Glide 注解自动生产的一个 Glide 的 Module 配置器。如下： 12345678910111213141516171819202122232425262728@Nullable@SuppressWarnings({\"unchecked\", \"deprecation\", \"TryWithIdenticalCatches\"})private static GeneratedAppGlideModule getAnnotationGeneratedGlideModules() { GeneratedAppGlideModule result = null; try { Class&lt;GeneratedAppGlideModule&gt; clazz = (Class&lt;GeneratedAppGlideModule&gt;) Class.forName(\"com.bumptech.glide.GeneratedAppGlideModuleImpl\"); result = clazz.getDeclaredConstructor().newInstance(); } catch (ClassNotFoundException e) { if (Log.isLoggable(TAG, Log.WARN)) { Log.w(TAG, \"Failed to find GeneratedAppGlideModule. You should include an\" + \" annotationProcessor compile dependency on com.github.bumptech.glide:compiler\" + \" in your application and a @GlideModule annotated AppGlideModule implementation or\" + \" LibraryGlideModules will be silently ignored\"); } // These exceptions can't be squashed across all versions of Android. } catch (InstantiationException e) { throwIncorrectGlideModule(e); } catch (IllegalAccessException e) { throwIncorrectGlideModule(e); } catch (NoSuchMethodException e) { throwIncorrectGlideModule(e); } catch (InvocationTargetException e) { throwIncorrectGlideModule(e); } return result;} 其中 com.bumptech.glide.GeneratedAppGlideModuleImpl 是在编译时由 Glide 生成的一个类，主要用于过滤不必要的 GlideModule ，以及提供一个请求检索器工厂，这个后面会讲到。 接下生成一个 Manifest 解析器 ManifestParser ，用于获取配置的 GlideModule ，并存放在 manifestModules 中。然后是一个判断 1234if (annotationGeneratedModule != null &amp;&amp; !annotationGeneratedModule.getExcludedModuleClasses().isEmpty()) { ......} 如果条件成立，即编译时自动生成的类中，包含了需要排除的 GlideModule ，逐个将其移除。 接着以上代码，Glide 将逐个调用剩下的 GlideModule ，并回调 applyOptions 和 registerComponents 接口，这时，用户配置的 GlideModule 就会被调用，同时用户设置的参数也就被配置到 Glide 中。 12345678910111213141516171819202122232425RequestManagerRetriever.RequestManagerFactory factory = annotationGeneratedModule != null ? annotationGeneratedModule.getRequestManagerFactory() : null;builder.setRequestManagerFactory(factory);// 逐个回调用户配置的 GlideModulefor (com.bumptech.glide.module.GlideModule module : manifestModules) { module.applyOptions(applicationContext, builder);}// 回调注释标记的 AppGlideModuleif (annotationGeneratedModule != null) { annotationGeneratedModule.applyOptions(applicationContext, builder);}// 构造 Glide 实例Glide glide = builder.build(applicationContext);for (com.bumptech.glide.module.GlideModule module : manifestModules) { module.registerComponents(applicationContext, glide, glide.registry);}if (annotationGeneratedModule != null) { annotationGeneratedModule.registerComponents(applicationContext, glide, glide.registry);}applicationContext.registerComponentCallbacks(glide);Glide.glide = glide; 在以上代码中，发现一句代码，在回调 registerComponents 前，首先构建了 glide 的实例。 1Glide glide = builder.build(applicationContext); 3. GlideBuilder构建Glide单例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115@NonNullGlide build(@NonNull Context context) { /* * 建立资源加载请求器，实际上是一个线程池， * 用于加载 URL 或者本地资源，即加载源数据 */ if (sourceExecutor == null) { sourceExecutor = GlideExecutor.newSourceExecutor(); } /* * 建立本地缓存资源加载请求器，也是一个线程池 * 用于加载缓存在磁盘中的数据 * 并且这个线程池不能用于加载 url 网络数据 */ if (diskCacheExecutor == null) { diskCacheExecutor = GlideExecutor.newDiskCacheExecutor(); } /* * 建立动画加载请求器，也是线程池 */ if (animationExecutor == null) { animationExecutor = GlideExecutor.newAnimationExecutor(); } /* * 内存计算器 */ if (memorySizeCalculator == null) { memorySizeCalculator = new MemorySizeCalculator.Builder(context).build(); } /* * 网络链接状态检测器工厂， * 用于监听网络状态 */ if (connectivityMonitorFactory == null) { connectivityMonitorFactory = new DefaultConnectivityMonitorFactory(); } /* * 建立 bitmap 资源缓存池， * 该缓存主要用于 bitmap 资源的缓存和回收， * 避免由于大量创建和回收 bitmap 导致内存抖动 */ if (bitmapPool == null) { int size = memorySizeCalculator.getBitmapPoolSize(); if (size &gt; 0) { bitmapPool = new LruBitmapPool(size); } else { bitmapPool = new BitmapPoolAdapter(); } } /* * 数组资源缓存池 */ if (arrayPool == null) { arrayPool = new LruArrayPool(memorySizeCalculator.getArrayPoolSizeInBytes()); } /* * 内存缓存，用于缓存完成加载和显示的图片数据资源 */ if (memoryCache == null) { memoryCache = new LruResourceCache(memorySizeCalculator.getMemoryCacheSize()); } /* * 本地磁盘缓存器，默认为存储在 app 内部私密目录 */ if (diskCacheFactory == null) { diskCacheFactory = new InternalCacheDiskCacheFactory(context); } /* * 创建图片加载引擎，用于执行图片加载请求驱动 */ if (engine == null) { engine = new Engine( memoryCache, diskCacheFactory, diskCacheExecutor, sourceExecutor, GlideExecutor.newUnlimitedSourceExecutor(), GlideExecutor.newAnimationExecutor(), isActiveResourceRetentionAllowed); } /* * 建立请求索引器 */ RequestManagerRetriever requestManagerRetriever = new RequestManagerRetriever(requestManagerFactory); /* * 创建 Glide */ return new Glide( context, engine, memoryCache, bitmapPool, arrayPool, requestManagerRetriever, connectivityMonitorFactory, logLevel, defaultRequestOptions.lock(), defaultTransitionOptions);} 通过以上一系列工具的新建，Glide 建立了资源请求线程池，本地缓存加载线程池，动画线程池，内存缓存器，磁盘缓存工具等等，接着构造了 Engine 数据加载引擎，最后再将 Engine 注入 Glide ，构建 Glide 。 其中还建立了一个请求器索引器，用于索引 RequestManger ，后面我们再详细讲。 我们进入最后, 构建 Glide 。 4. 构建Glide，配置数据转换器/解码器/转码器/编码器回到 Glide 中，看看 Glide 的构造函数，这是一个长得变态的构造函数（有200行），但是不必被它吓倒（好吧，其实第一次看到这里，我是被吓倒了，直接略过去了，限于文章篇幅，这里只截取了部分源码，仔细的话可以直接看源码），仔细分析一下，其实整个构造过程并没那么复杂。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120Glide( @NonNull Context context, @NonNull Engine engine, @NonNull MemoryCache memoryCache, @NonNull BitmapPool bitmapPool, @NonNull ArrayPool arrayPool, @NonNull RequestManagerRetriever requestManagerRetriever, @NonNull ConnectivityMonitorFactory connectivityMonitorFactory, int logLevel, @NonNull RequestOptions defaultRequestOptions, @NonNull Map&lt;Class&lt;?&gt;, TransitionOptions&lt;?, ?&gt;&gt; defaultTransitionOptions) { // 步骤1：赋值 GlideBuilder 注入的工具 this.engine = engine; this.bitmapPool = bitmapPool; this.arrayPool = arrayPool; this.memoryCache = memoryCache; this.requestManagerRetriever = requestManagerRetriever; this.connectivityMonitorFactory = connectivityMonitorFactory; DecodeFormat decodeFormat = defaultRequestOptions.getOptions().get(Downsampler.DECODE_FORMAT); bitmapPreFiller = new BitmapPreFiller(memoryCache, bitmapPool, decodeFormat); final Resources resources = context.getResources(); // 步骤2：新建注册器 registry = new Registry(); registry.register(new DefaultImageHeaderParser()); // 步骤3：构建编码器和解码器 Downsampler downsampler = new Downsampler(registry.getImageHeaderParsers(), resources.getDisplayMetrics(), bitmapPool, arrayPool); ByteBufferGifDecoder byteBufferGifDecoder = new ByteBufferGifDecoder(context, registry.getImageHeaderParsers(), bitmapPool, arrayPool); ResourceDecoder&lt;ParcelFileDescriptor, Bitmap&gt; parcelFileDescriptorVideoDecoder = VideoDecoder.parcel(bitmapPool); ByteBufferBitmapDecoder byteBufferBitmapDecoder = new ByteBufferBitmapDecoder(downsampler); StreamBitmapDecoder streamBitmapDecoder = new StreamBitmapDecoder(downsampler, arrayPool); ResourceDrawableDecoder resourceDrawableDecoder = new ResourceDrawableDecoder(context); ResourceLoader.StreamFactory resourceLoaderStreamFactory = new ResourceLoader.StreamFactory(resources); ResourceLoader.UriFactory resourceLoaderUriFactory = new ResourceLoader.UriFactory(resources); ResourceLoader.FileDescriptorFactory resourceLoaderFileDescriptorFactory = new ResourceLoader.FileDescriptorFactory(resources); ResourceLoader.AssetFileDescriptorFactory resourceLoaderAssetFileDescriptorFactory = new ResourceLoader.AssetFileDescriptorFactory(resources); BitmapEncoder bitmapEncoder = new BitmapEncoder(arrayPool); BitmapBytesTranscoder bitmapBytesTranscoder = new BitmapBytesTranscoder(); GifDrawableBytesTranscoder gifDrawableBytesTranscoder = new GifDrawableBytesTranscoder(); ContentResolver contentResolver = context.getContentResolver(); // 步骤4：开始注册各个类型对应的解码器和编码器 省略部分代码 registry .append(ByteBuffer.class, new ByteBufferEncoder()) .append(InputStream.class, new StreamEncoder(arrayPool)) /* Bitmaps */ .append(Registry.BUCKET_BITMAP, ByteBuffer.class, Bitmap.class, byteBufferBitmapDecoder) .append(Registry.BUCKET_BITMAP, InputStream.class, Bitmap.class, streamBitmapDecoder) /* BitmapDrawables */ .append( Registry.BUCKET_BITMAP_DRAWABLE, ByteBuffer.class, BitmapDrawable.class, new BitmapDrawableDecoder&lt;&gt;(resources, byteBufferBitmapDecoder)) /* GIFs */ .append( Registry.BUCKET_GIF, InputStream.class, GifDrawable.class, new StreamGifDecoder(registry.getImageHeaderParsers(), byteBufferGifDecoder, arrayPool)) .append(Registry.BUCKET_GIF, ByteBuffer.class, GifDrawable.class, byteBufferGifDecoder) .append(GifDrawable.class, new GifDrawableEncoder()) /* GIF Frames */ // Compilation with Gradle requires the type to be specified for UnitModelLoader here. .append( GifDecoder.class, GifDecoder.class, UnitModelLoader.Factory.&lt;GifDecoder&gt;getInstance()) .append( Registry.BUCKET_BITMAP, GifDecoder.class, Bitmap.class, new GifFrameResourceDecoder(bitmapPool)) /* Drawables */ .append(Uri.class, Drawable.class, resourceDrawableDecoder) .append( Uri.class, Bitmap.class, new ResourceBitmapDecoder(resourceDrawableDecoder, bitmapPool)) /* Files */ .register(new ByteBufferRewinder.Factory()) .append(File.class, ByteBuffer.class, new ByteBufferFileLoader.Factory()) // Compilation with Gradle requires the type to be specified for UnitModelLoader here. .append(File.class, File.class, UnitModelLoader.Factory.&lt;File&gt;getInstance()) /* Models */ .register(new InputStreamRewinder.Factory(arrayPool)) .append(int.class, InputStream.class, resourceLoaderStreamFactory) /* Transcoders */ .register( Bitmap.class, BitmapDrawable.class, new BitmapDrawableTranscoder(resources)) .register(Bitmap.class, byte[].class, bitmapBytesTranscoder); // 步骤5：新建图片显示目标对象工厂，并构建 Glide 上下文 ImageViewTargetFactory imageViewTargetFactory = new ImageViewTargetFactory(); glideContext = new GlideContext( context, arrayPool, registry, imageViewTargetFactory, defaultRequestOptions, defaultTransitionOptions, engine, logLevel);} 其中最重要的是步骤3和步骤4，分别为 Glide 初始化了模型转换加载器，解码器，转码器，编码器，并将对各种类型进行一一注册，将其列成表格如下： 模型转换器 转换器 功能 ResourceLoader.StreamFactory 将Android资源ID转换为Uri，在加载成为InputStream ResourceLoader.UriFactory 将资源ID转换为Uri ResourceLoader.FileDescriptorFactory 将资源ID转化为ParcelFileDescriptor ResourceLoader.AssetFileDescriptorFactory 将资源ID转化为AssetFileDescriptor UnitModelLoader.Factory 不做任何转换，返回源数据 ByteBufferFileLoader.Factory 将File转换为ByteBuffer FileLoader.StreamFactory 将File转换为InputStream FileLoader.FileDescriptorFactory 将File转化为ParcelFileDescriptor DataUrlLoader.StreamFactory 将Url转化为InputStream … … 解码器 解码器 功能 ByteBufferGifDecoder 将ByteBuffer解码为GifDrawable ByteBufferBitmapDecoder 将ByteBuffer解码为Bitmap ResourceDrawableDecoder 将资源Uri解码为Drawable ResourceBitmapDecoder 将资源ID解码为Bitmap BitmapDrawableDecoder 将数据解码为BitmapDrawable StreamBitmapDecoder 将InputStreams解码为Bitmap StreamGifDecoder 将InputStream数据转换为BtyeBuffer，再解码为GifDrawable GifFrameResourceDecoder 解码gif帧 FileDecoder 包装File成为FileResource … … 转码器 转码器 功能 BitmapDrawableTranscoder 将Bitmap转码为BitmapDrawable BitmapBytesTranscoder 将Bitmap转码为Byte arrays DrawableBytesTranscoder 将BitmapDrawable转码为Byte arrays GifDrawableBytesTranscoder 将GifDrawable转码为Byte arrays 编码器 编码器 功能 ByteBufferEncoder 将Byte数据缓存为File StreamEncoder InputStream缓存为File BitmapEncoder 将Bitmap数据缓存为File BitmapDrawableEncoder 将BitmapDrawable数据缓存为File GifDrawableEncoder 将GifDrawable数据缓存为File 模型转换注册表（实在太多，只列出了部分） 源数据 转换数据 转换器 Integer.class InputStream.class ResourceLoader.StreamFactory String.class InputStream.class DataUrlLoader.StreamFactory Uri.class InputStream.class DataUrlLoader.StreamFactory … … … 以上模型转换注册表非常重要，在Glide进入解码流程时，将会遍历这里注册的所有可能转换的情形，尝试进行数据转换。 这里只列出部分情形，其它还包括 File/Bitmap/Drawable/Byte 等等几乎涵括了日常使用的情况。 Glide的加载流程可以概括为以下流程： model(数据源)--&gt;data(转换数据)--&gt;decode(解码)--&gt;transformed(缩放)--&gt;transcoded(转码)--&gt;encoded(编码保存到本地) 其中，transformed 为对解码得到的图片数据进行缩放，如 FitCenter、CropCenter 等。 到这里，Glide 单例就构建完成了，让我们返回到 Glide#with 中 1234567891011121314151617@NonNullpublic static RequestManager with(@NonNull FragmentActivity activity) { return getRetriever(activity).get(activity);}@NonNullprivate static RequestManagerRetriever getRetriever(@Nullable Context context) { // Context could be null for other reasons (ie the user passes in null), but in practice it will // only occur due to errors with the Fragment lifecycle. Preconditions.checkNotNull( context, \"You cannot start a load on a not yet attached View or a Fragment where getActivity() \" + \"returns null (which usually occurs when getActivity() is called before the Fragment \" + \"is attached or after the Fragment is destroyed).\"); return Glide.get(context).getRequestManagerRetriever();} 在构建好 Glide 后，通过 getRequestManagerRetriever() 将会得到一个 RequestManagerRetriever ，即 RequestManager 的检索器，RequestManagerRetriever#get() 将为每个请求页面创建一个 RequestManager。 还记得 GlideBuilder#build 提到的一句代码吗？12RequestManagerRetriever requestManagerRetriever = new RequestManagerRetriever(requestManagerFactory); 没错，这里获取的就是它。这里就必须要讲到 Glide 数据请求的生命周期了。 我们都知道 Glide 会根据页面的生命周期来自动的开启和结束数据的请求，那么 Glide 是怎么做到的呢？ 5. 生命周期管理我们进入 RequestManagerRetriever#get(Activity) 方法中。 123456789101112@SuppressWarnings(\"deprecation\")@NonNullpublic RequestManager get(@NonNull Activity activity) { if (Util.isOnBackgroundThread()) { return get(activity.getApplicationContext()); } else { assertNotDestroyed(activity); android.app.FragmentManager fm = activity.getFragmentManager(); return fragmentGet( activity, fm, /*parentHint=*/ null, isActivityVisible(activity)); }} 首先，判断是否为后台线程，如果是，则使用 ApplicationContext 重新获取。重点来看 else 代码块。先断言请求的页面是否已经销毁。否则获取当前页面的 FragmentManager，并传给 fragmentGet 方法。 12345678910111213141516171819202122232425@SuppressWarnings({\"deprecation\", \"DeprecatedIsStillUsed\"})@Deprecated@NonNullprivate RequestManager fragmentGet(@NonNull Context context, @NonNull android.app.FragmentManager fm, @Nullable android.app.Fragment parentHint, boolean isParentVisible) { RequestManagerFragment current = getRequestManagerFragment(fm, parentHint, isParentVisible); RequestManager requestManager = current.getRequestManager(); if (requestManager == null) { // TODO(b/27524013): Factor out this Glide.get() call. Glide glide = Glide.get(context); requestManager = factory.build( glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context); current.setRequestManager(requestManager); } return requestManager;}@NonNullSupportRequestManagerFragment getSupportRequestManagerFragment(FragmentActivity activity) { return getSupportRequestManagerFragment( activity.getSupportFragmentManager(), /*parentHint=*/ null, isActivityVisible(activity));} 在 fragmentGet 中首先通过 getRequestManagerFragment() 来获取一个命名为 FRAGMENT_TAG 的 fragment，如不存在，则新建一个 RequestManagerFragment，并添加到当前页面中。 这里我们就可以猜到了，Glide 是通过在页面中添加一个 Fragment 来动态监听页面的创建和销毁，从而达到依赖页面生命周期，动态管理请求的目的。 在 RequestManagerFragment 构造函数中，注入了一个生命周期监听器 ActivityFragmentLifecycle，并在 Fragment 各个生命周期回调中，调用了对应的方法。 而 ActivityFragmentLifecycle 也紧接着会调用 lifecycleListener 监听器，而这个监听器其实就是 RequestManger。如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445class ActivityFragmentLifecycle implements Lifecycle { private final Set&lt;LifecycleListener&gt; lifecycleListeners = Collections.newSetFromMap(new WeakHashMap&lt;LifecycleListener, Boolean&gt;()); private boolean isStarted; private boolean isDestroyed; @Override public void addListener(@NonNull LifecycleListener listener) { lifecycleListeners.add(listener); if (isDestroyed) { listener.onDestroy(); } else if (isStarted) { listener.onStart(); } else { listener.onStop(); } } @Override public void removeListener(@NonNull LifecycleListener listener) { lifecycleListeners.remove(listener); } void onStart() { isStarted = true; for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) { lifecycleListener.onStart(); } } void onStop() { isStarted = false; for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) { lifecycleListener.onStop(); } } void onDestroy() { isDestroyed = true; for (LifecycleListener lifecycleListener : Util.getSnapshot(lifecycleListeners)) { lifecycleListener.onDestroy(); } }} 最后，RequestManagerRetriever#fragmentGet，判断这个Fragment的RequestManager是否存在，否则创建一个RequestManager，并将生命周期注入，同时RquestManager构建时，将会通过addListener注入生命周期回调（具体可以查看RequestManger构造函数）。 最后，Glide#with终将得到一个RequestManager。 至此，Glide的加载过程就解析完毕了。总结一下整个流程： 通过AndroidManifest和@GlideModule注解获取用户自定义配置GlideModule，并调用其对应的方法 通过GlideBuilder构建Glide： 新建线程池 新建图片缓存池和缓存池 新建内存缓存管理器 新建默认本地缓存管理器 新建请求引擎Engine 新建RequestManger检索器 新建Glide Glide构造方法中，新建模型转换器，解码器，转码器，编码器，以及生成Glide上下文GlideContext 通过RequestManager检索器，建立生命周期监听，并建立一个RequestManager Glide与GlideApp如果在项目中已经使用了 Glide3.x ，并且想要升级到 Glide4.x ，那么你会发现，原来使用链式调用进行参数配置的方法已经被修改了，同一个封装到了 RequesOptions 中，如下：12345678910RequestOptions options = new RequestOptions() .centerCrop() .placeholder(R.mipmap.ic_launcher_round) .error(R.mipmap.ic_launcher) .priority(Priority.HIGH) .diskCacheStrategy(DiskCacheStrategy.NONE);Glide.with(this) .load(ImageConfig.URL_GIF) .apply(options) .into(iv); 这样的话升级后将导致大量的修改，当然你也可以自己封装一下，但是 Glide 已经为我们做好了兼容方案。 还记得初始化是通过 @GlideModule 注解来注册自定义配置吗？只要在项目中定义这么一个配置，那么 Glide 将会自动帮我们生成一个 GlideApp 模块，封装了 Glide3.x 中的调用方式。 123456public class GlideConfiguration extends AppGlideModule { @Override public void applyOptions(Context context, GlideBuilder builder) { }} 调用如下，还是原来的配方，还是熟悉的味道～ 1234567GlideApp.with(this) .load(ImageConfig.URL_WEBP) .sizeMultiplier(0.5f) .centerCrop() .diskCacheStrategy(DiskCacheStrategy.ALL) .error(R.mipmap.ic_launcher) .into(iv); 如果你还觉得不爽，那么你甚至可以把GlideApp直接修改为Glide，实现几乎“无缝对接”。当然，你还是要修改引用路径的。 1234567@GlideModule(glideName=\"Glide\")public class GlideConfiguration extends AppGlideModule { @Override public void applyOptions(Context context, GlideBuilder builder) { }} 来源： Android Glide4 源码解析–框架初始化","link":"/2018/04/26/Glide-源码解析-一/"},{"title":"Java初始化顺序","text":"无继承情况下的Java初始化顺序：123456789101112131415161718192021222324252627class Sample{ Sample(String s){ System.out.println(s); } Sample(){ System.out.println(\"Sample默认构造函数被调用\"); }}class Test{ static Sample sam=new Sample(\"静态成员sam初始化\"); Sample sam1=new Sample(\"sam1成员初始化\"); static{ System.out.println(\"static块执行\"); if(sam==null)System.out.println(\"sam is null\"); sam=new Sample(\"静态块内初始化sam成员变量\"); } Test(){ System.out.println(\"Test默认构造函数被调用\"); }}//主函数public static void main(String str[]){ Test a=new Test();} 输出结果为： 12345静态成员sam初始化 -----静态成员初始化static块执行 -----静态块被执行静态块内初始化sam成员变量 ----静态块执行sam1成员初始化 -----普通成员初始化Test默认构造函数被调用 -----构造函数执行 由此可以得出结论： 静态成员变量首先初始化（注意，Static可以看做一个静态成员，其执行顺序和其在类中申明的顺序有关） 普通成员初始化 执行构造函数。 继承情况下的初始化顺序12345678910111213141516171819202122232425262728293031323334class Test { static { System.out.println(&quot;父类static 块 1 执行&quot;); } static Sample staticSam1 = new Sample(&quot;父类 静态成员staticSam1初始化&quot;); Sample sam1 = new Sample(&quot;父类 sam1成员初始化&quot;); static Sample staticSam2 = new Sample(&quot;父类 静态成员staticSam2初始化&quot;); static { System.out.println(&quot;父类 static 块 2 执行&quot;); } Test() { System.out.println(&quot;父类 Test默认构造函数被调用&quot;); } Sample sam2 = new Sample(&quot;父类 sam2成员初始化&quot;);}class TestSub extends Test { static Sample staticSamSub = new Sample(&quot;子类 静态成员staticSamSub初始化&quot;); TestSub() { System.out.println(&quot;子类 TestSub 默认构造函数被调用&quot;); } Sample sam1 = new Sample(&quot;子类 sam1成员初始化&quot;); static Sample staticSamSub1 = new Sample(&quot;子类 静态成员staticSamSub1初始化&quot;); static { System.out.println(&quot;子类 static 块 执行&quot;);} Sample sam2 = new Sample(&quot;子类 sam2成员初始化&quot;);} 执行结果： 1234567891011121314151617父类 static 块 1 执行父类 静态成员staticSam1初始化父类 静态成员staticSam2初始化父类 static 块 2 执行 --------父类静态成员初始化子类 静态成员staticSamSub初始化子类 静态成员staticSamSub1初始化子类 static 块 执行 -------子类静态成员初始化父类 sam1成员初始化父类 sam2成员初始化父类 Test默认构造函数被调用 -------父类普通成员初始化和构造函数执行子类 sam1成员初始化子类 sam2成员初始化子类 TestSub 默认构造函数被调用 -------父类普通成员初始化和构造函数执行 由此得出Java初始化顺序结论： 继承体系的所有静态成员初始化（先父类，后子类） 父类初始化完成（普通成员的初始化–&gt;构造函数的调用） 子类初始化（普通成员–&gt;构造函数） Java初始化顺序如图：","link":"/2018/03/30/Java初始化顺序/"}],"tags":[{"name":"推荐","slug":"推荐","link":"/tags/推荐/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"动态权限申请","slug":"动态权限申请","link":"/tags/动态权限申请/"},{"name":"面试","slug":"面试","link":"/tags/面试/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Django","slug":"Django","link":"/tags/Django/"},{"name":"杂","slug":"杂","link":"/tags/杂/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"想说的","slug":"想说的","link":"/tags/想说的/"},{"name":"RecyclerView","slug":"RecyclerView","link":"/tags/RecyclerView/"},{"name":"bug","slug":"bug","link":"/tags/bug/"},{"name":"爬虫","slug":"爬虫","link":"/tags/爬虫/"},{"name":"Scrapy","slug":"Scrapy","link":"/tags/Scrapy/"},{"name":"摄影","slug":"摄影","link":"/tags/摄影/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"数据结构","slug":"数据结构","link":"/tags/数据结构/"},{"name":"排序","slug":"排序","link":"/tags/排序/"},{"name":"生活","slug":"生活","link":"/tags/生活/"},{"name":"北漂","slug":"北漂","link":"/tags/北漂/"},{"name":"编程思想","slug":"编程思想","link":"/tags/编程思想/"},{"name":"足球","slug":"足球","link":"/tags/足球/"},{"name":"文字","slug":"文字","link":"/tags/文字/"},{"name":"收藏","slug":"收藏","link":"/tags/收藏/"},{"name":"师太","slug":"师太","link":"/tags/师太/"},{"name":"感悟","slug":"感悟","link":"/tags/感悟/"},{"name":"随笔","slug":"随笔","link":"/tags/随笔/"},{"name":"Android开发艺术探索","slug":"Android开发艺术探索","link":"/tags/Android开发艺术探索/"},{"name":"Lottie","slug":"Lottie","link":"/tags/Lottie/"},{"name":"RxJava","slug":"RxJava","link":"/tags/RxJava/"}],"categories":[{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"Django","slug":"Python/Django","link":"/categories/Python/Django/"},{"name":"想说的","slug":"想说的","link":"/categories/想说的/"},{"name":"爬虫","slug":"Python/爬虫","link":"/categories/Python/爬虫/"},{"name":"摄影","slug":"摄影","link":"/categories/摄影/"},{"name":"算法","slug":"算法","link":"/categories/算法/"},{"name":"编程思想","slug":"编程思想","link":"/categories/编程思想/"},{"name":"Scrapy","slug":"Python/爬虫/Scrapy","link":"/categories/Python/爬虫/Scrapy/"},{"name":"足球","slug":"足球","link":"/categories/足球/"},{"name":"文字","slug":"文字","link":"/categories/文字/"},{"name":"生活","slug":"生活","link":"/categories/生活/"},{"name":"师太","slug":"师太","link":"/categories/师太/"},{"name":"收藏","slug":"文字/收藏","link":"/categories/文字/收藏/"},{"name":"数据结构","slug":"数据结构","link":"/categories/数据结构/"},{"name":"Java","slug":"Java","link":"/categories/Java/"}]}